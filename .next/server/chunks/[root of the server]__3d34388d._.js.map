{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 54, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/env.js"],"sourcesContent":["import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .default(\"development\"),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE;IAC3B;;;GAGC,GACD,QAAQ;QACN,cAAc,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG;QAC5B,UAAU,sIAAA,CAAA,IAAC,CACR,IAAI,CAAC;YAAC;YAAe;YAAQ;SAAa,EAC1C,OAAO,CAAC;IACb;IAEA;;;;GAIC,GACD,QAAQ;IAER;IAEA;;;GAGC,GACD,YAAY;QACV,cAAc,QAAQ,GAAG,CAAC,YAAY;QACtC,QAAQ;IAEV;IACA;;;GAGC,GACD,gBAAgB,CAAC,CAAC,QAAQ,GAAG,CAAC,mBAAmB;IACjD;;;GAGC,GACD,wBAAwB;AAC1B","debugId":null}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"@/env\";\n\nconst createPrismaClient = () =>\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"error\", \"warn\"] : [\"error\"],\n  });\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\n};\n\nexport const db = globalForPrisma.prisma ?? createPrismaClient();\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,qBAAqB,IACzB,IAAI,6HAAA,CAAA,eAAY,CAAC;QACf,KACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBAAgB;YAAC;YAAS;SAAO,GAAG;YAAC;SAAQ;IAClE;AAEF,MAAM,kBAAkB;AAIjB,MAAM,KAAK,gBAAgB,MAAM,IAAI;AAE5C,IAAI,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,cAAc,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 165, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/api/trpc.ts"],"sourcesContent":["/**\n * YOU PROBABLY DON'T NEED TO EDIT THIS FILE, UNLESS:\n * 1. You want to modify request context (see Part 1).\n * 2. You want to create a new middleware or type of procedure (see Part 3).\n *\n * TL;DR - This is where all the tRPC server stuff is created and plugged in. The pieces you will\n * need to use are documented accordingly near the end.\n */\nimport { initTRPC } from \"@trpc/server\";\nimport superjson from \"superjson\";\nimport { ZodError } from \"zod\";\n\nimport { db } from \"@/server/db\";\nimport { auth } from \"@clerk/nextjs/server\";\n\n/**\n * 1. CONTEXT\n *\n * This section defines the \"contexts\" that are available in the backend API.\n *\n * These allow you to access things when processing a request, like the database, the session, etc.\n *\n * This helper generates the \"internals\" for a tRPC context. The API handler and RSC clients each\n * wrap this and provides the required context.\n *\n * @see https://trpc.io/docs/server/context\n */\nexport const createTRPCContext = async (opts: { headers: Headers }) => {\n  const user = await auth()\n  return {\n    auth: user,\n    db,\n    ...opts,\n  };\n};\n\n/**\n * 2. INITIALIZATION\n *\n * This is where the tRPC API is initialized, connecting the context and transformer. We also parse\n * ZodErrors so that you get typesafety on the frontend if your procedure fails due to validation\n * errors on the backend.\n */\nconst t = initTRPC.context<typeof createTRPCContext>().create({\n  transformer: superjson,\n  errorFormatter({ shape, error }) {\n    return {\n      ...shape,\n      data: {\n        ...shape.data,\n        zodError:\n          error.cause instanceof ZodError ? error.cause.flatten() : null,\n      },\n    };\n  },\n});\n\n/**\n * Create a server-side caller.\n *\n * @see https://trpc.io/docs/server/server-side-calls\n */\nexport const createCallerFactory = t.createCallerFactory;\n\n/**\n * 3. ROUTER & PROCEDURE (THE IMPORTANT BIT)\n *\n * These are the pieces you use to build your tRPC API. You should import these a lot in the\n * \"/src/server/api/routers\" directory.\n */\n\n/**\n * This is how you create new routers and sub-routers in your tRPC API.\n *\n * @see https://trpc.io/docs/router\n */\nexport const createTRPCRouter = t.router;\n\n/**\n * Middleware for timing procedure execution and adding an artificial delay in development.\n *\n * You can remove this if you don't like it, but it can help catch unwanted waterfalls by simulating\n * network latency that would occur in production but not in local development.\n */\nconst timingMiddleware = t.middleware(async ({ next, path }) => {\n  const start = Date.now();\n\n  if (t._config.isDev) {\n    // artificial delay in dev\n    const waitMs = Math.floor(Math.random() * 400) + 100;\n    await new Promise((resolve) => setTimeout(resolve, waitMs));\n  }\n\n  const result = await next();\n\n  const end = Date.now();\n  console.log(`[TRPC] ${path} took ${end - start}ms to execute`);\n\n  return result;\n});\n\nconst isAuth = t.middleware(({ next, ctx }) => {\n  if (!ctx.auth?.userId) {\n    throw new Error(\"Unauthorized\");\n  }\n  return next({ ctx: { ...ctx, auth: ctx.auth! as Required<typeof ctx.auth> } });\n});\n\n/**\n * Public (unauthenticated) procedure\n *\n * This is the base piece you use to build new queries and mutations on your tRPC API. It does not\n * guarantee that a user querying is authorized, but you can still access user session data if they\n * are logged in.\n */\nexport const publicProcedure = t.procedure.use(timingMiddleware);\nexport const protectedProcedure = t.procedure.use(isAuth);\n"],"names":[],"mappings":"AAAA;;;;;;;CAOC;;;;;;;AACD;AAAA;AACA;AACA;AAEA;AACA;;;;;;AAcO,MAAM,oBAAoB,OAAO;IACtC,MAAM,OAAO,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IACtB,OAAO;QACL,MAAM;QACN,IAAA,qHAAA,CAAA,KAAE;QACF,GAAG,IAAI;IACT;AACF;AAEA;;;;;;CAMC,GACD,MAAM,IAAI,kMAAA,CAAA,WAAQ,CAAC,OAAO,GAA6B,MAAM,CAAC;IAC5D,aAAa,4IAAA,CAAA,UAAS;IACtB,gBAAe,EAAE,KAAK,EAAE,KAAK,EAAE;QAC7B,OAAO;YACL,GAAG,KAAK;YACR,MAAM;gBACJ,GAAG,MAAM,IAAI;gBACb,UACE,MAAM,KAAK,YAAY,sIAAA,CAAA,WAAQ,GAAG,MAAM,KAAK,CAAC,OAAO,KAAK;YAC9D;QACF;IACF;AACF;AAOO,MAAM,sBAAsB,EAAE,mBAAmB;AAcjD,MAAM,mBAAmB,EAAE,MAAM;AAExC;;;;;CAKC,GACD,MAAM,mBAAmB,EAAE,UAAU,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE;IACzD,MAAM,QAAQ,KAAK,GAAG;IAEtB,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE;QACnB,0BAA0B;QAC1B,MAAM,SAAS,KAAK,KAAK,CAAC,KAAK,MAAM,KAAK,OAAO;QACjD,MAAM,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;IACrD;IAEA,MAAM,SAAS,MAAM;IAErB,MAAM,MAAM,KAAK,GAAG;IACpB,QAAQ,GAAG,CAAC,CAAC,OAAO,EAAE,KAAK,MAAM,EAAE,MAAM,MAAM,aAAa,CAAC;IAE7D,OAAO;AACT;AAEA,MAAM,SAAS,EAAE,UAAU,CAAC,CAAC,EAAE,IAAI,EAAE,GAAG,EAAE;IACxC,IAAI,CAAC,IAAI,IAAI,EAAE,QAAQ;QACrB,MAAM,IAAI,MAAM;IAClB;IACA,OAAO,KAAK;QAAE,KAAK;YAAE,GAAG,GAAG;YAAE,MAAM,IAAI,IAAI;QAA+B;IAAE;AAC9E;AASO,MAAM,kBAAkB,EAAE,SAAS,CAAC,GAAG,CAAC;AACxC,MAAM,qBAAqB,EAAE,SAAS,CAAC,GAAG,CAAC","debugId":null}},
    {"offset": {"line": 350, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/embeddings.ts"],"sourcesContent":["import { OpenAIApi, Configuration } from \"openai-edge\";\n\nconst config = new Configuration({\n    apiKey: process.env.OPENAI_API_KEY,\n});\n\nconst openai = new OpenAIApi(config);\n\nexport async function getEmbeddings(text: string) {\n    try {\n        const response = await openai.createEmbedding({\n            model: \"text-embedding-ada-002\",\n            input: text.replace(/\\n/g, \" \"),\n        });\n        const result = await response.json();\n        // console.log(result)\n        return result.data[0].embedding as number[];\n    } catch (error) {\n        console.log(\"error calling openai embeddings api\", error);\n        throw error;\n    }\n}\n"],"names":[],"mappings":";;;AAAA;;AAEA,MAAM,SAAS,IAAI,kJAAA,CAAA,gBAAa,CAAC;IAC7B,QAAQ,QAAQ,GAAG,CAAC,cAAc;AACtC;AAEA,MAAM,SAAS,IAAI,kJAAA,CAAA,YAAS,CAAC;AAEtB,eAAe,cAAc,IAAY;IAC5C,IAAI;QACA,MAAM,WAAW,MAAM,OAAO,eAAe,CAAC;YAC1C,OAAO;YACP,OAAO,KAAK,OAAO,CAAC,OAAO;QAC/B;QACA,MAAM,SAAS,MAAM,SAAS,IAAI;QAClC,sBAAsB;QACtB,OAAO,OAAO,IAAI,CAAC,EAAE,CAAC,SAAS;IACnC,EAAE,OAAO,OAAO;QACZ,QAAQ,GAAG,CAAC,uCAAuC;QACnD,MAAM;IACV;AACJ","debugId":null}},
    {"offset": {"line": 379, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/orama.ts"],"sourcesContent":["import { create, insert, search, save, load, type AnyOrama } from \"@orama/orama\";\nimport { persist, restore } from \"@orama/plugin-data-persistence\";\nimport { db } from \"@/server/db\";\nimport { getEmbeddings } from \"@/lib/embeddings\";\n\nexport class OramaManager {\n    // @ts-ignore\n    private orama: AnyOrama;\n    private accountId: string;\n\n    constructor(accountId: string) {\n        this.accountId = accountId;\n    }\n\n    async initialize() {\n        const account = await db.account.findUnique({\n            where: { id: this.accountId },\n            select: { binaryIndex: true }\n        });\n\n        if (!account) throw new Error('Account not found');\n\n        if (account.binaryIndex) {\n            this.orama = await restore('json', account.binaryIndex as any);\n        } else {\n            this.orama = await create({\n                schema: {\n                    title: \"string\",\n                    body: \"string\",\n                    rawBody: \"string\",\n                    from: 'string',\n                    to: 'string[]',\n                    sentAt: 'string',\n                    embeddings: 'vector[1536]',\n                    threadId: 'string'\n                },\n            });\n            await this.saveIndex();\n        }\n    }\n\n    async insert(document: any) {\n        await insert(this.orama, document);\n        await this.saveIndex();\n    }\n\n    async vectorSearch({ prompt, numResults = 10 }: { prompt: string, numResults?: number }) {\n        const embeddings = await getEmbeddings(prompt)\n        const results = await search(this.orama, {\n            mode: 'hybrid',\n            term: prompt,\n            vector: {\n                value: embeddings,\n                property: 'embeddings'\n            },\n            similarity: 0.80,\n            limit: numResults,\n            // hybridWeights: {\n            //     text: 0.8,\n            //     vector: 0.2,\n            // }\n        })\n        // console.log(results.hits.map(hit => hit.document))\n        return results\n    }\n    async search({ term }: { term: string }) {\n        return await search(this.orama, {\n            term: term,\n        });\n    }\n\n    async saveIndex() {\n        const index = await persist(this.orama, 'json');\n        await db.account.update({\n            where: { id: this.accountId },\n            data: { binaryIndex: index as Buffer }\n        });\n    }\n}\n\n// Usage example:\nasync function main() {\n    const oramaManager = new OramaManager('67358');\n    await oramaManager.initialize();\n\n    // Insert a document\n    // const emails = await db.email.findMany({\n    //     where: {\n    //         thread: { accountId: '67358' }\n    //     },\n    //     select: {\n    //         subject: true,\n    //         bodySnippet: true,\n    //         from: { select: { address: true, name: true } },\n    //         to: { select: { address: true, name: true } },\n    //         sentAt: true,\n    //     },\n    //     take: 100\n    // })\n    // await Promise.all(emails.map(async email => {\n    //     // const bodyEmbedding = await getEmbeddings(email.bodySnippet || '');\n    //     // console.log(bodyEmbedding)\n    //     await oramaManager.insert({\n    //         title: email.subject,\n    //         body: email.bodySnippet,\n    //         from: `${email.from.name} <${email.from.address}>`,\n    //         to: email.to.map(t => `${t.name} <${t.address}>`),\n    //         sentAt: email.sentAt.getTime(),\n    //         // bodyEmbedding: bodyEmbedding,\n    //     })\n    // }))\n\n\n    // Search\n    const searchResults = await oramaManager.search({\n        term: \"cascading\",\n    });\n\n    console.log(searchResults.hits.map((hit) => hit.document));\n}\n\n// main().catch(console.error);\n"],"names":[],"mappings":";;;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;AAEO,MAAM;IACT,aAAa;IACL,MAAgB;IAChB,UAAkB;IAE1B,YAAY,SAAiB,CAAE;QAC3B,IAAI,CAAC,SAAS,GAAG;IACrB;IAEA,MAAM,aAAa;QACf,MAAM,UAAU,MAAM,qHAAA,CAAA,KAAE,CAAC,OAAO,CAAC,UAAU,CAAC;YACxC,OAAO;gBAAE,IAAI,IAAI,CAAC,SAAS;YAAC;YAC5B,QAAQ;gBAAE,aAAa;YAAK;QAChC;QAEA,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;QAE9B,IAAI,QAAQ,WAAW,EAAE;YACrB,IAAI,CAAC,KAAK,GAAG,MAAM,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,EAAE,QAAQ,QAAQ,WAAW;QAC1D,OAAO;YACH,IAAI,CAAC,KAAK,GAAG,MAAM,CAAA,GAAA,+JAAA,CAAA,SAAM,AAAD,EAAE;gBACtB,QAAQ;oBACJ,OAAO;oBACP,MAAM;oBACN,SAAS;oBACT,MAAM;oBACN,IAAI;oBACJ,QAAQ;oBACR,YAAY;oBACZ,UAAU;gBACd;YACJ;YACA,MAAM,IAAI,CAAC,SAAS;QACxB;IACJ;IAEA,MAAM,OAAO,QAAa,EAAE;QACxB,MAAM,CAAA,GAAA,+JAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,KAAK,EAAE;QACzB,MAAM,IAAI,CAAC,SAAS;IACxB;IAEA,MAAM,aAAa,EAAE,MAAM,EAAE,aAAa,EAAE,EAA2C,EAAE;QACrF,MAAM,aAAa,MAAM,CAAA,GAAA,0HAAA,CAAA,gBAAa,AAAD,EAAE;QACvC,MAAM,UAAU,MAAM,CAAA,GAAA,+JAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,KAAK,EAAE;YACrC,MAAM;YACN,MAAM;YACN,QAAQ;gBACJ,OAAO;gBACP,UAAU;YACd;YACA,YAAY;YACZ,OAAO;QAKX;QACA,qDAAqD;QACrD,OAAO;IACX;IACA,MAAM,OAAO,EAAE,IAAI,EAAoB,EAAE;QACrC,OAAO,MAAM,CAAA,GAAA,+JAAA,CAAA,SAAM,AAAD,EAAE,IAAI,CAAC,KAAK,EAAE;YAC5B,MAAM;QACV;IACJ;IAEA,MAAM,YAAY;QACd,MAAM,QAAQ,MAAM,CAAA,GAAA,2KAAA,CAAA,UAAO,AAAD,EAAE,IAAI,CAAC,KAAK,EAAE;QACxC,MAAM,qHAAA,CAAA,KAAE,CAAC,OAAO,CAAC,MAAM,CAAC;YACpB,OAAO;gBAAE,IAAI,IAAI,CAAC,SAAS;YAAC;YAC5B,MAAM;gBAAE,aAAa;YAAgB;QACzC;IACJ;AACJ;AAEA,iBAAiB;AACjB,eAAe;IACX,MAAM,eAAe,IAAI,aAAa;IACtC,MAAM,aAAa,UAAU;IAE7B,oBAAoB;IACpB,2CAA2C;IAC3C,eAAe;IACf,yCAAyC;IACzC,SAAS;IACT,gBAAgB;IAChB,yBAAyB;IACzB,6BAA6B;IAC7B,2DAA2D;IAC3D,yDAAyD;IACzD,wBAAwB;IACxB,SAAS;IACT,gBAAgB;IAChB,KAAK;IACL,gDAAgD;IAChD,6EAA6E;IAC7E,oCAAoC;IACpC,kCAAkC;IAClC,gCAAgC;IAChC,mCAAmC;IACnC,8DAA8D;IAC9D,6DAA6D;IAC7D,0CAA0C;IAC1C,2CAA2C;IAC3C,SAAS;IACT,MAAM;IAGN,SAAS;IACT,MAAM,gBAAgB,MAAM,aAAa,MAAM,CAAC;QAC5C,MAAM;IACV;IAEA,QAAQ,GAAG,CAAC,cAAc,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,IAAI,QAAQ;AAC5D,EAEA,+BAA+B","debugId":null}},
    {"offset": {"line": 505, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/turndown.ts"],"sourcesContent":["import TurndownService from 'turndown';\n\nexport const turndown = new TurndownService({\n    headingStyle: 'atx',\n    codeBlockStyle: 'fenced',\n    emDelimiter: '*',\n    strongDelimiter: '**',\n    bulletListMarker: '-',\n    linkStyle: 'inlined',\n});\n\n// Remove link tags\nturndown.addRule('linkRemover', {\n    filter: 'a',\n    replacement: (content) => content,\n});\n\n// Remove style tags\nturndown.addRule('styleRemover', {\n    filter: 'style',\n    replacement: () => '',\n});\n\n// Remove script tags\nturndown.addRule('scriptRemover', {\n    filter: 'script',\n    replacement: () => '',\n});\n\nturndown.addRule('imageRemover', {\n    filter: 'img',\n    replacement: (content) => content,\n});\n"],"names":[],"mappings":";;;AAAA;;AAEO,MAAM,WAAW,IAAI,mJAAA,CAAA,UAAe,CAAC;IACxC,cAAc;IACd,gBAAgB;IAChB,aAAa;IACb,iBAAiB;IACjB,kBAAkB;IAClB,WAAW;AACf;AAEA,mBAAmB;AACnB,SAAS,OAAO,CAAC,eAAe;IAC5B,QAAQ;IACR,aAAa,CAAC,UAAY;AAC9B;AAEA,oBAAoB;AACpB,SAAS,OAAO,CAAC,gBAAgB;IAC7B,QAAQ;IACR,aAAa,IAAM;AACvB;AAEA,qBAAqB;AACrB,SAAS,OAAO,CAAC,iBAAiB;IAC9B,QAAQ;IACR,aAAa,IAAM;AACvB;AAEA,SAAS,OAAO,CAAC,gBAAgB;IAC7B,QAAQ;IACR,aAAa,CAAC,UAAY;AAC9B","debugId":null}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/sync-to-db.ts"],"sourcesContent":["import { db } from '@/server/db';\nimport type { SyncUpdatedResponse, EmailMessage, EmailAddress, EmailAttachment, EmailHeader } from './types';\nimport pLimit from 'p-limit';\nimport { Prisma } from '@prisma/client';\nimport { OramaManager } from './orama';\nimport { getEmbeddings } from './embeddings';\nimport { turndown } from './turndown';\n\nasync function syncEmailsToDatabase(emails: EmailMessage[], accountId: string) {\n    console.log(`Syncing ${emails.length} emails to database`);\n    const limit = pLimit(10); // Process up to 10 emails concurrently\n\n    const oramaClient = new OramaManager(accountId)\n    oramaClient.initialize()\n\n    try {\n\n        async function syncToOrama() {\n            await Promise.all(emails.map(email => {\n                return limit(async () => {\n                    const body = turndown.turndown(email.body ?? email.bodySnippet ?? '')\n                    const payload = `From: ${email.from.name} <${email.from.address}>\\nTo: ${email.to.map(t => `${t.name} <${t.address}>`).join(', ')}\\nSubject: ${email.subject}\\nBody: ${body}\\n SentAt: ${new Date(email.sentAt).toLocaleString()}`\n                    const bodyEmbedding = await getEmbeddings(payload);\n                    await oramaClient.insert({\n                        title: email.subject,\n                        body: body,\n                        rawBody: email.bodySnippet ?? '',\n                        from: `${email.from.name} <${email.from.address}>`,\n                        to: email.to.map(t => `${t.name} <${t.address}>`),\n                        sentAt: new Date(email.sentAt).toLocaleString(),\n                        embeddings: bodyEmbedding,\n                        threadId: email.threadId\n                    })\n                })\n            }))\n        }\n\n        async function syncToDB() {\n            for (const [index, email] of emails.entries()) {\n                await upsertEmail(email, index, accountId);\n            }\n        }\n\n        await Promise.all([syncToOrama(), syncToDB()])\n\n        await oramaClient.saveIndex()\n    } catch (error) {\n        console.log('error', error)\n    }\n\n}\n\nasync function upsertEmail(email: EmailMessage, index: number, accountId: string) {\n    console.log(`Upserting email ${index + 1}`, JSON.stringify(email, null, 2));\n    try {\n\n        // determine email label type\n        let emailLabelType: 'inbox' | 'sent' | 'draft' = 'inbox'\n        if (email.sysLabels.includes('inbox') || email.sysLabels.includes('important')) {\n            emailLabelType = 'inbox'\n        } else if (email.sysLabels.includes('sent')) {\n            emailLabelType = 'sent'\n        } else if (email.sysLabels.includes('draft')) {\n            emailLabelType = 'draft'\n        }\n\n        // 1. Upsert EmailAddress records\n        const addressesToUpsert = new Map()\n        for (const address of [email.from, ...email.to, ...email.cc, ...email.bcc, ...email.replyTo]) {\n            addressesToUpsert.set(address.address, address);\n        }\n\n        const upsertedAddresses: (Awaited<ReturnType<typeof upsertEmailAddress>> | null)[] = [];\n\n        for (const address of addressesToUpsert.values()) {\n            const upsertedAddress = await upsertEmailAddress(address, accountId);\n            upsertedAddresses.push(upsertedAddress);\n        }\n\n        const addressMap = new Map(\n            upsertedAddresses.filter(Boolean).map(address => [address!.address, address])\n        );\n\n        const fromAddress = addressMap.get(email.from.address);\n        if (!fromAddress) {\n            console.log(`Failed to upsert from address for email ${email.bodySnippet}`);\n            return;\n        }\n\n        const toAddresses = email.to.map(addr => addressMap.get(addr.address)).filter(Boolean);\n        const ccAddresses = email.cc.map(addr => addressMap.get(addr.address)).filter(Boolean);\n        const bccAddresses = email.bcc.map(addr => addressMap.get(addr.address)).filter(Boolean);\n        const replyToAddresses = email.replyTo.map(addr => addressMap.get(addr.address)).filter(Boolean);\n\n        // 2. Upsert Thread\n        const thread = await db.thread.upsert({\n            where: { id: email.threadId },\n            update: {\n                subject: email.subject,\n                accountId,\n                lastMessageDate: new Date(email.sentAt),\n                done: false,\n                participantIds: [...new Set([\n                    fromAddress.id,\n                    ...toAddresses.map(a => a!.id),\n                    ...ccAddresses.map(a => a!.id),\n                    ...bccAddresses.map(a => a!.id)\n                ])]\n            },\n            create: {\n                id: email.threadId,\n                accountId,\n                subject: email.subject,\n                done: false,\n                draftStatus: emailLabelType === 'draft',\n                inboxStatus: emailLabelType === 'inbox',\n                sentStatus: emailLabelType === 'sent',\n                lastMessageDate: new Date(email.sentAt),\n                participantIds: [...new Set([\n                    fromAddress.id,\n                    ...toAddresses.map(a => a!.id),\n                    ...ccAddresses.map(a => a!.id),\n                    ...bccAddresses.map(a => a!.id)\n                ])]\n            }\n        });\n\n        // 3. Upsert Email\n        await db.email.upsert({\n            where: { id: email.id },\n            update: {\n                threadId: thread.id,\n                createdTime: new Date(email.createdTime),\n                lastModifiedTime: new Date(),\n                sentAt: new Date(email.sentAt),\n                receivedAt: new Date(email.receivedAt),\n                internetMessageId: email.internetMessageId,\n                subject: email.subject,\n                sysLabels: email.sysLabels,\n                keywords: email.keywords,\n                sysClassifications: email.sysClassifications,\n                sensitivity: email.sensitivity,\n                meetingMessageMethod: email.meetingMessageMethod,\n                fromId: fromAddress.id,\n                to: { set: toAddresses.map(a => ({ id: a!.id })) },\n                cc: { set: ccAddresses.map(a => ({ id: a!.id })) },\n                bcc: { set: bccAddresses.map(a => ({ id: a!.id })) },\n                replyTo: { set: replyToAddresses.map(a => ({ id: a!.id })) },\n                hasAttachments: email.hasAttachments,\n                internetHeaders: email.internetHeaders as any,\n                body: email.body,\n                bodySnippet: email.bodySnippet,\n                inReplyTo: email.inReplyTo,\n                references: email.references,\n                threadIndex: email.threadIndex,\n                nativeProperties: email.nativeProperties as any,\n                folderId: email.folderId,\n                omitted: email.omitted,\n                emailLabel: emailLabelType,\n            },\n            create: {\n                id: email.id,\n                emailLabel: emailLabelType,\n                threadId: thread.id,\n                createdTime: new Date(email.createdTime),\n                lastModifiedTime: new Date(),\n                sentAt: new Date(email.sentAt),\n                receivedAt: new Date(email.receivedAt),\n                internetMessageId: email.internetMessageId,\n                subject: email.subject,\n                sysLabels: email.sysLabels,\n                internetHeaders: email.internetHeaders as any,\n                keywords: email.keywords,\n                sysClassifications: email.sysClassifications,\n                sensitivity: email.sensitivity,\n                meetingMessageMethod: email.meetingMessageMethod,\n                fromId: fromAddress.id,\n                to: { connect: toAddresses.map(a => ({ id: a!.id })) },\n                cc: { connect: ccAddresses.map(a => ({ id: a!.id })) },\n                bcc: { connect: bccAddresses.map(a => ({ id: a!.id })) },\n                replyTo: { connect: replyToAddresses.map(a => ({ id: a!.id })) },\n                hasAttachments: email.hasAttachments,\n                body: email.body,\n                bodySnippet: email.bodySnippet,\n                inReplyTo: email.inReplyTo,\n                references: email.references,\n                threadIndex: email.threadIndex,\n                nativeProperties: email.nativeProperties as any,\n                folderId: email.folderId,\n                omitted: email.omitted,\n            }\n        });\n\n\n        const threadEmails = await db.email.findMany({\n            where: { threadId: thread.id },\n            orderBy: { receivedAt: 'asc' }\n        });\n\n        let threadFolderType = 'sent';\n        for (const threadEmail of threadEmails) {\n            if (threadEmail.emailLabel === 'inbox') {\n                threadFolderType = 'inbox';\n                break; // If any email is in inbox, the whole thread is in inbox\n            } else if (threadEmail.emailLabel === 'draft') {\n                threadFolderType = 'draft'; // Set to draft, but continue checking for inbox\n            }\n        }\n        await db.thread.update({\n            where: { id: thread.id },\n            data: {\n                draftStatus: threadFolderType === 'draft',\n                inboxStatus: threadFolderType === 'inbox',\n                sentStatus: threadFolderType === 'sent',\n            }\n        });\n\n        // 4. Upsert Attachments\n        for (const attachment of email.attachments) {\n            await upsertAttachment(email.id, attachment);\n        }\n    } catch (error) {\n        if (error instanceof Prisma.PrismaClientKnownRequestError) {\n            console.log(`Prisma error for email ${email.id}: ${error.message}`);\n        } else {\n            console.log(`Unknown error for email ${email.id}: ${error}`);\n        }\n    }\n}\n\nasync function upsertEmailAddress(address: EmailAddress, accountId: string) {\n    try {\n        const existingAddress = await db.emailAddress.findUnique({\n            where: { accountId_address: { accountId: accountId, address: address.address ?? \"\" } },\n        });\n\n        if (existingAddress) {\n            return await db.emailAddress.update({\n                where: { id: existingAddress.id },\n                data: { name: address.name, raw: address.raw },\n            });\n        } else {\n            return await db.emailAddress.create({\n                data: { address: address.address ?? \"\", name: address.name, raw: address.raw, accountId },\n            });\n        }\n    } catch (error) {\n        console.log(`Failed to upsert email address: ${error}`);\n        return null;\n    }\n}\nasync function upsertAttachment(emailId: string, attachment: EmailAttachment) {\n    try {\n        await db.emailAttachment.upsert({\n            where: { id: attachment.id ?? \"\" },\n            update: {\n                name: attachment.name,\n                mimeType: attachment.mimeType,\n                size: attachment.size,\n                inline: attachment.inline,\n                contentId: attachment.contentId,\n                content: attachment.content,\n                contentLocation: attachment.contentLocation,\n            },\n            create: {\n                id: attachment.id,\n                emailId,\n                name: attachment.name,\n                mimeType: attachment.mimeType,\n                size: attachment.size,\n                inline: attachment.inline,\n                contentId: attachment.contentId,\n                content: attachment.content,\n                contentLocation: attachment.contentLocation,\n            },\n        });\n    } catch (error) {\n        console.log(`Failed to upsert attachment for email ${emailId}: ${error}`);\n    }\n}\n\nexport { syncEmailsToDatabase };"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 887, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/account.ts"],"sourcesContent":["import type { EmailHeader, EmailMessage, SyncResponse, SyncUpdatedResponse } from '@/lib/types';\nimport { db } from '@/server/db';\nimport axios from 'axios';\nimport { syncEmailsToDatabase } from './sync-to-db';\n\nconst API_BASE_URL = 'https://api.aurinko.io/v1';\n\nclass Account {\n    private token: string;\n\n    constructor(token: string) {\n        this.token = token;\n    }\n\n    private async startSync(daysWithin: number): Promise<SyncResponse> {\n        const response = await axios.post<SyncResponse>(\n            `${API_BASE_URL}/email/sync`,\n            {},\n            {\n                headers: { Authorization: `Bearer ${this.token}` }, params: {\n                    daysWithin,\n                    bodyType: 'html'\n                }\n            }\n        );\n        return response.data;\n    }\n\n    async createSubscription() {\n        const webhookUrl = process.env.NODE_ENV === 'development' ? 'https://potatoes-calculator-reports-crisis.trycloudflare.com' : process.env.NEXT_PUBLIC_URL\n        const res = await axios.post('https://api.aurinko.io/v1/subscriptions',\n            {\n                resource: '/email/messages',\n                notificationUrl: webhookUrl + '/api/aurinko/webhook'\n            },\n            {\n                headers: {\n                    'Authorization': `Bearer ${this.token}`,\n                    'Content-Type': 'application/json'\n                }\n            }\n        )\n        return res.data\n    }\n\n    async syncEmails() {\n        const account = await db.account.findUnique({\n            where: {\n                token: this.token\n            },\n        })\n        if (!account) throw new Error(\"Invalid token\")\n        if (!account.nextDeltaToken) throw new Error(\"No delta token\")\n        let response = await this.getUpdatedEmails({ deltaToken: account.nextDeltaToken })\n        let allEmails: EmailMessage[] = response.records\n        let storedDeltaToken = account.nextDeltaToken\n        if (response.nextDeltaToken) {\n            storedDeltaToken = response.nextDeltaToken\n        }\n        while (response.nextPageToken) {\n            response = await this.getUpdatedEmails({ pageToken: response.nextPageToken });\n            allEmails = allEmails.concat(response.records);\n            if (response.nextDeltaToken) {\n                storedDeltaToken = response.nextDeltaToken\n            }\n        }\n\n        if (!response) throw new Error(\"Failed to sync emails\")\n\n\n        try {\n            await syncEmailsToDatabase(allEmails, account.id)\n        } catch (error) {\n            console.log('error', error)\n        }\n\n        // console.log('syncEmails', response)\n        await db.account.update({\n            where: {\n                id: account.id,\n            },\n            data: {\n                nextDeltaToken: storedDeltaToken,\n            }\n        })\n    }\n\n    async getUpdatedEmails({ deltaToken, pageToken }: { deltaToken?: string, pageToken?: string }): Promise<SyncUpdatedResponse> {\n        // console.log('getUpdatedEmails', { deltaToken, pageToken });\n        let params: Record<string, string> = {};\n        if (deltaToken) {\n            params.deltaToken = deltaToken;\n        }\n        if (pageToken) {\n            params.pageToken = pageToken;\n        }\n        const response = await axios.get<SyncUpdatedResponse>(\n            `${API_BASE_URL}/email/sync/updated`,\n            {\n                params,\n                headers: { Authorization: `Bearer ${this.token}` }\n            }\n        );\n        return response.data;\n    }\n\n    async performInitialSync() {\n        try {\n            // Start the sync process\n            const daysWithin = 3\n            let syncResponse = await this.startSync(daysWithin); // Sync emails from the last 7 days\n\n            // Wait until the sync is ready\n            while (!syncResponse.ready) {\n                await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for 1 second\n                syncResponse = await this.startSync(daysWithin);\n            }\n\n            // console.log('Sync is ready. Tokens:', syncResponse);\n\n            // Perform initial sync of updated emails\n            let storedDeltaToken: string = syncResponse.syncUpdatedToken\n            let updatedResponse = await this.getUpdatedEmails({ deltaToken: syncResponse.syncUpdatedToken });\n            // console.log('updatedResponse', updatedResponse)\n            if (updatedResponse.nextDeltaToken) {\n                storedDeltaToken = updatedResponse.nextDeltaToken\n            }\n            let allEmails: EmailMessage[] = updatedResponse.records;\n\n            // Fetch all pages if there are more\n            while (updatedResponse.nextPageToken) {\n                updatedResponse = await this.getUpdatedEmails({ pageToken: updatedResponse.nextPageToken });\n                allEmails = allEmails.concat(updatedResponse.records);\n                if (updatedResponse.nextDeltaToken) {\n                    storedDeltaToken = updatedResponse.nextDeltaToken\n                }\n            }\n\n            // console.log('Initial sync complete. Total emails:', allEmails.length);\n\n            // Store the nextDeltaToken for future incremental syncs\n\n\n            // Example of using the stored delta token for an incremental sync\n            // await this.performIncrementalSync(storedDeltaToken);\n            return {\n                emails: allEmails,\n                deltaToken: storedDeltaToken,\n            }\n\n        } catch (error) {\n            if (axios.isAxiosError(error)) {\n                console.error('Error during sync:', JSON.stringify(error.response?.data, null, 2));\n            } else {\n                console.error('Error during sync:', error);\n            }\n        }\n    }\n\n\n    async sendEmail({\n        from,\n        subject,\n        body,\n        inReplyTo,\n        references,\n        threadId,\n        to,\n        cc,\n        bcc,\n        replyTo,\n    }: {\n        from: EmailAddress;\n        subject: string;\n        body: string;\n        inReplyTo?: string;\n        references?: string;\n        threadId?: string;\n        to: EmailAddress[];\n        cc?: EmailAddress[];\n        bcc?: EmailAddress[];\n        replyTo?: EmailAddress;\n    }) {\n        try {\n            const response = await axios.post(\n                `${API_BASE_URL}/email/messages`,\n                {\n                    from,\n                    subject,\n                    body,\n                    inReplyTo,\n                    references,\n                    threadId,\n                    to,\n                    cc,\n                    bcc,\n                    replyTo: [replyTo],\n                },\n                {\n                    params: {\n                        returnIds: true\n                    },\n                    headers: { Authorization: `Bearer ${this.token}` }\n                }\n            );\n\n            console.log('sendmail', response.data)\n            return response.data;\n        } catch (error) {\n            if (axios.isAxiosError(error)) {\n                console.error('Error sending email:', JSON.stringify(error.response?.data, null, 2));\n            } else {\n                console.error('Error sending email:', error);\n            }\n            throw error;\n        }\n    }\n\n\n    async getWebhooks() {\n        type Response = {\n            records: {\n                id: number;\n                resource: string;\n                notificationUrl: string;\n                active: boolean;\n                failSince: string;\n                failDescription: string;\n            }[];\n            totalSize: number;\n            offset: number;\n            done: boolean;\n        }\n        const res = await axios.get<Response>(`${API_BASE_URL}/subscriptions`, {\n            headers: {\n                'Authorization': `Bearer ${this.token}`,\n                'Content-Type': 'application/json'\n            }\n        })\n        return res.data\n    }\n\n    async createWebhook(resource: string, notificationUrl: string) {\n        const res = await axios.post(`${API_BASE_URL}/subscriptions`, {\n            resource,\n            notificationUrl\n        }, {\n            headers: {\n                'Authorization': `Bearer ${this.token}`,\n                'Content-Type': 'application/json'\n            }\n        })\n        return res.data\n    }\n\n    async deleteWebhook(subscriptionId: string) {\n        const res = await axios.delete(`${API_BASE_URL}/subscriptions/${subscriptionId}`, {\n            headers: {\n                'Authorization': `Bearer ${this.token}`,\n                'Content-Type': 'application/json'\n            }\n        })\n        return res.data\n    }\n}\ntype EmailAddress = {\n    name: string;\n    address: string;\n}\n\nexport default Account;\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1112, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/stripe.ts"],"sourcesContent":["'server-only'\nimport Stripe from 'stripe'\n\nexport const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n    apiVersion: '2024-06-20',\n})\n\n"],"names":[],"mappings":";;;AACA;AADA;;AAGO,MAAM,SAAS,IAAI,wJAAA,CAAA,UAAM,CAAC,QAAQ,GAAG,CAAC,iBAAiB,EAAG;IAC7D,YAAY;AAChB","debugId":null}},
    {"offset": {"line": 1127, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/stripe-actions.ts"],"sourcesContent":["'use server'\n\nimport { auth } from \"@clerk/nextjs/server\";\nimport { stripe } from \"./stripe\";\nimport { redirect } from \"next/navigation\";\nimport { db } from \"@/server/db\";\n\nexport async function createCheckoutSession() {\n    const { userId } = await auth();\n\n    if (!userId) {\n        throw new Error('User not found');\n    }\n\n    const session = await stripe.checkout.sessions.create({\n        payment_method_types: ['card'],\n        line_items: [\n            {\n                price: process.env.STRIPE_PRICE_ID,\n                quantity: 1,\n            },\n        ],\n        mode: 'subscription',\n        success_url: `${process.env.NEXT_PUBLIC_URL}/mail`,\n        cancel_url: `${process.env.NEXT_PUBLIC_URL}/pricing`,\n        client_reference_id: userId.toString(),\n    });\n\n    redirect(session.url!);\n}\n\nexport async function createBillingPortalSession() {\n    const { userId } = await auth();\n    if (!userId) {\n        return false\n    }\n    const subscription = await db.stripeSubscription.findUnique({\n        where: { userId: userId },\n    });\n    if (!subscription?.customerId) {\n        throw new Error('Subscription not found');\n    }\n    const session = await stripe.billingPortal.sessions.create({\n        customer: subscription.customerId,\n        return_url: `${process.env.NEXT_PUBLIC_URL}/pricing`,\n    });\n    redirect(session.url!)\n}\n\nexport async function getSubscriptionStatus() {\n    const { userId } = await auth();\n    if (!userId) {\n        return false\n    }\n    const subscription = await db.stripeSubscription.findUnique({\n        where: { userId: userId },\n    });\n    if (!subscription) {\n        return false;\n    }\n    return subscription.currentPeriodEnd > new Date();\n}\n\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AAAA;AACA;;;;;;;;AAEO,eAAe,uCAAmB,GAAnB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAE5B,IAAI,CAAC,QAAQ;QACT,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,UAAU,MAAM,sHAAA,CAAA,SAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;QAClD,sBAAsB;YAAC;SAAO;QAC9B,YAAY;YACR;gBACI,OAAO,QAAQ,GAAG,CAAC,eAAe;gBAClC,UAAU;YACd;SACH;QACD,MAAM;QACN,aAAa,GAAG,QAAQ,GAAG,CAAC,eAAe,CAAC,KAAK,CAAC;QAClD,YAAY,GAAG,QAAQ,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAC;QACpD,qBAAqB,OAAO,QAAQ;IACxC;IAEA,CAAA,GAAA,uLAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG;AACxB;AAEO,eAAe,uCAAwB,GAAxB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAC5B,IAAI,CAAC,QAAQ;QACT,OAAO;IACX;IACA,MAAM,eAAe,MAAM,qHAAA,CAAA,KAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC;QACxD,OAAO;YAAE,QAAQ;QAAO;IAC5B;IACA,IAAI,CAAC,cAAc,YAAY;QAC3B,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,UAAU,MAAM,sHAAA,CAAA,SAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC;QACvD,UAAU,aAAa,UAAU;QACjC,YAAY,GAAG,QAAQ,GAAG,CAAC,eAAe,CAAC,QAAQ,CAAC;IACxD;IACA,CAAA,GAAA,uLAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG;AACxB;AAEO,eAAe,uCAAmB,GAAnB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAC5B,IAAI,CAAC,QAAQ;QACT,OAAO;IACX;IACA,MAAM,eAAe,MAAM,qHAAA,CAAA,KAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC;QACxD,OAAO;YAAE,QAAQ;QAAO;IAC5B;IACA,IAAI,CAAC,cAAc;QACf,OAAO;IACX;IACA,OAAO,aAAa,gBAAgB,GAAG,IAAI;AAC/C;;;IAtDsB;IAwBA;IAkBA;;AA1CA,iPAAA;AAwBA,iPAAA;AAkBA,iPAAA","debugId":null}},
    {"offset": {"line": 1217, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/app/constants.ts"],"sourcesContent":["export const FREE_CREDITS_PER_DAY = 15\nexport const FREE_ACCOUNTS_PER_USER = 1\nexport const PRO_ACCOUNTS_PER_USER = 3"],"names":[],"mappings":";;;;;AAAO,MAAM,uBAAuB;AAC7B,MAAM,yBAAyB;AAC/B,MAAM,wBAAwB","debugId":null}},
    {"offset": {"line": 1231, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/aurinko.ts"],"sourcesContent":["'use server'\nimport axios from 'axios'\nimport type { EmailMessage } from './types';\nimport { auth } from '@clerk/nextjs/server';\nimport { getSubscriptionStatus } from './stripe-actions';\nimport { db } from '@/server/db';\nimport { FREE_ACCOUNTS_PER_USER, PRO_ACCOUNTS_PER_USER } from '@/app/constants';\n\nexport const getAurinkoAuthorizationUrl = async (serviceType: 'Google' | 'Office365') => {\n    const { userId } = await auth()\n    if (!userId) throw new Error('User not found')\n\n    const user = await db.user.findUnique({\n        where: {\n            id: userId\n        }, select: { role: true }\n    })\n\n    if (!user) throw new Error('User not found')\n\n    const isSubscribed = await getSubscriptionStatus()\n\n    const accounts = await db.account.count({\n        where: { userId }\n    })\n\n    if (user.role === 'user') {\n        if (isSubscribed) {\n            if (accounts >= PRO_ACCOUNTS_PER_USER) {\n                throw new Error('You have reached the maximum number of accounts for your subscription')\n            }\n        } else {\n            if (accounts >= FREE_ACCOUNTS_PER_USER) {\n                throw new Error('You have reached the maximum number of accounts for your subscription')\n            }\n        }\n    }\n\n\n    const params = new URLSearchParams({\n        clientId: process.env.AURINKO_CLIENT_ID as string,\n        serviceType,\n        scopes: 'Mail.Read Mail.ReadWrite Mail.Send Mail.Drafts Mail.All',\n        responseType: 'code',\n        returnUrl: `${process.env.NEXT_PUBLIC_URL}/api/aurinko/callback`,\n    });\n\n    return `https://api.aurinko.io/v1/auth/authorize?${params.toString()}`;\n};\n\n\nexport const getAurinkoToken = async (code: string) => {\n    try {\n        const response = await axios.post(`https://api.aurinko.io/v1/auth/token/${code}`,\n            {},\n            {\n                auth: {\n                    username: process.env.AURINKO_CLIENT_ID as string,\n                    password: process.env.AURINKO_CLIENT_SECRET as string,\n                }\n            }\n        );\n\n        return response.data as {\n            accountId: number,\n            accessToken: string,\n            userId: string,\n            userSession: string\n        }\n    } catch (error) {\n        if (axios.isAxiosError(error)) {\n            console.error('Error fetching Aurinko token:', error.response?.data);\n        } else {\n            console.error('Unexpected error fetching Aurinko token:', error);\n        }\n    }\n}\n\nexport const getAccountDetails = async (accessToken: string) => {\n    try {\n        const response = await axios.get('https://api.aurinko.io/v1/account', {\n            headers: {\n                'Authorization': `Bearer ${accessToken}`\n            }\n        });\n        return response.data as {\n            email: string,\n            name: string\n        };\n    } catch (error) {\n        if (axios.isAxiosError(error)) {\n            console.error('Error fetching account details:', error.response?.data);\n        } else {\n            console.error('Unexpected error fetching account details:', error);\n        }\n        throw error;\n    }\n}\n\nexport const getEmailDetails = async (accessToken: string, emailId: string) => {\n    try {\n        const response = await axios.get<EmailMessage>(`https://api.aurinko.io/v1/email/messages/${emailId}`, {\n            params: {\n                loadInlines: true\n            },\n            headers: {\n                'Authorization': `Bearer ${accessToken}`\n            }\n        });\n        return response.data\n    } catch (error) {\n        if (axios.isAxiosError(error)) {\n            console.error('Error fetching email details:', error.response?.data);\n        } else {\n            console.error('Unexpected error fetching email details:', error);\n        }\n        throw error;\n    }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1361, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/types.ts"],"sourcesContent":["import { z } from \"zod\";\n\nexport interface SyncResponse {\n    syncUpdatedToken: string;\n    syncDeletedToken: string;\n    ready: boolean;\n}\nexport interface SyncUpdatedResponse {\n    nextPageToken?: string;\n    nextDeltaToken: string;\n    records: EmailMessage[];\n}\n\nexport const emailAddressSchema = z.object({\n    name: z.string(),\n    address: z.string(),\n})\n\nexport interface EmailMessage {\n    id: string;\n    threadId: string;\n    createdTime: string;\n    lastModifiedTime: string;\n    sentAt: string;\n    receivedAt: string;\n    internetMessageId: string;\n    subject: string;\n    sysLabels: Array<\"junk\" | \"trash\" | \"sent\" | \"inbox\" | \"unread\" | \"flagged\" | \"important\" | \"draft\">;\n    keywords: string[];\n    sysClassifications: Array<\"personal\" | \"social\" | \"promotions\" | \"updates\" | \"forums\">;\n    sensitivity: \"normal\" | \"private\" | \"personal\" | \"confidential\";\n    meetingMessageMethod?: \"request\" | \"reply\" | \"cancel\" | \"counter\" | \"other\";\n    from: EmailAddress;\n    to: EmailAddress[];\n    cc: EmailAddress[];\n    bcc: EmailAddress[];\n    replyTo: EmailAddress[];\n    hasAttachments: boolean;\n    body?: string;\n    bodySnippet?: string;\n    attachments: EmailAttachment[];\n    inReplyTo?: string;\n    references?: string;\n    threadIndex?: string;\n    internetHeaders: EmailHeader[];\n    nativeProperties: Record<string, string>;\n    folderId?: string;\n    omitted: Array<\"threadId\" | \"body\" | \"attachments\" | \"recipients\" | \"internetHeaders\">;\n}\n\nexport interface EmailAddress {\n    name?: string;\n    address: string;\n    raw?: string;\n}\n\nexport interface EmailAttachment {\n    id: string;\n    name: string;\n    mimeType: string;\n    size: number;\n    inline: boolean;\n    contentId?: string;\n    content?: string;\n    contentLocation?: string;\n}\n\nexport interface EmailHeader {\n    name: string;\n    value: string;\n}\n"],"names":[],"mappings":";;;AAAA;;AAaO,MAAM,qBAAqB,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;IACvC,MAAM,sIAAA,CAAA,IAAC,CAAC,MAAM;IACd,SAAS,sIAAA,CAAA,IAAC,CAAC,MAAM;AACrB","debugId":null}},
    {"offset": {"line": 1376, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/api/routers/mail.tsx"],"sourcesContent":["import { z } from \"zod\";\nimport { createTRPCRouter, protectedProcedure, publicProcedure } from \"../trpc\";\nimport Account from \"@/lib/account\";\nimport { syncEmailsToDatabase } from \"@/lib/sync-to-db\";\nimport { db } from \"@/server/db\";\nimport { getEmailDetails } from \"@/lib/aurinko\";\nimport type { Prisma } from \"@prisma/client\";\nimport { emailAddressSchema } from \"@/lib/types\";\nimport { FREE_CREDITS_PER_DAY } from \"@/app/constants\";\n\nexport const authoriseAccountAccess = async (accountId: string, userId: string) => {\n    const account = await db.account.findFirst({\n        where: {\n            id: accountId,\n            userId: userId,\n        },\n        select: {\n            id: true, emailAddress: true, name: true, token: true\n        }\n    })\n    if (!account) throw new Error(\"Invalid token\")\n    return account\n}\n\nconst inboxFilter = (accountId: string): Prisma.ThreadWhereInput => ({\n    accountId,\n    inboxStatus: true\n})\n\nconst sentFilter = (accountId: string): Prisma.ThreadWhereInput => ({\n    accountId,\n    sentStatus: true\n})\n\nconst draftFilter = (accountId: string): Prisma.ThreadWhereInput => ({\n    accountId,\n    draftStatus: true\n})\n\nexport const mailRouter = createTRPCRouter({\n    getAccounts: protectedProcedure.query(async ({ ctx }) => {\n        return await ctx.db.account.findMany({\n            where: {\n                userId: ctx.auth.userId,\n            }, select: {\n                id: true, emailAddress: true, name: true\n            }\n        })\n    }),\n    getNumThreads: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        tab: z.string()\n    })).query(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        let filter: Prisma.ThreadWhereInput = {}\n        if (input.tab === \"inbox\") {\n            filter = inboxFilter(account.id)\n        } else if (input.tab === \"sent\") {\n            filter = sentFilter(account.id)\n        } else if (input.tab === \"drafts\") {\n            filter = draftFilter(account.id)\n        }\n        return await ctx.db.thread.count({\n            where: filter\n        })\n    }),\n    getThreads: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        tab: z.string(),\n        done: z.boolean()\n    })).query(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n\n        let filter: Prisma.ThreadWhereInput = {}\n        if (input.tab === \"inbox\") {\n            filter = inboxFilter(account.id)\n        } else if (input.tab === \"sent\") {\n            filter = sentFilter(account.id)\n        } else if (input.tab === \"drafts\") {\n            filter = draftFilter(account.id)\n        }\n\n        filter.done = {\n            equals: input.done\n        }\n\n        const threads = await ctx.db.thread.findMany({\n            where: filter,\n            include: {\n                emails: {\n                    orderBy: {\n                        sentAt: \"asc\"\n                    },\n                    select: {\n                        from: true,\n                        body: true,\n                        bodySnippet: true,\n                        emailLabel: true,\n                        subject: true,\n                        sysLabels: true,\n                        id: true,\n                        sentAt: true\n                    }\n                }\n            },\n            take: 15,\n            orderBy: {\n                lastMessageDate: \"desc\"\n            }\n        })\n        return threads\n    }),\n\n    getThreadById: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        threadId: z.string()\n    })).query(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        return await ctx.db.thread.findUnique({\n            where: { id: input.threadId },\n            include: {\n                emails: {\n                    orderBy: {\n                        sentAt: \"asc\"\n                    },\n                    select: {\n                        from: true,\n                        body: true,\n                        subject: true,\n                        bodySnippet: true,\n                        emailLabel: true,\n                        sysLabels: true,\n                        id: true,\n                        sentAt: true\n                    }\n                }\n            },\n        })\n    }),\n\n    getReplyDetails: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        threadId: z.string(),\n        replyType: z.enum(['reply', 'replyAll'])\n    })).query(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n\n        const thread = await ctx.db.thread.findUnique({\n            where: { id: input.threadId },\n            include: {\n                emails: {\n                    orderBy: { sentAt: 'asc' },\n                    select: {\n                        from: true,\n                        to: true,\n                        cc: true,\n                        bcc: true,\n                        sentAt: true,\n                        subject: true,\n                        internetMessageId: true,\n                    },\n                },\n            },\n        });\n\n        if (!thread || thread.emails.length === 0) {\n            throw new Error(\"Thread not found or empty\");\n        }\n\n        const lastExternalEmail = thread.emails\n            .reverse()\n            .find(email => email.from.id !== account.id);\n\n        if (!lastExternalEmail) {\n            throw new Error(\"No external email found in thread\");\n        }\n\n        const allRecipients = new Set([\n            ...thread.emails.flatMap(e => [e.from, ...e.to, ...e.cc]),\n        ]);\n\n        if (input.replyType === 'reply') {\n            return {\n                to: [lastExternalEmail.from],\n                cc: [],\n                from: { name: account.name, address: account.emailAddress },\n                subject: `${lastExternalEmail.subject}`,\n                id: lastExternalEmail.internetMessageId\n            };\n        } else if (input.replyType === 'replyAll') {\n            return {\n                to: [lastExternalEmail.from, ...lastExternalEmail.to.filter(addr => addr.id !== account.id)],\n                cc: lastExternalEmail.cc.filter(addr => addr.id !== account.id),\n                from: { name: account.name, address: account.emailAddress },\n                subject: `${lastExternalEmail.subject}`,\n                id: lastExternalEmail.internetMessageId\n            };\n        }\n    }),\n\n    syncEmails: protectedProcedure.input(z.object({\n        accountId: z.string()\n    })).mutation(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        if (!account) throw new Error(\"Invalid token\")\n        const acc = new Account(account.token)\n        acc.syncEmails()\n    }),\n    setUndone: protectedProcedure.input(z.object({\n        threadId: z.string().optional(),\n        threadIds: z.array(z.string()).optional(),\n        accountId: z.string()\n    })).mutation(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        if (!account) throw new Error(\"Invalid token\")\n        if (input.threadId) {\n            await ctx.db.thread.update({\n                where: {\n                    id: input.threadId\n                },\n                data: {\n                    done: false\n                }\n            })\n        }\n        if (input.threadIds) {\n            await ctx.db.thread.updateMany({\n                where: {\n                    id: {\n                        in: input.threadIds\n                    }\n                },\n                data: {\n                    done: false\n                }\n            })\n        }\n    }),\n    setDone: protectedProcedure.input(z.object({\n        threadId: z.string().optional(),\n        threadIds: z.array(z.string()).optional(),\n        accountId: z.string()\n    })).mutation(async ({ ctx, input }) => {\n        if (!input.threadId && !input.threadIds) throw new Error(\"No threadId or threadIds provided\")\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        if (!account) throw new Error(\"Invalid token\")\n        if (input.threadId) {\n            await ctx.db.thread.update({\n                where: {\n                    id: input.threadId\n                },\n                data: {\n                    done: true\n                }\n            })\n        }\n        if (input.threadIds) {\n            await ctx.db.thread.updateMany({\n                where: {\n                    id: {\n                        in: input.threadIds\n                    }\n                },\n                data: {\n                    done: true\n                }\n            })\n        }\n    }),\n    getEmailDetails: protectedProcedure.input(z.object({\n        emailId: z.string(),\n        accountId: z.string()\n    })).query(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        return await getEmailDetails(account.token, input.emailId)\n    }),\n    sendEmail: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        body: z.string(),\n        subject: z.string(),\n        from: emailAddressSchema,\n        to: z.array(emailAddressSchema),\n        cc: z.array(emailAddressSchema).optional(),\n        bcc: z.array(emailAddressSchema).optional(),\n        replyTo: emailAddressSchema,\n        inReplyTo: z.string().optional(),\n        threadId: z.string().optional(),\n    })).mutation(async ({ ctx, input }) => {\n        const acc = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        const account = new Account(acc.token)\n        console.log('sendmail', input)\n        await account.sendEmail({\n            body: input.body,\n            subject: input.subject,\n            threadId: input.threadId,\n            to: input.to,\n            bcc: input.bcc,\n            cc: input.cc,\n            replyTo: input.replyTo,\n            from: input.from,\n            inReplyTo: input.inReplyTo,\n        })\n    }),\n    getEmailSuggestions: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        query: z.string(),\n    })).query(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        return await ctx.db.emailAddress.findMany({\n            where: {\n                accountId: input.accountId,\n                OR: [\n                    {\n                        address: {\n                            contains: input.query,\n                            mode: 'insensitive',\n                        },\n                    },\n                    {\n                        name: {\n                            contains: input.query,\n                            mode: 'insensitive',\n                        },\n                    },\n                ],\n            },\n            select: {\n                address: true,\n                name: true,\n            },\n            take: 10,\n        })\n    }),\n    getMyAccount: protectedProcedure.input(z.object({\n        accountId: z.string()\n    })).query(async ({ ctx, input }) => {\n        const account = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        return account\n    }),\n    getChatbotInteraction: protectedProcedure.query(async ({ ctx }) => {\n        const chatbotInteraction = await ctx.db.chatbotInteraction.findUnique({\n            where: {\n                day: new Date().toDateString(),\n                userId: ctx.auth.userId\n            }, select: { count: true }\n        })\n        const remainingCredits = FREE_CREDITS_PER_DAY - (chatbotInteraction?.count || 0)\n        return {\n            remainingCredits\n        }\n    }),\n});"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1757, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/api/routers/search.ts"],"sourcesContent":["import { z } from \"zod\";\nimport { createTRPCRouter, protectedProcedure } from \"../trpc\";\nimport { authoriseAccountAccess } from \"./mail\";\nimport { OramaManager } from \"@/lib/orama\";\nimport { getEmbeddings } from \"@/lib/embeddings\";\n\nexport const searchRouter = createTRPCRouter({\n    search: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        query: z.string(),\n    })).mutation(async ({ input, ctx }) => {\n        const account = await ctx.db.account.findFirst({\n            where: {\n                id: input.accountId,\n                userId: ctx.auth.userId,\n            },\n            select: {\n                id: true\n            }\n        })\n\n        if (!account) throw new Error(\"Invalid token\")\n        const oramaManager = new OramaManager(account.id);\n        await oramaManager.initialize();\n\n\n        const { query } = input;\n        const results = await oramaManager.search({ term: query });\n        return results\n    }),\n});\n"],"names":[],"mappings":";;;AAAA;AACA;AAEA;;;;AAGO,MAAM,eAAe,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IACzC,QAAQ,8HAAA,CAAA,qBAAkB,CAAC,KAAK,CAAC,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QACtC,WAAW,sIAAA,CAAA,IAAC,CAAC,MAAM;QACnB,OAAO,sIAAA,CAAA,IAAC,CAAC,MAAM;IACnB,IAAI,QAAQ,CAAC,OAAO,EAAE,KAAK,EAAE,GAAG,EAAE;QAC9B,MAAM,UAAU,MAAM,IAAI,EAAE,CAAC,OAAO,CAAC,SAAS,CAAC;YAC3C,OAAO;gBACH,IAAI,MAAM,SAAS;gBACnB,QAAQ,IAAI,IAAI,CAAC,MAAM;YAC3B;YACA,QAAQ;gBACJ,IAAI;YACR;QACJ;QAEA,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;QAC9B,MAAM,eAAe,IAAI,qHAAA,CAAA,eAAY,CAAC,QAAQ,EAAE;QAChD,MAAM,aAAa,UAAU;QAG7B,MAAM,EAAE,KAAK,EAAE,GAAG;QAClB,MAAM,UAAU,MAAM,aAAa,MAAM,CAAC;YAAE,MAAM;QAAM;QACxD,OAAO;IACX;AACJ","debugId":null}},
    {"offset": {"line": 1796, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/api/routers/webhooks.ts"],"sourcesContent":["import { z } from \"zod\";\nimport { createTRPCRouter, protectedProcedure } from \"../trpc\";\nimport { authoriseAccountAccess } from \"./mail\";\nimport Account from \"@/lib/account\";\n\nexport const webhooksRouter = createTRPCRouter({\n    getWebhooks: protectedProcedure.input(z.object({\n        accountId: z.string()\n    })).query(async ({ ctx, input }) => {\n        const acc = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        const account = new Account(acc.token)\n        return await account.getWebhooks()\n    }),\n    createWebhook: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        notificationUrl: z.string()\n    })).mutation(async ({ ctx, input }) => {\n        const acc = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        const account = new Account(acc.token)\n        return await account.createWebhook('/email/messages', input.notificationUrl)\n    }),\n    deleteWebhook: protectedProcedure.input(z.object({\n        accountId: z.string(),\n        webhookId: z.string()\n    })).mutation(async ({ ctx, input }) => {\n        const acc = await authoriseAccountAccess(input.accountId, ctx.auth.userId)\n        const account = new Account(acc.token)\n        return await account.deleteWebhook(input.webhookId)\n    })\n})"],"names":[],"mappings":";;;AAAA;AACA;AACA;AACA;;;;;AAEO,MAAM,iBAAiB,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IAC3C,aAAa,8HAAA,CAAA,qBAAkB,CAAC,KAAK,CAAC,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAC3C,WAAW,sIAAA,CAAA,IAAC,CAAC,MAAM;IACvB,IAAI,KAAK,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC3B,MAAM,MAAM,MAAM,CAAA,GAAA,0IAAA,CAAA,yBAAsB,AAAD,EAAE,MAAM,SAAS,EAAE,IAAI,IAAI,CAAC,MAAM;QACzE,MAAM,UAAU,IAAI,uHAAA,CAAA,UAAO,CAAC,IAAI,KAAK;QACrC,OAAO,MAAM,QAAQ,WAAW;IACpC;IACA,eAAe,8HAAA,CAAA,qBAAkB,CAAC,KAAK,CAAC,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAC7C,WAAW,sIAAA,CAAA,IAAC,CAAC,MAAM;QACnB,iBAAiB,sIAAA,CAAA,IAAC,CAAC,MAAM;IAC7B,IAAI,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC9B,MAAM,MAAM,MAAM,CAAA,GAAA,0IAAA,CAAA,yBAAsB,AAAD,EAAE,MAAM,SAAS,EAAE,IAAI,IAAI,CAAC,MAAM;QACzE,MAAM,UAAU,IAAI,uHAAA,CAAA,UAAO,CAAC,IAAI,KAAK;QACrC,OAAO,MAAM,QAAQ,aAAa,CAAC,mBAAmB,MAAM,eAAe;IAC/E;IACA,eAAe,8HAAA,CAAA,qBAAkB,CAAC,KAAK,CAAC,sIAAA,CAAA,IAAC,CAAC,MAAM,CAAC;QAC7C,WAAW,sIAAA,CAAA,IAAC,CAAC,MAAM;QACnB,WAAW,sIAAA,CAAA,IAAC,CAAC,MAAM;IACvB,IAAI,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,KAAK,EAAE;QAC9B,MAAM,MAAM,MAAM,CAAA,GAAA,0IAAA,CAAA,yBAAsB,AAAD,EAAE,MAAM,SAAS,EAAE,IAAI,IAAI,CAAC,MAAM;QACzE,MAAM,UAAU,IAAI,uHAAA,CAAA,UAAO,CAAC,IAAI,KAAK;QACrC,OAAO,MAAM,QAAQ,aAAa,CAAC,MAAM,SAAS;IACtD;AACJ","debugId":null}},
    {"offset": {"line": 1838, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/api/root.ts"],"sourcesContent":["import { createCallerFactory, createTRPCRouter } from \"@/server/api/trpc\";\nimport { mailRouter } from \"./routers/mail\";\nimport { searchRouter } from \"./routers/search\";\nimport { webhooksRouter } from \"./routers/webhooks\";\n\n/**\n * This is the primary router for your server.\n *\n * All routers added in /api/routers should be manually added here.\n */\nexport const appRouter = createTRPCRouter({\n  mail: mailRouter,\n  search: searchRouter,\n  webhooks: webhooksRouter\n});\n\n// export type definition of API\nexport type AppRouter = typeof appRouter;\n\n/**\n * Create a server-side caller for the tRPC API.\n * @example\n * const trpc = createCaller(createContext);\n * const res = await trpc.post.all();\n *       ^? Post[]\n */\nexport const createCaller = createCallerFactory(appRouter);\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAOO,MAAM,YAAY,CAAA,GAAA,8HAAA,CAAA,mBAAgB,AAAD,EAAE;IACxC,MAAM,0IAAA,CAAA,aAAU;IAChB,QAAQ,2IAAA,CAAA,eAAY;IACpB,UAAU,6IAAA,CAAA,iBAAc;AAC1B;AAYO,MAAM,eAAe,CAAA,GAAA,8HAAA,CAAA,sBAAmB,AAAD,EAAE","debugId":null}},
    {"offset": {"line": 1862, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/app/api/trpc/%5Btrpc%5D/route.ts"],"sourcesContent":["import { fetchRequestHandler } from \"@trpc/server/adapters/fetch\";\nimport { type NextRequest } from \"next/server\";\n\nimport { env } from \"@/env\";\nimport { appRouter } from \"@/server/api/root\";\nimport { createTRPCContext } from \"@/server/api/trpc\";\n\n/**\n * This wraps the `createTRPCContext` helper and provides the required context for the tRPC API when\n * handling a HTTP request (e.g. when you make requests from Client Components).\n */\nconst createContext = async (req: NextRequest) => {\n  return createTRPCContext({\n    headers: req.headers,\n  });\n};\n\nconst handler = async (req: NextRequest) =>\n  fetchRequestHandler({\n    endpoint: \"/api/trpc\",\n    req,\n    router: appRouter,\n    createContext: async () => await createContext(req),\n    onError:\n      env.NODE_ENV === \"development\"\n        ? ({ path, error }) => {\n            console.error(\n              `❌ tRPC failed on ${path ?? \"<no-path>\"}: ${error.message}`,\n            );\n          }\n        : undefined,\n  });\n\nexport { handler as GET, handler as POST };\n"],"names":[],"mappings":";;;;AAAA;AAAA;AAGA;AACA;AACA;;;;;AAEA;;;CAGC,GACD,MAAM,gBAAgB,OAAO;IAC3B,OAAO,CAAA,GAAA,8HAAA,CAAA,oBAAiB,AAAD,EAAE;QACvB,SAAS,IAAI,OAAO;IACtB;AACF;AAEA,MAAM,UAAU,OAAO,MACrB,CAAA,GAAA,uLAAA,CAAA,sBAAmB,AAAD,EAAE;QAClB,UAAU;QACV;QACA,QAAQ,8HAAA,CAAA,YAAS;QACjB,eAAe,UAAY,MAAM,cAAc;QAC/C,SACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBACb,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE;YACd,QAAQ,KAAK,CACX,CAAC,iBAAiB,EAAE,QAAQ,YAAY,EAAE,EAAE,MAAM,OAAO,EAAE;QAE/D,IACA;IACR","debugId":null}}]
}