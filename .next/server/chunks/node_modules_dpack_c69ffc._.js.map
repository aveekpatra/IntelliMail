{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/serialize.js"],"sourcesContent":["\"use strict\"\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\nvar ERROR_METADATA = 500\r\n\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\nvar nextId = 1\r\nvar iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '__iterator_symbol__'\r\n\r\nfunction createSerializer(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar extendedTypes = options.converterByConstructor\r\n\tif (!extendedTypes) {\r\n\t\textendedTypes = new Map()\r\n\t}\r\n\textendedTypes.set(Map, {\r\n\t\tname: 'Map',\r\n\t\ttoValue: writeMap\r\n\t})\r\n\textendedTypes.set(Set, {\r\n\t\tname: 'Set',\r\n\t\ttoValue: writeSet\r\n\t})\r\n\textendedTypes.set(Date, {\r\n\t\tname: 'Date',\r\n\t\ttoValue: writeDate\r\n\t})\r\n\tvar avoidShareUpdate = options.outlet || options.avoidShareUpdate\r\n\tvar charEncoder = (typeof global != 'undefined' && global.Buffer && !(options && options.encoding === 'utf16le')) ? exports.nodeCharEncoder(options) : browserCharEncoder(options)\r\n\tvar writeString = charEncoder.writeString\r\n\tvar writeToken = charEncoder.writeToken\r\n\tvar startSequence = charEncoder.startSequence\r\n\tvar endSequence = charEncoder.endSequence\r\n\tvar writeBuffer = charEncoder.writeBuffer\r\n\tvar forProperty = options.forProperty\r\n\tvar propertyUsed\r\n\tvar valueUsed\r\n\tif (options.shared) {\r\n\t\tpropertyUsed = options.shared.propertyUsed\r\n\t\tvalueUsed = options.shared.propertyUsed\r\n\t}\r\n\tvar pendingEncodings = []\r\n\tvar nextPropertyIndex = 8\r\n\tvar property\r\n\tvar bufferSymbol = exports.bufferSymbol || '_bufferSymbol_'\r\n\tvar targetSymbol = exports.targetSymbol || '_targetSymbol_'\r\n\tvar propertyComparisons = 0\r\n\tvar serializerId = nextId++\r\n\r\n\tvar writers = [\r\n\t\t0, 1, 2, 3, 4 , 5,\r\n\t\twriteAsDefault,\r\n\t\twriteAsArray,\r\n\t\twriteAsReferencing,\r\n\t\twriteAsNumber,\r\n\t\twriteOnlyNull\r\n\t]\r\n\t// write a rudimentary number\r\n\tfunction writeNumber(number) {\r\n\t\twriteToken(NUMBER_CODE, number)\r\n\t}\r\n\t// write a rudimentary string\r\n\tfunction writeInlineString(string) {\r\n\t\twriteToken(STRING_CODE, string.length)\r\n\t\twriteString(string)\r\n\t}\r\n\r\n\t// writing any value in referencing serialization type mode\r\n\tfunction writeAsReferencing(value) {\r\n\t\tvar type, values = property.values\r\n\t\tif (values) {\r\n\t\t\tif (values.resetTo > -1 && values.serializer !== serializerId) {\r\n\t\t\t\t// if this is a shared values, need to reset on each serialization\r\n\t\t\t\tvalues.serializer = serializerId\r\n\t\t\t\tif (values.resetTo < values.length)\r\n\t\t\t\t\tvalues.length = values.resetTo\r\n\t\t\t\twriteToken(TYPE_CODE, REFERENCING_POSITION)\r\n\t\t\t\twriteToken(NUMBER_CODE, values.resetTo)\r\n\t\t\t}\r\n\t\t\tvar reference = values.indexOf(value)\r\n\t\t\tif (reference > -1) {\r\n\t\t\t\treturn writeNumber(reference)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif ((type = typeof value) === 'string' || type ==='object' && value) {\r\n\t\t\tif (property.writeSharedValue) {\r\n\t\t\t\tif (property.writeSharedValue(value, writeToken, serializerId))\r\n\t\t\t\t\treturn\r\n\t\t\t} else if (values) {\r\n\t\t\t\tvar index = values.length\r\n\t\t\t\tif (index < 12)\r\n\t\t\t\t\tvalues[index] = value\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (type === 'string') {\r\n\t\t\twriteInlineString(value)\r\n\t\t} else {\r\n\t\t\twriteAsDefault(value)\r\n\t\t}\r\n\t}\r\n\r\n\t// writing any value in number serialization type mode\r\n\tfunction writeAsNumber(number) {\r\n\t\tvar type = typeof number\r\n\t\tif (type === 'number') {\r\n\t\t\tif (number >>> 0 === number || (number > 0 && number < 0x400000000000 && number % 1 === 0)) {\r\n\t\t\t\t// 46 bit unsigned integer\r\n\t\t\t\twriteToken(NUMBER_CODE, number)\r\n\t\t\t} else {\r\n\t\t\t\t// decimal number serialized as a string\r\n\t\t\t\tvar asString = number.toString()\r\n\t\t\t\twriteInlineString(asString)\r\n\t\t\t}\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteAsDefault(number)\r\n\t\t} else {\r\n\t\t\twriteTypedValue(number)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedValue(value) {\r\n\t\tif (value === null)\r\n\t\t\twriteToken(TYPE_CODE, NULL)\r\n\t\telse if (value === false)\r\n\t\t\twriteToken(TYPE_CODE, FALSE)\r\n\t\telse if (value === true)\r\n\t\t\twriteToken(TYPE_CODE, TRUE)\r\n\t\telse if (value === undefined)\r\n\t\t\twriteToken(TYPE_CODE, UNDEFINED)\r\n\t\telse {\r\n\t\t\twriteTypedNonConstant(value)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeTypedNonConstant(value) {\r\n\t\tvar type = typeof value\r\n\t\tvar extendedType\r\n\t\tif (type === 'object') {\r\n\t\t\tif (value) {\r\n\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t// leave type as is\r\n\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\ttype = 'array'\r\n\t\t\t\t} else {\r\n\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property.type === type) {\r\n\t\t\t\t\t\t\t// if we are the right type after doing the conversion, go back to the original property to serialize\r\n\t\t\t\t\t\t\tif (property.extendedType !== extendedType) {\r\n\t\t\t\t\t\t\t\tproperty.extendedType = extendedType\r\n\t\t\t\t\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn writers[property.code](value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t} else { // null\r\n\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t}\r\n\t\t} else if (type === 'boolean') {\r\n\t\t\ttype = 'undefined'\r\n\t\t} else if (type === 'function') {\r\n\t\t\tvalue = value.toString()\r\n\t\t\ttype = 'string'\r\n\t\t}\r\n\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\twriters[property.code](value)\r\n\t}\r\n\r\n\tfunction writeOnlyNull() {\r\n\t\twriteToken(TYPE_CODE, NULL)\r\n\t}\r\n\r\n\t// writing any value in default serialization type mode\r\n\tfunction writeAsDefault(value, isRoot) {\r\n\t\tvar type = typeof value\r\n\t\tif (type === 'object') {\r\n\t\t\tif (!value) {\r\n\t\t\t\treturn writeToken(TYPE_CODE, NULL)\r\n\t\t\t}\r\n\t\t\t// else continue with the object code\r\n\t\t} else if (type === 'string') {\r\n\t\t\treturn writeInlineString(value)\r\n\t\t} else if (type === 'number' && (value >>> 0 === value || (value > 0 && value < 0x400000000000 && value % 1 === 0))) {\r\n\t\t\t// 46 bit unsigned integer\r\n\t\t\treturn writeToken(NUMBER_CODE, value)\r\n\t\t} else {\r\n\t\t\treturn writeTypedValue(value)\r\n\t\t}\r\n\t\tvar object = value\r\n\t\tvar constructor = object.constructor\r\n\t\tvar notPlainObject\r\n\t\tif (object[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(value)\r\n\t\t} else if (constructor === Object) {\r\n\t\t\tnotPlainObject = false\r\n\t\t} else if (constructor === Array) {\r\n\t\t\tproperty = writeProperty(property.key, 'array')\r\n\t\t\treturn writers[property.code](value)\r\n\t\t} else {\r\n\t\t\tif (object.then) {\r\n\t\t\t\treturn writeBlockReference(value)\r\n\t\t\t}\r\n\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\tif (extendedType) {\r\n\t\t\t\tif (extendedType.toValue) {\r\n\t\t\t\t\treturn writeTypedValue(object)\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (object[iteratorSymbol]) {\r\n\t\t\t\t\tproperty = writeProperty(property.key, 'array')\r\n\t\t\t\t\treturn writeAsIterable(object, isRoot)\r\n\t\t\t\t}\r\n\t\t\t\textendedTypes.set(constructor, extendedType = {\r\n\t\t\t\t\tname: constructor.name\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (property.constructs !== constructor) {\r\n\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\twriteInlineString(extendedType.name)\r\n\t\t\t\tproperty.constructs = constructor\r\n\t\t\t}\r\n\t\t\tnotPlainObject = true\r\n\t\t}\r\n\t\tvar thisProperty = property\r\n\t\tif (thisProperty.resetTo < thisProperty.length && thisProperty.serializer != serializerId) {\r\n\t\t\tthisProperty.length = thisProperty.resetTo\r\n\t\t\tthisProperty.serializer = serializerId\r\n\t\t}\r\n\t\tstartSequence()\r\n\t\tvar i = 0\r\n\t\t//var sparse = false // densely packed property references can be searched more quickly\r\n\t\tvar resumeIndex = -2 // -2 denotes densely packed property references \r\n\t\tvar propertyIndex = 0\r\n\t\tfor (var key in object) {\r\n\t\t\tif (notPlainObject && !object.hasOwnProperty(key))\r\n\t\t\t\tcontinue\r\n\t\t\tvar value = object[key]\r\n\t\t\ttype = typeof value\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tvar constructor\r\n\t\t\tvar extendedType = false\r\n\t\t\tif (type === 'object') {\r\n\t\t\t\tif (value) {\r\n\t\t\t\t\tconstructor = value.constructor\r\n\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\textendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (value[iteratorSymbol] && !value.then) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else { // null\r\n\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined (and boolean), both constants that can go in any type\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property || property.key !== key ||\r\n\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\tvar lastPropertyIndex = propertyIndex\r\n\t\t\t\t// property doesn't match, search for it through existing properties\r\n\t\t\t\t// note that we are starting at the current propertyIndex, so this makes the assumption that\r\n\t\t\t\t// properties are rarely ever swapped, so possible property slots are always forward\r\n\t\t\t\tif (resumeIndex > -2)\r\n\t\t\t\t\tpropertyIndex = resumeIndex\r\n\t\t\t\tdo {\r\n\t\t\t\t\tproperty = thisProperty[++propertyIndex]\r\n\t\t\t\t} while(property && (property.key !== key ||\r\n\t\t\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\tif (property) {\r\n\t\t\t\t\t// found a match, reference it\r\n\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (thisProperty.getProperty) {\r\n\t\t\t\t\t// a shared property, let it allocate ids\r\n\t\t\t\t\tproperty = thisProperty.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex)\r\n\t\t\t\t\tpropertyIndex = property.index\r\n\t\t\t\t\tif (lastPropertyIndex !== propertyIndex && resumeIndex === -2) {\r\n\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (lastPropertyIndex === thisProperty.length) {\r\n\t\t\t\t\t\tpropertyIndex = lastPropertyIndex\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex = thisProperty.length)\r\n\t\t\t\t\t\tif (resumeIndex === -2) {\r\n\t\t\t\t\t\t\tresumeIndex = lastPropertyIndex - 1\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\tdebugger\r\n\t\t\t\t\t\tthrow new Error('overwriting frozen property')\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tproperty = thisProperty[propertyIndex] = writeProperty(key, type, extendedType)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (propertyUsed)\r\n\t\t\t\tpropertyUsed(property, object, serializerId, i)\r\n//\t\t\tif (property.resumeIndex) // TODO: add a flag to enable this when property ordering can be assumed\r\n//\t\t\t\tresumeIndex = property.resumeIndex\r\n\t\t\tvar code = property.code\r\n\t\t\tif (code > 7) {\r\n\t\t\t\tif (code === 8)\r\n\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t} else {\r\n\t\t\t\tif (code === 6) \r\n\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\telse\r\n\t\t\t\t\twriteAsArray(value)\r\n\t\t\t}\r\n\t\t\tpropertyIndex++\r\n\t\t\ti++\r\n\t\t}\r\n\t\tproperty = thisProperty\r\n\t\tendSequence(i)\r\n\t}\r\n\r\n\tfunction writeProperty(key, type, extendedType) {\r\n\t\tvar property\r\n\t\tproperty = []\r\n\t\tproperty.key = key\r\n\t\tproperty.type = type\r\n\t\tif (type === 'string') {\r\n\t\t\twriteToken(TYPE_CODE, REFERENCING_TYPE)\r\n\t\t\tproperty.values = []\r\n\t\t\tproperty.code = REFERENCING_TYPE\r\n\t\t} else if (type === 'number') {\r\n\t\t\twriteToken(TYPE_CODE, NUMBER_TYPE)\r\n\t\t\tproperty.code = NUMBER_TYPE\r\n\t\t} else if (type === 'object') {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else if (type === 'array') {\r\n\t\t\twriteToken(TYPE_CODE, ARRAY_TYPE)\r\n\t\t\tproperty.code = ARRAY_TYPE\r\n\t\t} else if (type === 'boolean' || type === 'undefined') {\r\n\t\t\tproperty.type = 'object'\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t} else {\r\n\t\t\twriteToken(TYPE_CODE, DEFAULT_TYPE)\r\n\t\t\tproperty.code = 10\r\n\t\t\tconsole.error('Unable to write value of type ' + type)\r\n\t\t}\r\n\r\n\t\tif (typeof key === 'string') {\r\n\t\t\twriteInlineString(key)\r\n\t\t} else if (!(key === null && (type === 'object' || type === 'array'))) { // if key is null followed by sequence, we can elide the key\r\n\t\t\twriteAsDefault(key)\r\n\t\t}\r\n\t\tif (extendedType) {\r\n\t\t\tproperty.extendedType = extendedType\r\n\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\twriteInlineString(extendedType.name)\r\n\t\t}\r\n\t\treturn property\r\n\t}\r\n\r\n\tfunction writeAsIterable(iterable, isRoot, iterator) {\r\n\t\t// TODO: With top level iterables we could pause for back-pressure\r\n\t\ttry {\r\n\t\t\tif (!iterator) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t\t\titerator = iterable[iteratorSymbol]()\r\n\t\t\t}\r\n\t\t\tvar arrayProperty = property\r\n\t\t\tproperty = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property\r\n\t\t\t// write out the elements\r\n\t\t\tvar result\r\n\t\t\twhile(!(result = iterator.next()).done) {\r\n\t\t\t\twriters[property.code](result.value, arrayProperty)\r\n\t\t\t\tif (isRoot && charEncoder.hasWritten) {\r\n\t\t\t\t\tcharEncoder.hasWritten = false // reset this property\r\n\t\t\t\t\tproperty = arrayProperty // restore current property\r\n\t\t\t\t\tpendingEncodings.unshift({\r\n\t\t\t\t\t\tthen: function(callback) {\r\n\t\t\t\t\t\t\twriteAsIterable(null, true, iterator)\r\n\t\t\t\t\t\t\treturn callback()\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t})\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(error) {\r\n\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\twriteToken(NUMBER_CODE, ERROR_METADATA)\r\n\t\t\twriteAsDefault(Object.assign(new ((typeof error == 'object' && error) ? error.constructor : Error)(), {\r\n\t\t\t\tname: error && error.name, // make these enumerable so they will serialize\r\n\t\t\t\tmessage: error && error.message || error\r\n\t\t\t}))\r\n\t\t\tthrow error\r\n\t\t}\r\n\t\tif (property !== arrayProperty.child) {\r\n\t\t\t// TODO: This really needs to happen immediately when a property changes, to match the parsing behavior\r\n\t\t\tarrayProperty.child = property\r\n\t\t}\r\n\t\tproperty = arrayProperty // restore current property\r\n\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t}\r\n\r\n\tfunction writeAsArray(array) {\r\n\t\tif (!array) {\r\n\t\t\twriteTypedValue(array)\r\n\t\t} else if (array[targetSymbol]) {\r\n\t\t\treturn writeBlockReference(array)\r\n\t\t} else if (array.constructor === Array) { // check to make sure it is an array\r\n\t\t\tvar length = array.length\r\n\t\t\tvar needsClosing\r\n\t\t\tif (length > 11) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE) // start sequence <\r\n\t\t\t\tneedsClosing = true\r\n\t\t\t} else {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, length) // write out the header token\r\n\t\t\t}\r\n\t\t\tvar arrayProperty = property\r\n\t\t\tproperty = arrayProperty[0] // set the current property to the child property\r\n\t\t\t// check to see if needs to be reset before starting\r\n\t\t\tif (arrayProperty.resetTo < arrayProperty.length && arrayProperty.serializer != serializerId) {\r\n\t\t\t\tarrayProperty.length = arrayProperty.resetTo\r\n\t\t\t\tarrayProperty.serializer = serializerId\r\n\t\t\t}\r\n\t\t\tvar propertyIndex = 0\r\n\t\t\t// write out the elements\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tvar value = array[i]\r\n\t\t\t\tvar type = typeof value\r\n\t\t\t\tif (type === 'object') {\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tvar constructor = value.constructor\r\n\t\t\t\t\t\tif (constructor === Object) {\r\n\t\t\t\t\t\t\t// leave type as is\r\n\t\t\t\t\t\t} else if (constructor === Array) {\r\n\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvar extendedType = extendedTypes.get(constructor)\r\n\t\t\t\t\t\t\tif (extendedType && extendedType.toValue) {\r\n\t\t\t\t\t\t\t\tvalue = extendedType.toValue(value)\r\n\t\t\t\t\t\t\t\ttype = typeof value // go through the same logic adjustment here\r\n\t\t\t\t\t\t\t\tif (value && type === 'object' && value.constructor === Array) {\r\n\t\t\t\t\t\t\t\t\ttype = 'array'\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\textendedType = false\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else { // null\r\n\t\t\t\t\t\ttype = 'undefined' // treat null as same type as undefined, both constants\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (!property) {\r\n\t\t\t\t\tif (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, 0)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (type === 'string' || type === 'number' || type === 'array')\r\n\t\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\t// default doesn't have to be written\r\n\t\t\t\t\t\t\tproperty = []\r\n\t\t\t\t\t\t\tproperty.type = type\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t\tproperty.code = DEFAULT_TYPE\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tarrayProperty[0] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t(extendedType && property.extendedType !== constructor)) {\r\n\t\t\t\t\tpropertyIndex = -1\r\n\t\t\t\t\tdo {\r\n\t\t\t\t\t\tproperty = arrayProperty[++propertyIndex]\r\n\t\t\t\t\t} while(property && ((property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number')) ||\r\n\t\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t} else if (arrayProperty.getProperty) {\r\n\t\t\t\t\t\t// a shared property\r\n\t\t\t\t\t\tproperty = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, -1)\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t\tproperty = writeProperty(null, type, extendedType)\r\n\t\t\t\t\t\tarrayProperty[propertyIndex] = property\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (propertyUsed)\r\n\t\t\t\t\tpropertyUsed(property, array, serializerId, i)\r\n\t\t\t\tvar code = property.code\r\n\t\t\t\tif (code > 7) {\r\n\t\t\t\t\tif (code === 8)\r\n\t\t\t\t\t\twriteAsReferencing(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsNumber(value)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (code === 6) \r\n\t\t\t\t\t\twriteAsDefault(value)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\twriteAsArray(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (needsClosing) {\r\n\t\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence\r\n\t\t\t}\r\n\t\t\tproperty = arrayProperty // restore current property\r\n\t\t} else if (typeof array == 'object' && array[iteratorSymbol]) {\r\n\t\t\treturn writeAsIterable(array)\r\n\t\t} else if (type === 'string') {\r\n\t\t\treturn writeInlineString(value)\r\n\t\t} else if (type === 'number' && (value >>> 0 === value || (value > 0 && value < 0x400000000000 && value % 1 === 0))) {\r\n\t\t\treturn writeToken(NUMBER_CODE, value)\r\n\t\t} else { // bail to default mode behavior\r\n\t\t\twriteTypedValue(array)\r\n\t\t}\r\n\t}\r\n\r\n\tvar blockProperty\r\n\r\n\tfunction writeBlockReference(block, writer) {\r\n\t\twriteToken(SEQUENCE_CODE, DEFERRED_REFERENCE)\r\n\t\tvar blockProperty = property\r\n\t\tvar lazyPromise = block[targetSymbol] ? {\r\n\t\t\tthen: then\r\n\t\t} : {\r\n\t\t\tthen: function(callback) {\r\n\t\t\t\treturn block.then(function(value) {\r\n\t\t\t\t\tblock = value\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t}, function(error) {\r\n\t\t\t\t\tblock = Object.assign(new ((typeof error == 'object' && error) ? error.constructor : Error)(), {\r\n\t\t\t\t\t\tname: error && error.name, // make these enumerable so they will serialize\r\n\t\t\t\t\t\tmessage: error && error.message || error\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!blockProperty.upgrade) {\r\n\t\t\t\t\t\twriteToken(TYPE_CODE, METADATA_TYPE)\r\n\t\t\t\t\t\twriteToken(NUMBER_CODE, ERROR_METADATA)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tthen(callback)\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t}\r\n\t\tfunction then(callback) {\r\n\t\t\tif (options.forBlock && block) {\r\n\t\t\t\t// this is used by the sizeTable serializer to record the size of each block\r\n\t\t\t\toptions.forBlock(block, blockProperty)\r\n\t\t\t} else {\r\n\t\t\t\tvar buffer = block && block[bufferSymbol] && block[bufferSymbol](blockProperty)\r\n\t\t\t\tif (buffer) {\r\n\t\t\t\t\twriteBuffer(buffer)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tproperty = blockProperty\r\n\t\t\t\t\tvar lastPendingEncodings = pendingEncodings\r\n\t\t\t\t\tpendingEncodings = [] // record any nested pending encoding separately\r\n\t\t\t\t\twriteAsDefault(block, true) // write it out as the next block\r\n\t\t\t\t\tlastPendingEncodings.unshift.apply(lastPendingEncodings, pendingEncodings) // and splice them in front\r\n\t\t\t\t\tpendingEncodings = lastPendingEncodings\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcallback()\r\n\t\t}\r\n\t\tpendingEncodings.push(lazyPromise)\r\n\t}\r\n\r\n\tvar serializer = {\r\n\t\tserialize: function(value, sharedProperty) {\r\n\t\t\tvar buffer = value && value[bufferSymbol] && value[bufferSymbol](sharedProperty)\r\n\r\n\t\t\tif (buffer) {\r\n\t\t\t\tcharEncoder.writeBuffer(buffer)\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tif (sharedProperty) {\r\n\t\t\t\tproperty = sharedProperty\r\n\t\t\t\twriters[property.code](value)\r\n\t\t\t} else {\r\n\t\t\t\tproperty = []\r\n\t\t\t\tproperty.key = null\r\n\t\t\t\twriteAsDefault(value, true)\r\n\t\t\t}\r\n\t\t},\r\n\t\tgetSerialized: function() {\r\n\t\t\tif (pendingEncodings.length > 0) {\r\n\t\t\t\tvar promises = []\r\n\t\t\t\twhile (pendingEncodings.length > 0) {\r\n\t\t\t\t\tvar finished = false\r\n\t\t\t\t\tvar promise = pendingEncodings.shift().then(function() {\r\n\t\t\t\t\t\tfinished = true\r\n\t\t\t\t\t})\r\n\t\t\t\t\tif (!finished) {\r\n\t\t\t\t\t\tpromises.push(promise)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (promises.length > 0) {\r\n\t\t\t\t\treturn Promise.all(promises).then(function() {\r\n\t\t\t\t\t\treturn serializer.getSerialized()\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (options && options.encoding === 'utf16le') {\r\n\t\t\t\treturn Buffer.from(charEncoder.getSerialized(), 'utf16le')\r\n\t\t\t}\r\n\t\t\treturn charEncoder.getSerialized()\r\n\t\t},\r\n\t\tflush: charEncoder.flush,\r\n\t\tsetOffset: charEncoder.setOffset,\r\n\t\tfinish: charEncoder.finish,\r\n\t\tpendingEncodings: pendingEncodings,\r\n\t\tgetWriters: function() {\r\n\t\t\treturn {\r\n\t\t\t\twriteProperty: writeProperty,\r\n\t\t\t\twriteToken: writeToken,\r\n\t\t\t\twriteAsDefault: writeAsDefault,\r\n\t\t\t\twriteBuffer: writeBuffer\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn serializer\r\n}\r\nfunction serialize(value, options) {\r\n\tvar serializer = createSerializer(options)\r\n\tvar sharedProperty = options && options.shared\r\n\tvar buffer\r\n\tif (sharedProperty && sharedProperty.startWrite) {\r\n\t\t// record the start of each write\r\n\t\tsharedProperty.startWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tserializer.serialize(value, sharedProperty)\r\n\tbuffer = serializer.getSerialized()\r\n\tif (sharedProperty && sharedProperty.endWrite) {\r\n\t\t// record the end of each write\r\n\t\tsharedProperty.endWrite(options.avoidShareUpdate, value)\r\n\t}\r\n\tif (serializer.finish)\r\n\t\tserializer.finish()\r\n\tvar sizeTable = value && value[exports.sizeTableSymbol]\r\n\tif (sizeTable) {\r\n\t\tbuffer.sizeTable = sizeTable\r\n\t}\r\n\r\n\tif (options && options.lazy) {\r\n\t\treturn Buffer.concat([value[exports.sizeTableSymbol], buffer])\r\n\t}\r\n\treturn buffer\r\n}\r\nexports.serialize = serialize\r\nexports.createSerializer = createSerializer\r\nfunction browserCharEncoder() {\r\n\tvar serialized = ''\r\n\tfunction writeToken(type, number) {\r\n\t\tvar serializedToken\r\n\t\tif (number < 0x10) { // 4 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(((type << 4) | number) ^ 0x40)\r\n\t\t} else if (number < 0x400) { // 10 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 6),\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000) { // 16 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 12),\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000) { // 22 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 18),\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000) { // 28 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 24),\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x100000000) { // 32 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number >>> 30),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000) { // 34 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000 >>> 0),\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x10000000000) { // 40 bits of number\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x1000000000 >>> 0),\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else if (number < 0x400000000000) { // 46 bits of number (needed for dates!)\r\n\t\t\tserializedToken = String.fromCharCode(\r\n\t\t\t\t(type << 4) + (number / 0x40000000000 >>> 0),\r\n\t\t\t\t(number / 0x1000000000) & 0x3f,\r\n\t\t\t\t(number / 0x40000000) & 0x3f,\r\n\t\t\t\t(number >>> 24) & 0x3f,\r\n\t\t\t\t(number >>> 18) & 0x3f,\r\n\t\t\t\t(number >>> 12) & 0x3f,\r\n\t\t\t\t(number >>> 6) & 0x3f,\r\n\t\t\t\t(number & 0x3f) + 0x40)\r\n\t\t} else {\r\n\t\t\tthrow new Error('Too big of number')\r\n\t\t}\r\n\t\tserialized += serializedToken\r\n\t}\r\n\tfunction writeString(string) {\r\n\t\tserialized += string\r\n\t}\r\n\tfunction getSerialized() {\r\n\t\treturn serialized\r\n\t}\r\n\treturn {\r\n\t\twriteToken: writeToken,\r\n\t\twriteString: writeString,\r\n\t\t//writeBuffer,\r\n\t\tgetSerialized: getSerialized,\r\n\t\t//insertBuffer,\r\n\t\t//flush,\r\n\t\tstartSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t},\r\n\t\tendSequence: function() {\r\n\t\t\twriteToken(SEQUENCE_CODE, END_SEQUENCE)\r\n\t\t},\r\n\t\tgetOffset: function() {// unsupported\r\n\t\t\treturn -1\r\n\t\t}\r\n\t}\r\n}\r\nvar ArrayFrom = Array.from || function(iterable, keyValue) {\r\n\tvar array = []\r\n\tvar keyValue = iterable.constructor === Map\r\n\titerable.forEach(function(key, value) {\r\n\t\tif (keyValue) {\r\n\t\t\tarray.push([value, key])\r\n\t\t} else {\r\n\t\t\tarray.push(key)\r\n\t\t}\r\n\t})\r\n\treturn array\r\n}\r\n\r\nfunction writeMap(map) {\r\n\tvar keyValues = ArrayFrom(map)\r\n\tfor (var i = 0, length = keyValues.length; i < length; i++) {\r\n\t\tvar keyValue = keyValues[i]\r\n\t\tkeyValues[i] = {\r\n\t\t\tkey: keyValue[0],\r\n\t\t\tvalue: keyValue[1]\r\n\t\t}\r\n\t}\r\n\treturn keyValues\r\n}\r\nfunction writeSet(set) {\r\n\treturn ArrayFrom(set)\r\n}\r\nfunction writeDate(date) {\r\n\treturn date.getTime()\r\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 775, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/serialize-stream.js"],"sourcesContent":["\"use strict\"\r\nconst { Transform } = require('stream')\r\nconst { createSerializer } = require('./serialize')\r\n// a readable stream for serializing a set of variables to a JSON stream\r\nclass DPackSerializeStream extends Transform {\r\n\r\n\tconstructor(options) {\r\n\t\t// Calls the stream.Readable(options) constructor\r\n\t\toptions = options || {}\r\n\t\tsuper(options)\r\n\t\tthis.options = options\r\n\t\tthis.continueWriting = true\r\n\t}\r\n\twrite(value) {\r\n\t\tconst serializer = this.serializer || (this.serializer = createSerializer({ asBlock: true }))\r\n\t\tserializer.serialize(value)\r\n\t\tconst buffer = serializer.getSerialized()\r\n\t\tif (buffer.then) {\r\n\t\t\t// we need to wait for this to finish, spawn a new serializer to handle any other writes\r\n\t\t\tbuffer.then(buffer => this.push(buffer))\r\n\t\t\tthis.serializer = null\r\n\t\t} else {\r\n\t\t\tserializer.flush(this)\r\n\r\n\t\t}\r\n\t}\r\n\r\n\tend(value) {\r\n\t\tif (value) {\r\n\t\t\tthis.options.outlet = this\r\n\t\t\tconst serializer = this.serializer || (this.serializer = createSerializer(this.options))\r\n\t\t\tserializer.serialize(value) // we do not need to write the last value as a block, its state won't affect anything afterwards\r\n\t\t}\r\n\t\tif (this.serializer.pendingEncodings.length > 0) {\r\n\t\t\tthis.endWhenDone = true\r\n\t\t\tthis.writeNext()\r\n\t\t} else {\r\n\t\t\tthis.serializer.flush()\r\n\t\t\tthis.push(null)\r\n\t\t}\r\n\t}\r\n\r\n\twriteBytes(buffer) {\r\n\t\ttry {\r\n\t\t\tthis.continueWriting = this.push(buffer)\r\n\t\t} catch(error) {\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\t_read() {\r\n\t\tthis.continueWriting = true\r\n\t\tif(!this.pausedForPromise && this.serializer && this.endWhenDone && this.serializer.pendingEncodings.length > 0) {\r\n\t\t\tthis.writeNext()\r\n\t\t}\r\n\t}\r\n\twriteNext() {\r\n\t\tvar isSync\r\n\t\tdo {\r\n\t\t\tvar hasMoreToSend = this.serializer.pendingEncodings.length > 0\r\n\t\t\tisSync = null\r\n\t\t\tif (hasMoreToSend) {\r\n\t\t\t\tthis.serializer.pendingEncodings.shift().then(() => {\r\n\t\t\t\t\tif (isSync === false) {\r\n\t\t\t\t\t\t// if we are async, call writeNext which will look for more pending encodings\r\n\t\t\t\t\t\tthis.pausedForPromise = false\r\n\t\t\t\t\t\tif (this.continueWriting || this.serializer.pendingEncodings.length === 0)\r\n\t\t\t\t\t\t\tthis.writeNext()\r\n\t\t\t\t\t\telse { // backpressure, flush and wait for flow\r\n\t\t\t\t\t\t\tthis.serializer.flush() // flush what we have before waiting for _read call\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// mark it as sync so we can exit and loop instead of recursing\r\n\t\t\t\t\t\tisSync = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}, (error) => {\r\n\t\t\t\t\t// the serializer should handle promise errors, but if that fails, end the stream with the error\r\n\t\t\t\t\tconsole.error(error)\r\n\t\t\t\t\tthis.push(error.toString())\r\n\t\t\t\t\tthis.push(null)\r\n\t\t\t\t})\r\n\t\t\t\tif (!isSync) { // async promise, flush what we have and wait for promise\r\n\t\t\t\t\tisSync = false\r\n\t\t\t\t\t// flush what we have so far while waiting for the promise\r\n\t\t\t\t\tthis.pausedForPromise = true\r\n\t\t\t\t\tthis.serializer.flush()\r\n\t\t\t\t} else if (!this.continueWriting && this.serializer.pendingEncodings.length > 0) {\r\n\t\t\t\t\tthis.serializer.flush() // flush what we have\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\t\t\t} else if (this.endWhenDone) {\r\n\t\t\t\tthis.serializer.flush()\r\n\t\t\t\tthis.push(']')\r\n\t\t\t\tthis.push(null)\r\n\t\t\t}\r\n\t\t} while (isSync)\r\n\t}\r\n}\r\n\r\nexports.createSerializeStream = () => {\r\n\treturn new DPackSerializeStream()\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 875, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 879, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/parse.js"],"sourcesContent":["\"use strict\"\r\n\r\n// type codes:\r\n// these are the codes that are used to determine the rudimentary type of numbers\r\nvar PROPERTY_CODE = 0\r\nvar TYPE_CODE = 3\r\nvar STRING_CODE = 2\r\nvar NUMBER_CODE = 1\r\nvar SEQUENCE_CODE = 7\r\n\r\n// constant codes\r\nvar NULL = 0 // p\r\nvar FALSE = 3 // s\r\nvar TRUE = 4 // t\r\nvar UNDEFINED = 5 // u\r\n\r\n// these are the starting codes (structures also use this space) for complete types\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\nvar EXTENSIONS = 10\r\nvar METADATA_TYPE = 11\r\nvar COPY_PROPERTY = 12  // for defining a typed object without returning the value\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14  // for defining a typed object without returning the value\r\n\r\nvar ERROR_METADATA = 500\r\n// sequence codes\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar PARTIAL_DEFERRED_REFERENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\nvar DEFERRED_REFERENCE = 15 // ?\r\n\r\nvar MAX_LENGTH = 1024*1024*16\r\nvar PAUSED = {}\r\n\r\nfunction createParser(options) {\r\n\tif (!options)\r\n\t\toptions = {}\r\n\tvar offset\r\n\tvar source\r\n\tvar isPartial\r\n\tvar classByName = options.classByName || new Map()\r\n\tclassByName.set('Map', readMap)\r\n\tclassByName.set('Set', readSet)\r\n\tclassByName.set('Date', readDate)\r\n\tvar pausedState\r\n\tvar deferredReads\r\n\r\n\tfunction pause(state, lastRead) {\r\n\t\tstate.previous = pausedState\r\n\t\tstate.resume = true\r\n\t\tpausedState = state\r\n\t\tif (!isPartial)\r\n\t\t\tthrow new Error('Unexpected end of dpack stream')\r\n\r\n\t\tif (!parser.onResume) // only if not already defined, otherwise we just want to use the one from the top of the call stack\r\n\t\t\tparser.onResume = function(nextString, isPartialString, rebuildString) {\r\n\t\t\t\t// top of the resume stack\r\n\t\t\t\tvar resumeState = pausedState\r\n\t\t\t\tpausedState = null\r\n\t\t\t\tparser.onResume = null\r\n\t\t\t\t// we slice and add these together to generate an entirely new string\r\n\t\t\t\t// so we don't cause a memory leak with redundant strings that a retained a slice parents\r\n\t\t\t\tif (lastRead < source.length)\r\n\t\t\t\t\tsource = source.slice(lastRead) + nextString\r\n\t\t\t\telse {\r\n\t\t\t\t\tif (rebuildString) // if we have read all of source, we want to slice and re-concatenate to eliminate the slice reference to the parent, we really don't want that retained in memory\r\n\t\t\t\t\t\tsource = nextString.slice(0, 1) + nextString.slice(1)\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\tsource = nextString\r\n\t\t\t\t}\r\n\t\t\t\tisPartial = isPartialString\r\n\t\t\t\tdisposedChars += lastRead\r\n\t\t\t\toffset = 0\r\n\t\t\t\treturn resumeState.reader ? resumeState.reader(resumeState) : readSequence(resumeState.length, resumeState)\r\n\t\t\t}\r\n\t\treturn state.object\r\n\t}\r\n\r\n\tfunction readSequence(length, thisProperty) {\r\n\t\t/* propertyStates:\r\n\t\t0 - starting next property slot\r\n\t\t1 - property created, succeeding value should be value of property\r\n\t\t2 - property creation in progress, next value should define key\r\n\t\t11+ - modifying property, next value modifies property (adds metadata, position, type, etc.)\r\n\t\t*/\r\n\t\tvar propertyState = 0\r\n\t\tthisProperty = thisProperty || []\r\n\t\tvar property, isArray, object, value, i = 0, propertyIndex = 0\r\n\t\tif (thisProperty.resume) { // resuming, thisProperty is the resume state.\r\n\t\t\tproperty = thisProperty.previous\r\n\t\t\tif (property) {\r\n\t\t\t\t// do the previous/upper stack frame first\r\n\t\t\t\tvar value = property.reader ? property.reader(property) : readSequence(property.length, property)\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (values) {\r\n\t\t\t\t\t// we have an assignment to referencing values that is waiting for pausing to complete\r\n\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t// if still paused, pass on to next pausedState\r\n\t\t\t\t\t\tpausedState.values = values\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (value.nextPosition > -1) {\r\n\t\t\t\t\t\t\t// we use this path for fulfilling forward references, and when the position is reset\r\n\t\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (thisProperty.code && thisProperty.code !== thisProperty.thisProperty.code) {\r\n\t\t\t\tthisProperty.resume = false // if the resume property has been reassigned to an incompatible type, can't switch\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\ti = thisProperty.i || 0\r\n\t\t\t\tobject = thisProperty.object\r\n\t\t\t\tpropertyState = thisProperty.propertyState || 0\r\n\t\t\t\tpropertyIndex = thisProperty.propertyIndex || 0\r\n\t\t\t\tthisProperty = thisProperty.thisProperty\r\n\t\t\t}\r\n\t\t}\r\n\t\tisArray = thisProperty.code === ARRAY_TYPE/*ARRAY_TYPE*/\r\n\t\tobject = object || (thisProperty.constructs ? new thisProperty.constructs() : isArray ? [] : {}) // TODO: we could probably construct a new reader that does this a little faster\r\n\t\tfor (; i < length;) {\r\n\t\t\tvar type, number\r\n\t\t\tvar lastRead = offset\r\n\t\t\tvar token = source.charCodeAt(offset++)\r\n\t\t\tif (token >= 0x30) { // fast path for one byte with stop bit\r\n\t\t\t\tif (token > 0x3000) { // long-token handling\r\n\t\t\t\t\ttype = (token >>> 12) ^ 4\r\n\t\t\t\t\tnumber = token & 0xfff\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttype = (token >>> 4) ^ 4\r\n\t\t\t\t\tnumber = token & 0xf\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\ttype = (token >>> 4) & 11 // shift and omit the stop bit (bit 3)\r\n\t\t\t\tnumber = token & 0xf\r\n\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 10 bit number\r\n\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 16 bit number\r\n\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 22 bit number\r\n\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\tnumber = (number << 6) + (token & 0x3f) // 28 bit number\r\n\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)\r\n\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 40 bit number\r\n\t\t\t\t\t\t\t\t\tif (!(token >= 0x40)) {\r\n\t\t\t\t\t\t\t\t\t\ttoken = source.charCodeAt(offset++)\r\n\t\t\t\t\t\t\t\t\t\tnumber = (number * 0x40) + (token & 0x3f) // 46 bit number, we don't go beyond this\r\n\t\t\t\t\t\t\t\t\t\tif (!(token >= 0)) {\r\n\t\t\t\t\t\t\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (type === 0) { /*PROPERTY_CODE*/\r\n\t\t\t\tpropertyIndex = number\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t\tcontinue\r\n\t\t\t}\r\n\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\tif (type === 3) { /*TYPE_CODE*/\r\n\t\t\t\t// we store the previous property state in token, so we can assign the next one\r\n\t\t\t\tif (number < 6) {\r\n\t\t\t\t\t// special values (constants, deferreds)\r\n\t\t\t\t\tif (number < 3) {\r\n\t\t\t\t\t\tif (number === 0) {\r\n\t\t\t\t\t\t\tvalue = null\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = 'Unknown token, type: ' + type + ' number: ' + number\r\n\t\t\t\t\t\t} \r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number === TRUE) {\r\n\t\t\t\t\t\t\tvalue = true\r\n\t\t\t\t\t\t} else if (number === FALSE) {\r\n\t\t\t\t\t\t\tvalue = false\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tvalue = undefined\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (number <= NUMBER_TYPE) {\r\n\t\t\t\t\t\t// property definition\r\n\t\t\t\t\t\tif (propertyState === 1) {\r\n\t\t\t\t\t\t\t// we were in property value position, but no value, so we increment position here\r\n\t\t\t\t\t\t\tpropertyIndex++\r\n\t\t\t\t\t\t\ti++\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex]\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyIndex < thisProperty.resetTo) {\r\n\t\t\t\t\t\t\tthrow new Error('Overwriting frozen property')\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (property) {\r\n\t\t\t\t\t\t\tif (!property.resume) {\r\n\t\t\t\t\t\t\t\tvalue = property.key // inherit the existing key\r\n\t\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\t\tproperty.key = value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else { // no property existed in slot, start with default key of null\r\n\t\t\t\t\t\t\tproperty = thisProperty[propertyIndex] = []\r\n\t\t\t\t\t\t\tproperty.key = null\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.code = number\r\n\t\t\t\t\t\tproperty.parent = thisProperty\r\n\t\t\t\t\t\t//property.key = null\r\n\t\t\t\t\t\tpropertyState = 2 // read next value as the key\r\n\t\t\t\t\t\tif (number === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\t\t\t\tproperty.values = []\r\n\t\t\t\t\t\t} else if (number === ARRAY_TYPE) {\r\n\t\t\t\t\t\t\tproperty[0] = []\r\n\t\t\t\t\t\t\tproperty[0].key = null\r\n\t\t\t\t\t\t\tproperty[0].code = DEFAULT_TYPE\r\n\t\t\t\t\t\t\tproperty[0].parent = property\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// property modification\r\n\t\t\t\t\t\tpropertyState = number\r\n\t\t\t\t\t}\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tif (type === 2 /*STRING_CODE*/) {\r\n\t\t\t\t\tvalue = source.slice(offset, offset += number)\r\n\t\t\t\t\tif (offset > source.length) {\r\n\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\tpropertyState: propertyState\r\n\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (propertyState < 2) {\r\n\t\t\t\t\t\tif (property.code === NUMBER_TYPE/*NUMBER_TYPE*/) {\r\n\t\t\t\t\t\t\tvalue = +value\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (type === 1) { /*NUMBER_CODE*/\r\n\t\t\t\t\tvalue = number\r\n\t\t\t\t} else { /*if type == 7 SEQUENCE_CODE*/\r\n\t\t\t\t\tif (number > 13) {\r\n\t\t\t\t\t\tif (number === END_SEQUENCE)\r\n\t\t\t\t\t\t\treturn object\r\n\t\t\t\t\t\telse if (number === DEFERRED_REFERENCE) {\r\n\t\t\t\t\t\t\tvalue = readSequence(0, property)\r\n\t\t\t\t\t\t\tpropertyState = 0\r\n\t\t\t\t\t\t\tif (options.forDeferred) {\r\n\t\t\t\t\t\t\t\tvalue = options.forDeferred(value, property)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t(deferredReads || (deferredReads = [])).push({\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tvalue: value\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tif (number >= OPEN_SEQUENCE) {\r\n\t\t\t\t\t\t\tnumber = 2000000000\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif (propertyState > 1) {\r\n\t\t\t\t\t\t\tif (propertyState === 2) {\r\n\t\t\t\t\t\t\t\tpropertyState = 0 // if the property key was skipped, go directly into value mode\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t\t} else if (propertyState === METADATA_TYPE)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, [{ key: null, code: 6 }])\r\n\t\t\t\t\t\t\telse if (property.resume && (property.code || DEFAULT_TYPE) === property.thisProperty.code)\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property.thisProperty)\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\t} else\r\n\t\t\t\t\t\t\tvalue = readSequence(number, property)\r\n\t\t\t\t\t\tif (pausedState) {\r\n\t\t\t\t\t\t\tif (value === undefined) { // or a PAUSED object\r\n\t\t\t\t\t\t\t\tpausedState = null // erase anything further up in the stack, as this means the sequence couldn't start, so we need to re-parse from here\r\n\t\t\t\t\t\t\t\tparser.onResume = null\r\n\t\t\t\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\t\t\t\tlength: length,\r\n\t\t\t\t\t\t\t\t\tthisProperty: thisProperty,\r\n\t\t\t\t\t\t\t\t\ti: i,\r\n\t\t\t\t\t\t\t\t\tobject: object,\r\n\t\t\t\t\t\t\t\t\tproperty: property,\r\n\t\t\t\t\t\t\t\t\tpropertyIndex: propertyIndex,\r\n\t\t\t\t\t\t\t\t\tpreviousProperty: previousProperty,\r\n\t\t\t\t\t\t\t\t\tpropertyState: propertyState,\r\n\t\t\t\t\t\t\t\t}, lastRead)\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t// need to assign the values *after* the completion of the sequence if it is a forward reference\r\n\t\t\t\t\t\t\t\tpausedState.values = property.values instanceof Array ? property.values : undefined\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}/*else if (values) {\r\n\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t}*/\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!property) {\r\n\t\t\t\tthrow new Error('No property defined for slot' + (thisProperty.key ? ' in ' + thisProperty.key : ''))\r\n\t\t\t}\r\n\t\t\tif (propertyState < 2 && property && property.code === REFERENCING_TYPE/*REFERENCING_TYPE*/) {\r\n\t\t\t\tvar values = property.values\r\n\t\t\t\tif (typeof value === 'number') {\r\n\t\t\t\t\tvalue = values[number]\r\n\t\t\t\t\tif (value === undefined && !((number) in values)) {\r\n\t\t\t\t\t\tthrow new Error('Referencing value that has not been read yet')\r\n\t\t\t\t\t}\t\t\t\t\t\r\n\t\t\t\t} else if ((type === 2 || type === 7) && values) { // only strings and sequences\r\n\t\t\t\t\tif (values.nextPosition > -1) {\r\n\t\t\t\t\t\t// we use this path for fulfilling forward references\r\n\t\t\t\t\t\tif (property.recordValueReference) {\r\n\t\t\t\t\t\t\tproperty.recordValueReference(values)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tvalues[values.nextPosition++] = value\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tvalues.push(value)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tif (propertyState > 1) {\r\n\t\t\t\t// 0, 1: values are the value of the property\r\n\t\t\t\tif (propertyState === 2) { // property key\r\n\t\t\t\t\tproperty.key = value\r\n\t\t\t\t} else if (propertyState === METADATA_TYPE) { // 3: metadata paramater\r\n\t\t\t\t\tif (typeof value === 'string') {\r\n\t\t\t\t\t\tvar extendedType = classByName.get(value)\r\n\t\t\t\t\t\tif (extendedType) {\r\n\t\t\t\t\t\t\tif (extendedType.fromValue) {\r\n\t\t\t\t\t\t\t\tproperty.fromValue = extendedType.fromValue\r\n\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\tproperty.constructs = extendedType\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t} else if (options.errorOnUnknownClass) {\r\n\t\t\t\t\t\t\tthrow new Error('Attempt to deserialize to unknown class ' + parameter)\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// if no warning, just parse as a plain value/object\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tproperty.extendedType = extendedType // if this gets used for serialization, this is needed\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// extended metadata assignment (used by shared structures to mark objects as unstructured)\r\n\t\t\t\t\t\tproperty.metadata = value\r\n\t\t\t\t\t\tif (value === ERROR_METADATA)\r\n\t\t\t\t\t\t\tproperty.fromValue = onError\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (propertyState === REFERENCING_POSITION) {\r\n\t\t\t\t\tvar values = property.values || (property.values = [])\r\n\t\t\t\t\t//values.splice(value, values.length)\r\n\t\t\t\t\tvalues.nextPosition = value\r\n\t\t\t\t} else if (propertyState === TYPE_DEFINITION) { // for type-only state\r\n\t\t\t\t\t// throw away this value and read next value as the real value\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow new Error('Unknown property type ' + propertyState)\r\n\t\t\t\t}\r\n\t\t\t\tpropertyState = 1 // property value after definition position\r\n\t\t\t\tcontinue // read next value as the property value\r\n\t\t\t} else {\r\n\t\t\t\tpropertyState = 0\r\n\t\t\t}\r\n\t\t\tif (property.fromValue) {\r\n\t\t\t\tvalue = property.fromValue(value)\r\n\t\t\t}\r\n\t\t\tif (isArray && property.key === null) {\r\n\t\t\t\tobject.push(value)\r\n\t\t\t} else if (value !== undefined) {\r\n\t\t\t\tobject[property.key] = value\r\n\t\t\t}\r\n\t\t\ti++\r\n\t\t\tif (!isArray)\r\n\t\t\t\tpropertyIndex++\r\n\t\t}\r\n\t\treturn object\r\n\t}\r\n\r\n\tfunction unknownType(number) {\r\n\t\tthrow new Error('Unknown type ' + number)\r\n\t}\r\n\tvar nonParsingError\r\n\tfunction onError(error) {\r\n\t\tvar g = typeof global != 'undefined' ? global : window\r\n\t\tif (error && error.name && g[error.name])\r\n\t\t\terror = new g[error.name](error.message)\r\n\t\telse if (typeof error == 'string')\r\n\t\t\terror = new Error(error)\r\n\t\tif (options.onError)\r\n\t\t\toptions.onError(error)\r\n\t\telse {\r\n\t\t\tnonParsingError = true\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\tvar disposedChars = 0\r\n\tfunction read(property) {\r\n\t\ttry {\r\n\t\t\tif (property && property.resume) {\r\n\t\t\t\tvar previous = property.previous\r\n\t\t\t\tvalue = readSequence(previous.length, previous)\r\n\t\t\t\t// once we get the value, we don't know which point in the stack could still be resolving\r\n\t\t\t\tvalue = property.object || value\r\n\t\t\t\tproperty = property.property\r\n\t\t\t} else {\r\n\t\t\t\tproperty = property || [options && options.shared || {\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tcode: 6\r\n\t\t\t\t}]\r\n\t\t\t\tvar value = readSequence(1, property)[property[0].key]\r\n\t\t\t}\r\n\t\t\twhile (true) {\r\n\t\t\t\tif (pausedState) {\r\n\t\t\t\t\treturn pause({\r\n\t\t\t\t\t\treader: read,\r\n\t\t\t\t\t\tobject: value,\r\n\t\t\t\t\t\tproperty: property\r\n\t\t\t\t\t})\r\n\t\t\t\t}\r\n\t\t\t\tif (!deferredReads) {\r\n\t\t\t\t\treturn value\r\n\t\t\t\t}\r\n\t\t\t\tvar index = deferredReads.index || 0\r\n\t\t\t\tvar deferredRead = deferredReads[index]\r\n\t\t\t\tdeferredReads.index = index + 1\r\n\t\t\t\tif (!deferredRead) {\r\n\t\t\t\t\tdeferredReads = deferredReads.parent\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t\tvar target = deferredRead.value\r\n\t\t\t\tvar parentDeferredReads = deferredReads\r\n\t\t\t\tdeferredReads = []\r\n\t\t\t\tdeferredReads.parent = parentDeferredReads\r\n\t\t\t\tvar targetProperty = deferredRead.property\r\n\t\t\t\tvar result = readSequence(1, property = [{\r\n\t\t\t\t\tresume: true,\r\n\t\t\t\t\tkey: null,\r\n\t\t\t\t\tthisProperty: targetProperty,\r\n\t\t\t\t\tobject: target\r\n\t\t\t\t}])\r\n\t\t\t\tresult = result.null || result[targetProperty.key] // Blocks should use null as the root key, but could have the target property key as well\r\n\t\t\t\tif (result != target) { // This should only occur with a promise that resolves to a different type, an array\r\n\t\t\t\t\t// object was replaced with something else (an array, presumably)\r\n\t\t\t\t\tObject.assign(target, result)\r\n\t\t\t\t\tif (pausedState && pausedState.object === result) {\r\n\t\t\t\t\t\tpausedState.object = target\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (result && result.constructor === Array) {\r\n\t\t\t\t\t\ttarget.length = result.length\r\n\t\t\t\t\t\tObject.setPrototypeOf(target, Object.getPrototypeOf(result)) // do our best to make it array like\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} catch(error) {\r\n\t\t\tif (!nonParsingError)\r\n\t\t\t\terror.message = 'DPack parsing error: ' + error.message + ' at position: ' + (offset + disposedChars) + ' near: ' + source.slice(offset - 10, offset + 10)\r\n\t\t\tthrow error\r\n\t\t}\r\n\t}\r\n\r\n\tvar parser = {\r\n\t\tsetSource: function(string, startOffset, isPartialString) {\r\n\t\t\tsource = string\r\n\t\t\toffset = startOffset || 0\r\n\t\t\tdisposedChars = 0\r\n\t\t\tisPartial = isPartialString\r\n\t\t\treturn this\r\n\t\t},\r\n\t\thasMoreData: function() {\r\n\t\t\treturn source.length > offset\r\n\t\t},\r\n\t\tisPaused: function() {\r\n\t\t\treturn pausedState\r\n\t\t},\r\n\t\thasUnfulfilledReferences: function() {\r\n\t\t\treturn deferredReads && deferredReads.length > deferredReads.index\r\n\t\t},\r\n\t\tgetOffset: function() {\r\n\t\t\treturn offset + disposedChars\r\n\t\t},\r\n\t\tread: read\r\n\t}\r\n\treturn parser\r\n}\r\nexports.parse = function(stringOrBuffer, options) {\r\n\tvar source\r\n\tif (typeof stringOrBuffer === 'string') {\r\n\t\tsource = stringOrBuffer\r\n\t} else if (stringOrBuffer && stringOrBuffer.toString) {\r\n\t\tsource = stringOrBuffer.toString(options && options.encoding || 'utf8')\r\n\t} else { // whatever (undefined or null or whatever), just return it\r\n\t\treturn stringOrBuffer\r\n\t}\r\n\tvar parser = createParser(options).setSource(source)\r\n\tif (options && options.shared)\r\n\t\treturn parser.read([options.shared])\r\n\treturn parser.read()\r\n}\r\nexports.createParser = createParser\r\n\r\nvar readMap = {\r\n\tfromValue: function(entries) {\r\n\t\tvar map = new Map()\r\n\t\tfor (var i = 0, l = entries.length; i < l; i++) {\r\n\t\t\tvar entry = entries[i]\r\n\t\t\tmap.set(entry.key, entry.value)\r\n\t\t}\r\n\t\treturn map\r\n\t}\r\n}\r\nvar readSet = {\r\n\tfromValue: function(values) {\r\n\t\tvar set = new Set(values)\r\n\t\tif (set.size === 0 && values.length > 0) {\r\n\t\t\tfor (var i = 0, l = values.length; i < l; i++) {\r\n\t\t\t\tset.add(values[i])\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn set\r\n\t}\r\n}\r\nvar readDate = {\r\n\tfromValue: function(time) {\r\n\t\treturn new Date(time)\r\n\t}\r\n}\r\n\r\n"],"names":[],"mappings":"AAAA;AAEA,cAAc;AACd,iFAAiF;AACjF,IAAI,gBAAgB;AACpB,IAAI,YAAY;AAChB,IAAI,cAAc;AAClB,IAAI,cAAc;AAClB,IAAI,gBAAgB;AAEpB,iBAAiB;AACjB,IAAI,OAAO,EAAE,IAAI;;AACjB,IAAI,QAAQ,EAAE,IAAI;;AAClB,IAAI,OAAO,EAAE,IAAI;;AACjB,IAAI,YAAY,EAAE,IAAI;;AAEtB,mFAAmF;AACnF,IAAI,eAAe;AACnB,IAAI,aAAa;AACjB,IAAI,mBAAmB;AACvB,IAAI,cAAc;AAClB,IAAI,aAAa;AACjB,IAAI,gBAAgB;AACpB,IAAI,gBAAgB,GAAI,0DAA0D;;AAClF,IAAI,uBAAuB;AAC3B,IAAI,kBAAkB,GAAI,0DAA0D;;AAEpF,IAAI,iBAAiB;AACrB,iBAAiB;AACjB,IAAI,gBAAgB,GAAG,IAAI;;AAC3B,IAAI,6BAA6B,GAAG,IAAI;;AACxC,IAAI,eAAe,GAAG,IAAI;;AAC1B,IAAI,qBAAqB,GAAG,IAAI;;AAEhC,IAAI,aAAa,OAAK,OAAK;AAC3B,IAAI,SAAS,CAAC;AAEd,SAAS,aAAa,OAAO;IAC5B,IAAI,CAAC,SACJ,UAAU,CAAC;IACZ,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAI,cAAc,QAAQ,WAAW,IAAI,IAAI;IAC7C,YAAY,GAAG,CAAC,OAAO;IACvB,YAAY,GAAG,CAAC,OAAO;IACvB,YAAY,GAAG,CAAC,QAAQ;IACxB,IAAI;IACJ,IAAI;IAEJ,SAAS,MAAM,KAAK,EAAE,QAAQ;QAC7B,MAAM,QAAQ,GAAG;QACjB,MAAM,MAAM,GAAG;QACf,cAAc;QACd,IAAI,CAAC,WACJ,MAAM,IAAI,MAAM;QAEjB,IAAI,CAAC,OAAO,QAAQ,EACnB,OAAO,QAAQ,GAAG,SAAS,UAAU,EAAE,eAAe,EAAE,aAAa;YACpE,0BAA0B;YAC1B,IAAI,cAAc;YAClB,cAAc;YACd,OAAO,QAAQ,GAAG;YAClB,qEAAqE;YACrE,yFAAyF;YACzF,IAAI,WAAW,OAAO,MAAM,EAC3B,SAAS,OAAO,KAAK,CAAC,YAAY;iBAC9B;gBACJ,IAAI,eACH,SAAS,WAAW,KAAK,CAAC,GAAG,KAAK,WAAW,KAAK,CAAC;qBAEnD,SAAS;YACX;YACA,YAAY;YACZ,iBAAiB;YACjB,SAAS;YACT,OAAO,YAAY,MAAM,GAAG,YAAY,MAAM,CAAC,eAAe,aAAa,YAAY,MAAM,EAAE;QAChG;QACD,OAAO,MAAM,MAAM;IACpB;IAEA,SAAS,aAAa,MAAM,EAAE,YAAY;QACzC;;;;;EAKA,GACA,IAAI,gBAAgB;QACpB,eAAe,gBAAgB,EAAE;QACjC,IAAI,UAAU,SAAS,QAAQ,OAAO,IAAI,GAAG,gBAAgB;QAC7D,IAAI,aAAa,MAAM,EAAE;YACxB,WAAW,aAAa,QAAQ;YAChC,IAAI,UAAU;gBACb,0CAA0C;gBAC1C,IAAI,QAAQ,SAAS,MAAM,GAAG,SAAS,MAAM,CAAC,YAAY,aAAa,SAAS,MAAM,EAAE;gBACxF,IAAI,SAAS,SAAS,MAAM;gBAC5B,IAAI,QAAQ;oBACX,sFAAsF;oBACtF,IAAI,aAAa;wBAChB,+CAA+C;wBAC/C,YAAY,MAAM,GAAG;oBACtB,OAAO;wBACN,IAAI,MAAM,YAAY,GAAG,CAAC,GAAG;4BAC5B,qFAAqF;4BACrF,MAAM,CAAC,OAAO,YAAY,GAAG,GAAG;wBACjC,OAAO;4BACN,OAAO,IAAI,CAAC;wBACb;oBACD;gBACD;YACD;YACA,IAAI,aAAa,IAAI,IAAI,aAAa,IAAI,KAAK,aAAa,YAAY,CAAC,IAAI,EAAE;gBAC9E,aAAa,MAAM,GAAG,MAAM,mFAAmF;;YAChH,OACK;gBACJ,IAAI,aAAa,CAAC,IAAI;gBACtB,SAAS,aAAa,MAAM;gBAC5B,gBAAgB,aAAa,aAAa,IAAI;gBAC9C,gBAAgB,aAAa,aAAa,IAAI;gBAC9C,eAAe,aAAa,YAAY;YACzC;QACD;QACA,UAAU,aAAa,IAAI,KAAK,WAAU,YAAY;QACtD,SAAS,UAAU,CAAC,aAAa,UAAU,GAAG,IAAI,aAAa,UAAU,KAAK,UAAU,EAAE,GAAG,CAAC,CAAC,EAAE,gFAAgF;;QACjL,MAAO,IAAI,QAAS;YACnB,IAAI,MAAM;YACV,IAAI,WAAW;YACf,IAAI,QAAQ,OAAO,UAAU,CAAC;YAC9B,IAAI,SAAS,MAAM;gBAClB,IAAI,QAAQ,QAAQ;oBACnB,OAAO,AAAC,UAAU,KAAM;oBACxB,SAAS,QAAQ;gBAClB,OAAO;oBACN,OAAO,AAAC,UAAU,IAAK;oBACvB,SAAS,QAAQ;gBAClB;YACD,OAAO;gBACN,OAAO,AAAC,UAAU,IAAK,GAAG,sCAAsC;;gBAChE,SAAS,QAAQ;gBACjB,QAAQ,OAAO,UAAU,CAAC;gBAC1B,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,gBAAgB;;gBACxD,IAAI,CAAC,CAAC,SAAS,IAAI,GAAG;oBACrB,QAAQ,OAAO,UAAU,CAAC;oBAC1B,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,gBAAgB;;oBACxD,IAAI,CAAC,CAAC,SAAS,IAAI,GAAG;wBACrB,QAAQ,OAAO,UAAU,CAAC;wBAC1B,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,gBAAgB;;wBACxD,IAAI,CAAC,CAAC,SAAS,IAAI,GAAG;4BACrB,QAAQ,OAAO,UAAU,CAAC;4BAC1B,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,IAAI,EAAE,gBAAgB;;4BACxD,IAAI,CAAC,CAAC,SAAS,IAAI,GAAG;gCACrB,QAAQ,OAAO,UAAU,CAAC;gCAC1B,SAAS,AAAC,SAAS,OAAQ,CAAC,QAAQ,IAAI,EAAE,iEAAiE;;gCAC3G,IAAI,CAAC,CAAC,SAAS,IAAI,GAAG;oCACrB,QAAQ,OAAO,UAAU,CAAC;oCAC1B,SAAS,AAAC,SAAS,OAAQ,CAAC,QAAQ,IAAI,EAAE,gBAAgB;;oCAC1D,IAAI,CAAC,CAAC,SAAS,IAAI,GAAG;wCACrB,QAAQ,OAAO,UAAU,CAAC;wCAC1B,SAAS,AAAC,SAAS,OAAQ,CAAC,QAAQ,IAAI,EAAE,yCAAyC;;wCACnF,IAAI,CAAC,CAAC,SAAS,CAAC,GAAG;4CAClB,IAAI,SAAS,OAAO,MAAM,EAAE;gDAC3B,OAAO,MAAM;oDACZ,QAAQ;oDACR,cAAc;oDACd,GAAG;oDACH,QAAQ;oDACR,eAAe;oDACf,eAAe;gDAChB,GAAG;4CACJ;wCACD;oCACD;gCACD;4BACD;wBACD;oBACD;gBACD;YACD;YACA,IAAI,SAAS,GAAG;gBACf,gBAAgB;gBAChB,gBAAgB;gBAChB;YACD;YACA,WAAW,YAAY,CAAC,cAAc;YACtC,IAAI,SAAS,GAAG;gBACf,+EAA+E;gBAC/E,IAAI,SAAS,GAAG;oBACf,wCAAwC;oBACxC,IAAI,SAAS,GAAG;wBACf,IAAI,WAAW,GAAG;4BACjB,QAAQ;wBACT,OAAO;4BACN,QAAQ,0BAA0B,OAAO,cAAc;wBACxD;oBACD,OAAO;wBACN,IAAI,WAAW,MAAM;4BACpB,QAAQ;wBACT,OAAO,IAAI,WAAW,OAAO;4BAC5B,QAAQ;wBACT,OAAO;4BACN,QAAQ;wBACT;oBACD;gBACD,OAAO;oBACN,IAAI,UAAU,aAAa;wBAC1B,sBAAsB;wBACtB,IAAI,kBAAkB,GAAG;4BACxB,kFAAkF;4BAClF;4BACA;4BACA,WAAW,YAAY,CAAC,cAAc;wBACvC;wBACA,IAAI,gBAAgB,aAAa,OAAO,EAAE;4BACzC,MAAM,IAAI,MAAM;wBACjB;wBACA,IAAI,UAAU;4BACb,IAAI,CAAC,SAAS,MAAM,EAAE;gCACrB,QAAQ,SAAS,GAAG,CAAC,2BAA2B;;gCAChD,WAAW,YAAY,CAAC,cAAc,GAAG,EAAE;gCAC3C,SAAS,GAAG,GAAG;4BAChB;wBACD,OAAO;4BACN,WAAW,YAAY,CAAC,cAAc,GAAG,EAAE;4BAC3C,SAAS,GAAG,GAAG;wBAChB;wBACA,SAAS,IAAI,GAAG;wBAChB,SAAS,MAAM,GAAG;wBAClB,qBAAqB;wBACrB,gBAAgB,EAAE,6BAA6B;;wBAC/C,IAAI,WAAW,iBAAgB,kBAAkB,KAAI;4BACpD,SAAS,MAAM,GAAG,EAAE;wBACrB,OAAO,IAAI,WAAW,YAAY;4BACjC,QAAQ,CAAC,EAAE,GAAG,EAAE;4BAChB,QAAQ,CAAC,EAAE,CAAC,GAAG,GAAG;4BAClB,QAAQ,CAAC,EAAE,CAAC,IAAI,GAAG;4BACnB,QAAQ,CAAC,EAAE,CAAC,MAAM,GAAG;wBACtB;oBACD,OAAO;wBACN,wBAAwB;wBACxB,gBAAgB;oBACjB;oBACA;gBACD;YACD,OAAO;gBACN,IAAI,SAAS,EAAE,aAAa,KAAI;oBAC/B,QAAQ,OAAO,KAAK,CAAC,QAAQ,UAAU;oBACvC,IAAI,SAAS,OAAO,MAAM,EAAE;wBAC3B,OAAO,MAAM;4BACZ,QAAQ;4BACR,cAAc;4BACd,GAAG;4BACH,QAAQ;4BACR,eAAe;4BACf,eAAe;wBAChB,GAAG;oBACJ;oBACA,IAAI,gBAAgB,GAAG;wBACtB,IAAI,SAAS,IAAI,KAAK,YAAW,aAAa,KAAI;4BACjD,QAAQ,CAAC;wBACV;oBACD;gBACD,OAAO,IAAI,SAAS,GAAG;oBACtB,QAAQ;gBACT,OAAO;oBACN,IAAI,SAAS,IAAI;wBAChB,IAAI,WAAW,cACd,OAAO;6BACH,IAAI,WAAW,oBAAoB;4BACvC,QAAQ,aAAa,GAAG;4BACxB,gBAAgB;4BAChB,IAAI,QAAQ,WAAW,EAAE;gCACxB,QAAQ,QAAQ,WAAW,CAAC,OAAO;4BACpC,OAAO;gCACN,CAAC,iBAAiB,CAAC,gBAAgB,EAAE,CAAC,EAAE,IAAI,CAAC;oCAC5C,UAAU;oCACV,OAAO;gCACR;4BACD;wBACD;oBACD,OAAO;wBACN,IAAI,UAAU,eAAe;4BAC5B,SAAS;wBACV;wBACA,IAAI,gBAAgB,GAAG;4BACtB,IAAI,kBAAkB,GAAG;gCACxB,gBAAgB,EAAE,+DAA+D;;gCACjF,QAAQ,aAAa,QAAQ;4BAC9B,OAAO,IAAI,kBAAkB,eAC5B,QAAQ,aAAa,QAAQ;gCAAC;oCAAE,KAAK;oCAAM,MAAM;gCAAE;6BAAE;iCACjD,IAAI,SAAS,MAAM,IAAI,CAAC,SAAS,IAAI,IAAI,YAAY,MAAM,SAAS,YAAY,CAAC,IAAI,EACzF,QAAQ,aAAa,QAAQ,SAAS,YAAY;iCAElD,QAAQ,aAAa,QAAQ;wBAC/B,OACC,QAAQ,aAAa,QAAQ;wBAC9B,IAAI,aAAa;4BAChB,IAAI,UAAU,WAAW;gCACxB,cAAc,KAAK,sHAAsH;;gCACzI,OAAO,QAAQ,GAAG;gCAClB,OAAO,MAAM;oCACZ,QAAQ;oCACR,cAAc;oCACd,GAAG;oCACH,QAAQ;oCACR,UAAU;oCACV,eAAe;oCACf,kBAAkB;oCAClB,eAAe;gCAChB,GAAG;4BACJ,OAAO;gCACN,gGAAgG;gCAChG,YAAY,MAAM,GAAG,SAAS,MAAM,YAAY,QAAQ,SAAS,MAAM,GAAG;4BAC3E;wBACD,EAAC;;OAEA;oBACF;gBACD;YACD;YACA,IAAI,CAAC,UAAU;gBACd,MAAM,IAAI,MAAM,iCAAiC,CAAC,aAAa,GAAG,GAAG,SAAS,aAAa,GAAG,GAAG,EAAE;YACpG;YACA,IAAI,gBAAgB,KAAK,YAAY,SAAS,IAAI,KAAK,iBAAgB,kBAAkB,KAAI;gBAC5F,IAAI,SAAS,SAAS,MAAM;gBAC5B,IAAI,OAAO,UAAU,UAAU;oBAC9B,QAAQ,MAAM,CAAC,OAAO;oBACtB,IAAI,UAAU,aAAa,CAAC,CAAC,AAAC,UAAW,MAAM,GAAG;wBACjD,MAAM,IAAI,MAAM;oBACjB;gBACD,OAAO,IAAI,CAAC,SAAS,KAAK,SAAS,CAAC,KAAK,QAAQ;oBAChD,IAAI,OAAO,YAAY,GAAG,CAAC,GAAG;wBAC7B,qDAAqD;wBACrD,IAAI,SAAS,oBAAoB,EAAE;4BAClC,SAAS,oBAAoB,CAAC;wBAC/B;wBACA,MAAM,CAAC,OAAO,YAAY,GAAG,GAAG;oBACjC,OAAO;wBACN,OAAO,IAAI,CAAC;oBACb;gBACD;YACD;YAEA,IAAI,gBAAgB,GAAG;gBACtB,6CAA6C;gBAC7C,IAAI,kBAAkB,GAAG;oBACxB,SAAS,GAAG,GAAG;gBAChB,OAAO,IAAI,kBAAkB,eAAe;oBAC3C,IAAI,OAAO,UAAU,UAAU;wBAC9B,IAAI,eAAe,YAAY,GAAG,CAAC;wBACnC,IAAI,cAAc;4BACjB,IAAI,aAAa,SAAS,EAAE;gCAC3B,SAAS,SAAS,GAAG,aAAa,SAAS;4BAC5C,OAAO;gCACN,SAAS,UAAU,GAAG;4BACvB;wBACD,OAAO,IAAI,QAAQ,mBAAmB,EAAE;4BACvC,MAAM,IAAI,MAAM,6CAA6C;wBAC9D,OAAO;wBACN,oDAAoD;wBACrD;wBACA,SAAS,YAAY,GAAG,aAAa,sDAAsD;;oBAC5F,OAAO;wBACN,2FAA2F;wBAC3F,SAAS,QAAQ,GAAG;wBACpB,IAAI,UAAU,gBACb,SAAS,SAAS,GAAG;oBACvB;gBACD,OAAO,IAAI,kBAAkB,sBAAsB;oBAClD,IAAI,SAAS,SAAS,MAAM,IAAI,CAAC,SAAS,MAAM,GAAG,EAAE;oBACrD,qCAAqC;oBACrC,OAAO,YAAY,GAAG;gBACvB,OAAO,IAAI,kBAAkB,iBAAiB;gBAC7C,8DAA8D;gBAC/D,OAAO;oBACN,MAAM,IAAI,MAAM,2BAA2B;gBAC5C;gBACA,gBAAgB,EAAE,2CAA2C;;gBAC7D,UAAS,wCAAwC;YAClD,OAAO;gBACN,gBAAgB;YACjB;YACA,IAAI,SAAS,SAAS,EAAE;gBACvB,QAAQ,SAAS,SAAS,CAAC;YAC5B;YACA,IAAI,WAAW,SAAS,GAAG,KAAK,MAAM;gBACrC,OAAO,IAAI,CAAC;YACb,OAAO,IAAI,UAAU,WAAW;gBAC/B,MAAM,CAAC,SAAS,GAAG,CAAC,GAAG;YACxB;YACA;YACA,IAAI,CAAC,SACJ;QACF;QACA,OAAO;IACR;IAEA,SAAS,YAAY,MAAM;QAC1B,MAAM,IAAI,MAAM,kBAAkB;IACnC;IACA,IAAI;IACJ,SAAS,QAAQ,KAAK;QACrB,IAAI,IAAI,OAAO,UAAU,cAAc,SAAS;QAChD,IAAI,SAAS,MAAM,IAAI,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,EACvC,QAAQ,IAAI,CAAC,CAAC,MAAM,IAAI,CAAC,CAAC,MAAM,OAAO;aACnC,IAAI,OAAO,SAAS,UACxB,QAAQ,IAAI,MAAM;QACnB,IAAI,QAAQ,OAAO,EAClB,QAAQ,OAAO,CAAC;aACZ;YACJ,kBAAkB;YAClB,MAAM;QACP;IACD;IAEA,IAAI,gBAAgB;IACpB,SAAS,KAAK,QAAQ;QACrB,IAAI;YACH,IAAI,YAAY,SAAS,MAAM,EAAE;gBAChC,IAAI,WAAW,SAAS,QAAQ;gBAChC,QAAQ,aAAa,SAAS,MAAM,EAAE;gBACtC,yFAAyF;gBACzF,QAAQ,SAAS,MAAM,IAAI;gBAC3B,WAAW,SAAS,QAAQ;YAC7B,OAAO;gBACN,WAAW,YAAY;oBAAC,WAAW,QAAQ,MAAM,IAAI;wBACpD,KAAK;wBACL,MAAM;oBACP;iBAAE;gBACF,IAAI,QAAQ,aAAa,GAAG,SAAS,CAAC,QAAQ,CAAC,EAAE,CAAC,GAAG,CAAC;YACvD;YACA,MAAO,KAAM;gBACZ,IAAI,aAAa;oBAChB,OAAO,MAAM;wBACZ,QAAQ;wBACR,QAAQ;wBACR,UAAU;oBACX;gBACD;gBACA,IAAI,CAAC,eAAe;oBACnB,OAAO;gBACR;gBACA,IAAI,QAAQ,cAAc,KAAK,IAAI;gBACnC,IAAI,eAAe,aAAa,CAAC,MAAM;gBACvC,cAAc,KAAK,GAAG,QAAQ;gBAC9B,IAAI,CAAC,cAAc;oBAClB,gBAAgB,cAAc,MAAM;oBACpC;gBACD;gBACA,IAAI,SAAS,aAAa,KAAK;gBAC/B,IAAI,sBAAsB;gBAC1B,gBAAgB,EAAE;gBAClB,cAAc,MAAM,GAAG;gBACvB,IAAI,iBAAiB,aAAa,QAAQ;gBAC1C,IAAI,SAAS,aAAa,GAAG,WAAW;oBAAC;wBACxC,QAAQ;wBACR,KAAK;wBACL,cAAc;wBACd,QAAQ;oBACT;iBAAE;gBACF,SAAS,OAAO,IAAI,IAAI,MAAM,CAAC,eAAe,GAAG,CAAC,CAAC,yFAAyF;;gBAC5I,IAAI,UAAU,QAAQ;oBACrB,iEAAiE;oBACjE,OAAO,MAAM,CAAC,QAAQ;oBACtB,IAAI,eAAe,YAAY,MAAM,KAAK,QAAQ;wBACjD,YAAY,MAAM,GAAG;oBACtB;oBACA,IAAI,UAAU,OAAO,WAAW,KAAK,OAAO;wBAC3C,OAAO,MAAM,GAAG,OAAO,MAAM;wBAC7B,OAAO,cAAc,CAAC,QAAQ,OAAO,cAAc,CAAC,SAAS,oCAAoC;;oBAClG;gBACD;YACD;QACD,EAAE,OAAM,OAAO;YACd,IAAI,CAAC,iBACJ,MAAM,OAAO,GAAG,0BAA0B,MAAM,OAAO,GAAG,mBAAmB,CAAC,SAAS,aAAa,IAAI,YAAY,OAAO,KAAK,CAAC,SAAS,IAAI,SAAS;YACxJ,MAAM;QACP;IACD;IAEA,IAAI,SAAS;QACZ,WAAW,SAAS,MAAM,EAAE,WAAW,EAAE,eAAe;YACvD,SAAS;YACT,SAAS,eAAe;YACxB,gBAAgB;YAChB,YAAY;YACZ,OAAO,IAAI;QACZ;QACA,aAAa;YACZ,OAAO,OAAO,MAAM,GAAG;QACxB;QACA,UAAU;YACT,OAAO;QACR;QACA,0BAA0B;YACzB,OAAO,iBAAiB,cAAc,MAAM,GAAG,cAAc,KAAK;QACnE;QACA,WAAW;YACV,OAAO,SAAS;QACjB;QACA,MAAM;IACP;IACA,OAAO;AACR;AACA,QAAQ,KAAK,GAAG,SAAS,cAAc,EAAE,OAAO;IAC/C,IAAI;IACJ,IAAI,OAAO,mBAAmB,UAAU;QACvC,SAAS;IACV,OAAO,IAAI,kBAAkB,eAAe,QAAQ,EAAE;QACrD,SAAS,eAAe,QAAQ,CAAC,WAAW,QAAQ,QAAQ,IAAI;IACjE,OAAO;QACN,OAAO;IACR;IACA,IAAI,SAAS,aAAa,SAAS,SAAS,CAAC;IAC7C,IAAI,WAAW,QAAQ,MAAM,EAC5B,OAAO,OAAO,IAAI,CAAC;QAAC,QAAQ,MAAM;KAAC;IACpC,OAAO,OAAO,IAAI;AACnB;AACA,QAAQ,YAAY,GAAG;AAEvB,IAAI,UAAU;IACb,WAAW,SAAS,OAAO;QAC1B,IAAI,MAAM,IAAI;QACd,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,MAAM,EAAE,IAAI,GAAG,IAAK;YAC/C,IAAI,QAAQ,OAAO,CAAC,EAAE;YACtB,IAAI,GAAG,CAAC,MAAM,GAAG,EAAE,MAAM,KAAK;QAC/B;QACA,OAAO;IACR;AACD;AACA,IAAI,UAAU;IACb,WAAW,SAAS,MAAM;QACzB,IAAI,MAAM,IAAI,IAAI;QAClB,IAAI,IAAI,IAAI,KAAK,KAAK,OAAO,MAAM,GAAG,GAAG;YACxC,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,IAAI,GAAG,IAAK;gBAC9C,IAAI,GAAG,CAAC,MAAM,CAAC,EAAE;YAClB;QACD;QACA,OAAO;IACR;AACD;AACA,IAAI,WAAW;IACd,WAAW,SAAS,IAAI;QACvB,OAAO,IAAI,KAAK;IACjB;AACD"}},
    {"offset": {"line": 1430, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1434, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/parse-stream.js"],"sourcesContent":["\"use strict\"\r\nvar Transform = require('stream').Transform\r\nvar createParser = require('./parse').createParser\r\nvar DEFAULT_OPTIONS = {objectMode: true}\r\n\r\nclass DPackParseStream extends Transform {\r\n\tconstructor(options) {\r\n\t\tif (options) {\r\n\t\t\toptions.objectMode = true\r\n\t\t} else {\r\n\t\t\toptions = DEFAULT_OPTIONS\r\n\t\t}\r\n\t\tsuper(options)\r\n\t\tthis.parser = createParser(options)\r\n\t\tthis.waitingValues = []\r\n\t}\r\n\t_transform(chunk, encoding, callback) {\r\n\t\tvar value\r\n\t\ttry {\r\n\t\t\tvar sourceString = chunk.toString()\r\n\t\t\tvar parser = this.parser\r\n\t\t\tif (parser.onResume) {\r\n\t\t\t\tvalue = parser.onResume(sourceString, true)\r\n\t\t\t\tif (!parser.isPaused())\r\n\t\t\t\t\tthis.sendValue(value)\r\n\t\t\t} else {\r\n\t\t\t\tparser.setSource(sourceString, 0, true)\r\n\t\t\t}\r\n\t\t\twhile (parser.hasMoreData()) {\r\n\t\t\t\tvalue = parser.read()\r\n\t\t\t\tif (parser.isPaused())\r\n\t\t\t\t\tbreak\r\n\t\t\t\telse\r\n\t\t\t\t\tthis.sendValue(value)\r\n\t\t\t}\r\n\t\t} catch (error) { // must catch errors here, and still call callback\r\n\t\t\tconsole.error(error)\r\n\t\t}\r\n\t\tif (callback) callback()\r\n\t}\r\n\tsendValue(value) {\r\n\t\tif (this.parser.hasUnfulfilledReferences()) {\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tthis.waitingValues.push(value)\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\twhile (this.waitingValues.length > 0) {\r\n\t\t\t\tthis.push(this.waitingValues.shift())\r\n\t\t\t}\r\n\t\t\tif (value !== undefined) {\r\n\t\t\t\tthis.push(value)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexports.createParseStream = () => new DPackParseStream()\r\n"],"names":[],"mappings":"AAAA;AACA,IAAI,YAAY,kBAAkB,SAAS;AAC3C,IAAI,eAAe,4FAAmB,YAAY;AAClD,IAAI,kBAAkB;IAAC,YAAY;AAAI;AAEvC,MAAM,yBAAyB;IAC9B,YAAY,OAAO,CAAE;QACpB,IAAI,SAAS;YACZ,QAAQ,UAAU,GAAG;QACtB,OAAO;YACN,UAAU;QACX;QACA,KAAK,CAAC;QACN,IAAI,CAAC,MAAM,GAAG,aAAa;QAC3B,IAAI,CAAC,aAAa,GAAG,EAAE;IACxB;IACA,WAAW,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE;QACrC,IAAI;QACJ,IAAI;YACH,IAAI,eAAe,MAAM,QAAQ;YACjC,IAAI,SAAS,IAAI,CAAC,MAAM;YACxB,IAAI,OAAO,QAAQ,EAAE;gBACpB,QAAQ,OAAO,QAAQ,CAAC,cAAc;gBACtC,IAAI,CAAC,OAAO,QAAQ,IACnB,IAAI,CAAC,SAAS,CAAC;YACjB,OAAO;gBACN,OAAO,SAAS,CAAC,cAAc,GAAG;YACnC;YACA,MAAO,OAAO,WAAW,GAAI;gBAC5B,QAAQ,OAAO,IAAI;gBACnB,IAAI,OAAO,QAAQ,IAClB;qBAEA,IAAI,CAAC,SAAS,CAAC;YACjB;QACD,EAAE,OAAO,OAAO;YACf,QAAQ,KAAK,CAAC;QACf;QACA,IAAI,UAAU;IACf;IACA,UAAU,KAAK,EAAE;QAChB,IAAI,IAAI,CAAC,MAAM,CAAC,wBAAwB,IAAI;YAC3C,IAAI,UAAU,WAAW;gBACxB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC;YACzB;QACD,OAAO;YACN,MAAO,IAAI,CAAC,aAAa,CAAC,MAAM,GAAG,EAAG;gBACrC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK;YACnC;YACA,IAAI,UAAU,WAAW;gBACxB,IAAI,CAAC,IAAI,CAAC;YACX;QACD;IACD;AACD;AAEA,QAAQ,iBAAiB,GAAG,IAAM,IAAI"}},
    {"offset": {"line": 1488, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1492, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/node-encoder.js"],"sourcesContent":["var PREFERRED_MAX_BUFFER_SIZE = 0x8000\r\nvar availableBuffers = []\r\nfunction nodeCharEncoder(options) {\r\n\tvar offset = options.startOffset || 0\r\n\tvar bufferSize\r\n\tvar outlet = options.outlet\r\n\tvar buffer = availableBuffers.pop()\r\n\tif (buffer && buffer.length > offset + 0x80) {\r\n\t\t// reuse existing buffer if we can\r\n\t\tbufferSize = buffer.length\r\n\t} else {\r\n\t\tbufferSize = (offset >> 12 << 12) + 0x2000\r\n\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize)\r\n\t}\r\n\tvar encoding = options.encoding\r\n\tvar sequences = []\r\n\tfunction makeRoom(bytesNeeded) {\r\n\t\tif (outlet) {\r\n\t\t\toutlet.writeBytes(buffer.slice(0, offset))\r\n\t\t\tif (bufferSize < PREFERRED_MAX_BUFFER_SIZE || bytesNeeded > PREFERRED_MAX_BUFFER_SIZE) {\r\n\t\t\t\tbufferSize = Math.max(bufferSize * 4, bytesNeeded)\r\n\t\t\t}\r\n\t\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize)\r\n\t\t\toffset = 0\r\n\t\t\tsequences = [] // clear insertion points\r\n\t\t\tencoder.hasWritten = true\r\n\t\t} else {\r\n\t\t\tbufferSize = Math.max(bufferSize * 4, bufferSize + bytesNeeded, 0x2000)\r\n\t\t\tvar oldBuffer = buffer\r\n\t\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize)\r\n\t\t\toldBuffer.copy(buffer, 0, 0, offset)\r\n\t\t}\r\n\t}\r\n\tfunction flush(specifiedOutlet) {\r\n\t\t(specifiedOutlet || outlet).writeBytes(buffer.slice(0, offset))\r\n\t\tif (offset + 0x80 > buffer.length)\r\n\t\t\tbuffer = Buffer.allocUnsafeSlow(bufferSize = Math.min(Math.max((offset >> 10 << 10) + 0x2000, bufferSize), 0x8000)) // allocate a new buffer, don't want to overwrite the bytes in the old one while they are in use!\r\n\t\telse {// or continue to use the remaining space in this buffer, if there is a lot of room left\r\n\t\t\tbuffer = buffer.slice(offset)\r\n\t\t\tbufferSize = buffer.length\r\n\t\t}\r\n\t\toffset = 0\r\n\t\tsequences = [] // clear insertion points\r\n\t}\r\n\tfunction writeToken(type, number) {\r\n\t\tif (number < 0x10) { // 4 bits of number\r\n\t\t\tbuffer[offset++] = ((type << 4) + number) ^ 0x40\r\n\t\t} else if (number < 0x400) { // 10 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 6)\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x10000) { // 16 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 12)\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x400000) { // 22 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 18)\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x10000000) { // 28 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 24)\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x100000000) { // 32 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number >>> 30)\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x400000000) { // 34 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number / 0x40000000 >>> 0)\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x10000000000) { // 40 bits of number\r\n\t\t\tbuffer[offset++] = (type << 4) + (number / 0x1000000000 >>> 0)\r\n\t\t\tbuffer[offset++] = (number / 0x40000000) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else if (number < 0x400000000000) { // 46 bits of number (needed for dates!)\r\n\t\t\tbuffer[offset++] = (type << 4) + (number / 0x40000000000 >>> 0)\r\n\t\t\tbuffer[offset++] = (number / 0x1000000000) & 0x3f\r\n\t\t\tbuffer[offset++] = (number / 0x40000000) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 24) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 18) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 12) & 0x3f\r\n\t\t\tbuffer[offset++] = (number >>> 6) & 0x3f\r\n\t\t\tbuffer[offset++] = (number & 0x3f) + 0x40\r\n\t\t} else {\r\n\t\t\tthrow new Error('Invalid number ' + number)\r\n\t\t}\r\n\t\tif (offset > bufferSize - 10) {\r\n\t\t\tmakeRoom(0)\r\n\t\t}\r\n\t}\r\n\r\n\tfunction writeBuffer(source) {\r\n\t\tvar sourceLength = source.length\r\n\t\tif (sourceLength + offset + 10 > bufferSize) {\r\n\t\t\tmakeRoom(sourceLength + 10)\r\n\t\t}\r\n\t\tsource.copy(buffer, offset)\r\n\t\toffset += sourceLength\r\n\t}\r\n\r\n\tfunction writeString(string) {\r\n\t\tvar length = string.length\r\n\t\tvar maxStringLength = length * 3 + 10\r\n\t\tif (offset + maxStringLength > bufferSize) {\r\n\t\t\tmakeRoom(maxStringLength + 10)\r\n\t\t}\r\n\t\tvar bytesWritten = encoding ? buffer.write(string, offset, buffer.length, encoding) :\r\n\t\t\tbuffer.utf8Write(string, offset, buffer.length)\r\n\t\toffset += bytesWritten\r\n\t}\r\n\tfunction getSerialized() {\r\n\t\treturn buffer.slice(0, offset)\r\n\t}\r\n\tfunction insertBuffer(headerBuffer, position) {\r\n\t\tvar headerLength = headerBuffer.length\r\n\t\tif (offset + headerLength + 10 > bufferSize) {\r\n\t\t\tmakeRoom(headerLength + 10)\r\n\t\t}\r\n\t\tbuffer.copy(buffer, headerLength + position, position, offset)\r\n\t\theaderBuffer.copy(buffer, position)\r\n\t\toffset += headerLength\r\n\t}\r\n\r\n\tvar encoder = {\r\n\t\twriteToken,\r\n\t\twriteString,\r\n\t\twriteBuffer,\r\n\t\tgetSerialized,\r\n\t\tinsertBuffer,\r\n\t\tflush,\r\n\t\tstartSequence() {\r\n\t\t\tvar currentOffset = offset\r\n\t\t\tbuffer[offset++] = 60\r\n\t\t\tsequences.push(currentOffset)\r\n\t\t\tif (offset > bufferSize - 10) {\r\n\t\t\t\tmakeRoom(0)\r\n\t\t\t}\r\n\t\t},\r\n\t\tendSequence(length) {\r\n\t\t\tvar startOffset = sequences.pop()\r\n\t\t\tif (length < 12 && startOffset > -1) { // if it is short enough, and hasn't been cleared, we can set the beginning byte length\r\n\t\t\t\tbuffer[startOffset] = 48 + length\r\n\t\t\t\treturn\r\n\t\t\t}\r\n\t\t\tbuffer[offset++] = 62 // else we need to put an end sequence token in\r\n\t\t},\r\n\t\tfinish() {\r\n\t\t\tif (buffer.length - offset > 0x90)\r\n\t\t\t\tavailableBuffers.push(buffer.slice(offset))\r\n\t\t},\r\n\t\tgetOffset() {\r\n\t\t\treturn offset\r\n\t\t},\r\n\t\tsetOffset(newOffset) {\r\n\t\t\toffset = newOffset\r\n\t\t}\r\n\t}\r\n\tif (false) {\r\n\t\tglobal.typeCount = []\r\n\t\tencoder.writeToken = function(type, number) {\r\n\t\t\ttypeCount[type] = (typeCount[type] || 0) + 1\r\n\t\t\twriteToken(type, number)\r\n\t\t}\r\n\t\tglobal.stringCount = new Map()\r\n\t\tencoder.writeString = function(string) {\r\n\t\t\tstringCount.set(string, (stringCount.get(string) || 0) + 1)\r\n\t\t\twriteString(string)\r\n\t\t}\r\n\t\tsetTimeout(function() {\r\n\t\t\tvar stringDuplicationCount = 0\r\n\t\t\tconsole.log('stringCount', Array.from(stringCount).filter(([string, count]) => {\r\n\t\t\t\tif (count > 1 & string.length > 3) {\r\n\t\t\t\t\tstringDuplicationCount += (count - 1) * string.length\r\n\t\t\t\t\treturn true\r\n\t\t\t\t}\r\n\t\t\t}))\r\n\t\t\tconsole.log('stringDuplicationCount', stringDuplicationCount)\r\n\t\t\tconsole.log('typeCount', typeCount)\r\n\t\t})\r\n\t}\r\n\treturn encoder\r\n}\r\nexports.nodeCharEncoder = nodeCharEncoder\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1666, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1670, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/Options.js"],"sourcesContent":["\"use strict\"\r\nfunction Options() {\r\n\tvar classByName = this.classByName = new Map()\r\n\tthis.converterByConstructor = new Map()\r\n\t//writerByConstructor.set(Map, writeMap)\r\n\t//writerByConstructor.set(Set, writeSet)\r\n}\r\nOptions.prototype.addExtension = function(Class, name, options) {\r\n\tif (name && Class.name !== name) {\r\n\t\tClass.name = name\r\n\t}\r\n\tthis.classByName.set(Class.name, (options && options.fromArray) ? options : Class)\r\n\tthis.converterByConstructor.set(Class, (options && options.toArray) ? options : Class)\r\n}\r\nexports.Options = Options\r\n"],"names":[],"mappings":"AAAA;AACA,SAAS;IACR,IAAI,cAAc,IAAI,CAAC,WAAW,GAAG,IAAI;IACzC,IAAI,CAAC,sBAAsB,GAAG,IAAI;AAClC,wCAAwC;AACxC,wCAAwC;AACzC;AACA,QAAQ,SAAS,CAAC,YAAY,GAAG,SAAS,KAAK,EAAE,IAAI,EAAE,OAAO;IAC7D,IAAI,QAAQ,MAAM,IAAI,KAAK,MAAM;QAChC,MAAM,IAAI,GAAG;IACd;IACA,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM,IAAI,EAAE,AAAC,WAAW,QAAQ,SAAS,GAAI,UAAU;IAC5E,IAAI,CAAC,sBAAsB,CAAC,GAAG,CAAC,OAAO,AAAC,WAAW,QAAQ,OAAO,GAAI,UAAU;AACjF;AACA,QAAQ,OAAO,GAAG"}},
    {"offset": {"line": 1685, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1689, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/shared.js"],"sourcesContent":["const createSerializer = require('./serialize').createSerializer\r\nconst serialize = require('./serialize').serialize\r\nconst createParser = require('./parse').createParser\r\nconst Options = require('./Options').Options\r\nconst STRING_CODE = 2\r\nvar PROPERTY_CODE = 0\r\nvar NUMBER_CODE = 1\r\nvar TYPE_CODE = 3\r\nvar SEQUENCE_CODE = 7\r\n\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\nvar REFERENCING_TYPE = 8\r\nvar NUMBER_TYPE = 9\r\n\r\nvar NULL = 0 // p\r\n\r\nvar METADATA_TYPE = 11\r\nvar REFERENCING_POSITION = 13\r\nvar TYPE_DEFINITION = 14 // ~  // for defining a typed object without returning the value\r\nvar UNSTRUCTURED_MARKER = 11\r\n\r\nvar OPEN_SEQUENCE = 12 // <\r\nvar END_SEQUENCE = 14 // >\r\n\r\nvar COUNT_THRESHOLD = 2\r\n\r\nexports.createSharedStructure = createSharedStructure\r\nexports.readSharedStructure = readSharedStructure\r\nfunction readSharedStructure(from) {\r\n\tvar parser = createParser()\r\n\tvar sharedProperty = []\r\n\tsharedProperty.code = 6\r\n\tsharedProperty.key = null\r\n\t// end with with NULL (p) value to return something from type definition\r\n\tparser.setSource(from + 'p').read([sharedProperty])\r\n\tsetupShared(sharedProperty)\r\n\tsharedProperty.serialized = from\r\n\treturn sharedProperty\r\n}\r\n\r\nfunction setupShared(property) {\r\n\tproperty.resetTo = property.length\r\n\tproperty.upgrade = upgrade\r\n\tproperty.type = types[property.code]\r\n\tproperty.isFrozen = true\r\n\tObject.defineProperty(property, 'serialized', {\r\n\t\tget() {\r\n\t\t\treturn this._serialized || (this._serialized = serializeSharedStructure(this))\r\n\t\t}\r\n\t})\r\n\r\n\tif (typeof property.values === 'object' && property.values) {\r\n\t\tproperty.values.resetTo = property.values.length\r\n\t\tproperty.lastIndex = property.values.length\r\n\t}\r\n\tfor (var i = 0, l = property.length; i < l; i++) {\r\n\t\tproperty[i].index = i\r\n\t\tproperty[i].resumeIndex = i\r\n\t\tsetupShared(property[i])\r\n\t}\r\n}\r\nfunction startWrite() {\r\n\tfor (var i = 0, l = this.length; i < l; i++) {\r\n\t\tstartWrite.call(this[i])\r\n\t}\r\n\tthis.length = this.resetTo || 0\r\n\tif (typeof this.values === 'object' && this.values) {\r\n\t\tthis.values.length = this.values.resetTo || 0\r\n\t}\r\n}\r\n\r\n\r\n\r\n\t\t// upgrades the property to output this block\r\n\t\t// return 0 if the property was upgraded, or is compatible,\r\n\t\t// 1 if the shared information needs to be written out, but the property was upgraded\r\n\t\t// 2 if the shared information needs to be reserialized\r\nfunction upgrade(property) {\r\n\tif (!property) {\r\n\t\treturn 1\r\n\t}\r\n\tvar compatibility\r\n\tif (property) {\r\n\t\t// same block was serialized last time, fast path to compatility\r\n\t\tif (property.insertedFrom === this && property.insertedVersion === this.version && (\r\n\t\t\t\tproperty.recordUpdate || property.isFrozen || (property.length == 0 && property.code == this.code && property.values == null)\r\n\t\t\t)) {\r\n\t\t\t// but if the version incremented, we need to update\r\n\t\t\treturn 0\r\n\t\t}\r\n\t\tvar changedCode\r\n\t\tif (this.code !== property.code)\r\n\t\t\tchangedCode = true\r\n\t\tif (property.upgrade) {\r\n\t\t\tvar compatibility = copyProperty(this, property)\r\n\t\t\tif (changedCode)\r\n\t\t\t\tcompatibility = 2\r\n\t\t\tif (property.isFrozen && compatibility > 0) {\r\n\t\t\t\treturn 2\r\n\t\t\t}\r\n\t\t\tproperty.insertedFrom = this\r\n\t\t\tproperty.insertedVersion = this.version\r\n\t\t\tif (compatibility === 2) {\r\n\t\t\t\tdebugger\r\n\t\t\t\tconsole.error('Inserting incompatible block into property')\r\n\t\t\t\treturn 2\r\n\t\t\t} else \r\n\t\t\treturn 0\r\n\t\t} else { // upgrading into non-shared property,\r\n\t\t\tproperty.insertedFrom = this\r\n\t\t\tproperty.insertedVersion = this.version\r\n\t\t\t// if this is not a shared property that tracks changes, we have reset and ensure that it doesn't change when we reuse it\r\n\t\t\tproperty.length = 0\r\n\t\t\tproperty.values = null\r\n\t\t\tif (property.fromValue)\r\n\t\t\t\tproperty.fromValue = null\r\n\t\t\treturn 1\r\n\t\t}\r\n\t} else {\r\n\t\tif (this.length > 0) {\r\n\t\t\t// no property, (but block is shared) so just write the buffer with its shared part (if there is one)\r\n\t\t\tblockBuffer = Buffer.concat([this.serialized, blockBuffer])\r\n\t\t}\r\n\t}\r\n\treturn 1\r\n}\r\n\r\nvar typeToCode = {\r\n\tstring: REFERENCING_TYPE,\r\n\tnumber: NUMBER_TYPE,\r\n\tobject: DEFAULT_TYPE,\r\n\tboolean: DEFAULT_TYPE,\r\n\tundefined: DEFAULT_TYPE,\r\n\tarray: ARRAY_TYPE\r\n}\r\n\r\nvar lastPropertyOnObject = new WeakMap()\r\n\r\nfunction createSharedStructure(from, options) {\r\n\tvar instanceProperty = []\r\n\tinstanceProperty.key = null\r\n\tinstanceProperty.code = 6\r\n\tinstanceProperty.type = 'object'\r\n\tlet activeList = []\r\n\tlet needsCleanup = []\r\n\tactiveList.iteration = 0\r\n\tvar previousAvoidShareUpdate\r\n\r\n// property id ranges:\r\n// shared: 0 - 511\r\n// instance: 512+\r\n// shared: \r\n\r\n\tclass Shared extends Array {\r\n\t\tconstructor(instanceProperty) {\r\n\t\t\tsuper()\r\n\t\t\tlet hasUpdates\r\n\t\t\tthis.key = typeof instanceProperty.key == 'string' ? isolateString(instanceProperty.key) : instanceProperty.key\r\n\t\t\tthis.type = instanceProperty.type\r\n\t\t\tthis.code = instanceProperty.code\r\n\t\t\tthis.count = 0\r\n\t\t\tthis.comesAfter = []\r\n\t\t\tif (this.code == REFERENCING_TYPE) {\r\n\t\t\t\tthis.values = []\r\n\t\t\t\tthis.values.resetTo = 512\r\n\t\t\t\tthis.values.nextPosition = 512\r\n\t\t\t\tthis.previousValues = new Map()\r\n\t\t\t\tthis.lastIndex = 0\r\n\t\t\t\tthis.repetitions = 0\r\n\t\t\t}\r\n\t\t}\r\n\t\tnewProperty(instance) {\r\n\t\t\treturn new Shared(instance)\r\n\r\n\t\t}\r\n\t\tgetProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex) {\r\n\t\t\tlet property\r\n\t\t\tif (this.insertedFrom) {\r\n\t\t\t\tpropertySearch(this.insertedFrom)\r\n\t\t\t\tif (property) {\r\n\t\t\t\t\tif (lastPropertyIndex !== property.index) {\r\n\t\t\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn property\r\n\t\t\t\t}\r\n\t\t\t\tif (this.insertedFrom.getProperty) {\r\n\t\t\t\t\t//this.recordUpdate()\r\n\t\t\t\t\treturn this.insertedFrom.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tdebugger\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthis.recordUpdate()\r\n\t\t\tlet propertyIndex = this.length\r\n\t\t\tif (lastPropertyIndex !== propertyIndex) {\r\n\t\t\t\twriteToken(PROPERTY_CODE, propertyIndex)\r\n\t\t\t}\r\n\t\t\tif (type === 'boolean' || type === 'undefined') {\r\n\t\t\t\ttype = 'object'\r\n\t\t\t}\r\n\t\t\tproperty = this[propertyIndex] = new Shared({\r\n\t\t\t\tkey,\r\n\t\t\t\ttype,\r\n\t\t\t\tcode: typeToCode[type]\r\n\t\t\t})\r\n\t\t\tproperty.parent = this\r\n\t\t\tproperty.index = propertyIndex\r\n\t\t\treturn property\r\n\t\t\tfunction propertySearch(parentProperty) {\r\n\t\t\t\tlet propertyIndex = -1\r\n\t\t\t\tdo {\r\n\t\t\t\t\tproperty = parentProperty[++propertyIndex]\r\n\t\t\t\t} while(property && (property.key !== key ||\r\n\t\t\t\t\t\t(property.type !== type && type !== 'boolean' && type !== 'undefined') ||\r\n\t\t\t\t\t\t(extendedType && property.extendedType !== constructor)))\r\n\t\t\t}\r\n\t\t}\r\n\t\twriteSharedValue(value, writeToken, serializerId) {\r\n\t\t\t// there are several possible states of a property:\r\n\t\t\t// 1) Non-referencing state (initial state) - We don't reset position indices, and we never reference previous values\r\n\t\t\t// 2) Shared/repetitive state - We can have shared values (<12 position) and we can reference properties in an instance (>=12 position)\r\n\t\t\t// 3) Non-repetitive - If repetition is rare, goes to default type\r\n\t\t\tlet valueEntry = this.previousValues.get(value)\r\n\t\t\tif (valueEntry) {\r\n\t\t\t\tif (valueEntry.serializer == serializerId) {\r\n\t\t\t\t\tthis.repetitions++\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvalueEntry.serializations++\r\n\t\t\t\t\tvalueEntry.serializer = serializerId\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.previousValues.set(value, valueEntry = {\r\n\t\t\t\t\tserializations: 1,\r\n\t\t\t\t\tserializer: serializerId\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tif (!this.active) {\r\n\t\t\t\tthis.active = 2\r\n\t\t\t\tactiveList.push(this)\r\n\t\t\t}\r\n\t\t\treturn false\r\n\t\t\t/*var index = this.values.length\r\n\t\t\tif (index < 12)\r\n\t\t\t\tthis.values[index] = value*/\r\n\t\t}\r\n\t\tpropertyUsed(property, object, serializerId, i) {\r\n\t\t\tif (property.lastSerializer !== serializerId) {\r\n\t\t\t\tproperty.lastSerializer = serializerId\r\n\t\t\t\tproperty.count++\r\n\t\t\t}\r\n\t\t\tif (i !== 0) {\r\n\t\t\t\tlet lastProperty = lastPropertyOnObject.get(object)\r\n\t\t\t\t// record what has come before so we can order them when creating a common structure\r\n\t\t\t\tif (lastProperty && property.comesAfter.indexOf(lastProperty) === -1)\r\n\t\t\t\t\tproperty.comesAfter.push(lastProperty)\r\n\t\t\t}\r\n\t\t\tlastPropertyOnObject.set(object, property)\r\n\t\t}\r\n\t\trecordUpdate() {\r\n\t\t\tvar property = this\r\n\t\t\tdo {\r\n\t\t\t\tproperty.version = (property.version || 0) + 1\r\n\t\t\t\tif (property.insertedFrom) {\r\n\t\t\t\t\t// or we could try to upgrade the latest inserted property?\r\n\t\t\t\t\tproperty.insertedFrom = null\r\n\t\t\t\t}\r\n\t\t\t\tif (property._serialized)\r\n\t\t\t\t\tproperty._serialized = null\r\n\t\t\t} while(property = property.parent)\r\n\t\t}\r\n\r\n\t\treadingBlock(parse) {\r\n\t\t\t//var blockStructure = this.asBlockStructure()\r\n\t\t\ttry {\r\n\t\t\t\treturn parse()\r\n\t\t\t} finally {\r\n\t\t\t\tthis.readReset()\r\n\t\t\t\tif (this.length > 500) {\r\n\t\t\t\t\tdebugger\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t//active:\r\n\t\t// 0 - not-actively being monitored\r\n\t\t// 1 - being monitored, but an iteration hasn't started for this\r\n\t\t// 2 - being monitored, and an iteration has started\r\n\t\tstartWrite(avoidShareUpdate, value) {\r\n\t\t\tactiveList.iteration++\r\n\t\t\tif (value && value.constructor === Array) {\r\n\t\t\t\tif (this.code !== ARRAY_TYPE && this.version > 0) {\r\n\t\t\t\t\tthrow new Error('Can not change the root type of a shared object to an array')\r\n\t\t\t\t}\r\n\t\t\t\tif (this.code != ARRAY_TYPE)\r\n\t\t\t\t\tthis.recordUpdate()\r\n\t\t\t\tthis.code = ARRAY_TYPE\r\n\t\t\t\tthis.type = 'array'\r\n\t\t\t}\r\n\t\t\tif (this.writing)\r\n\t\t\t\treturn\r\n\t\t\telse\r\n\t\t\t\tthis.writing = true\r\n\t\t\treturn\r\n\t\t\tpreviousAvoidShareUpdate = currentAvoidShareUpdate\r\n\t\t\tif (avoidShareUpdate)\r\n\t\t\t\tcurrentAvoidShareUpdate = true\r\n\t\t}\r\n\t\tendWrite() {\r\n\t\t\tif (this.writing)\r\n\t\t\t\tthis.writing = false\r\n\t\t\telse\r\n\t\t\t\treturn\r\n\r\n\t\t\tlet iterations = this.iterations = (this.iterations || 0) + 1\r\n\t\t\tfor (let i = 0; i < activeList.length; i++) {\r\n\t\t\t\tlet activeSharedProperty = activeList[i]\r\n\t\t\t\tlet previousValues = activeSharedProperty.previousValues\r\n\t\t\t\tif (previousValues && previousValues.size && !activeSharedProperty.isFrozen) {\r\n\t\t\t\t\tif (!currentAvoidShareUpdate) {\r\n\t\t\t\t\t\tif (activeSharedProperty.values.length == 0 &&\r\n\t\t\t\t\t\t\titerations > ((activeSharedProperty.repetitions || 0) + 10) * 5) {\r\n\t\t\t\t\t\t\t// move to permanently non-repetitive\r\n\t\t\t\tconsole.log('changing referenceable to default', activeSharedProperty.key)\r\n\t\t\t\t\t\t\tactiveSharedProperty.previousValues = null\r\n\t\t\t\t\t\t\tactiveSharedProperty.code = DEFAULT_TYPE\r\n\t\t\t\t\t\t\tactiveSharedProperty.type = 'object'\r\n\t\t\t\t\t\t\tactiveSharedProperty.recordUpdate()\r\n\t\t\t\t\t\t\tactiveList.splice(i--, 1)\r\n\t\t\t\t\t\t\tpreviousValues = []\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tfor (let [value, entry] of previousValues) {\r\n\t\t\t\t\t\t\tlet values = activeSharedProperty.values\r\n\t\t\t\t\t\t\tif ((entry.serializations + 3) * 8 < iterations - (entry.startingIteration || (entry.startingIteration = iterations)) || values.length > 500) {\r\n\t\t\t\t\t\t\t\tpreviousValues.delete(value)\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif (entry.serializations > 50 && entry.serializations * 3 > iterations) {\r\n\t\t\t\t\t\t\t\tvalues[activeSharedProperty.lastIndex++] = value\r\n\t\t\t\t\t\t\t\tactiveSharedProperty.recordUpdate()\r\n\t\t\t\t\t\t\t\tconsole.log('adding value', value, 'to', activeSharedProperty.key)\r\n\t\t\t\t\t\t\t\tpreviousValues.delete(value) // done with tracking, it has been accepted as a common value\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tactiveSharedProperty.active = 0\r\n\t\t\t\t\tactiveList.splice(i--, 1)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (activeList.hasUpdates) {\r\n\t\t\t\tactiveList.hasUpdates = false\r\n\t\t\t\tthis.version++\r\n\t\t\t\tif (!this._serialized)\r\n\t\t\t\t\tthis._serialized = null\r\n\t\t\t\tif (options && options.onUpdate)\r\n\t\t\t\t\toptions.onUpdate()\r\n\t\t\t}\r\n\t\t\tcurrentAvoidShareUpdate = previousAvoidShareUpdate\r\n\t\t}\r\n\r\n\t\tupgrade(property) {\r\n\t\t\treturn upgrade.call(this, property)\r\n\t\t}\r\n\r\n\t\tget serialized() {\r\n\t\t\treturn this._serialized || (this._serialized = serializeSharedStructure(this))\r\n\t\t}\r\n\t\tserializeCommonStructure(embedded) {\r\n\t\t\tvar usageThreshold = Math.sqrt(activeList.iteration)\r\n\t\t\treturn serializeSharedStructure(this, childProperty => childProperty.count >= usageThreshold, embedded)\r\n\t\t}\r\n\t}\r\n\r\n\tvar sharedStructure = new Shared(instanceProperty)\r\n\tsharedStructure.version = 0\r\n\r\n\tsharedStructure.freeze = function() {\r\n\t\tthis.isFrozen = true\r\n\t\tthis.reset()\r\n\t}\r\n\r\n\tif (from) {\r\n\t\tvar parser = createParser({\r\n\t\t\tforDeferred(block, property) {\r\n\t\t\t\tproperty.isBlock = true\r\n\t\t\t\treturn block\r\n\t\t\t},\r\n\t\t\tparseDeferreds: true\r\n\t\t})\r\n\t\t// concatenate shared structure with null so there is a value to parse\r\n\t\tvar readProperty = []\r\n\t\treadProperty.code = 6\r\n\t\treadProperty.key = null\r\n\t\t// end with with NULL (p) value to return something from type definition\r\n\t\tparser.setSource(from + 'p').read([readProperty])\r\n\t\tcopyProperty(readProperty, sharedStructure)\r\n\t\tactiveList.hasUpdates = false\r\n\t\tsharedStructure.version = 1\r\n\t}\r\n\tsharedStructure.key = null // root must be null (for the parser to work properly)\r\n\r\n\treturn sharedStructure\r\n}\r\n\r\nfunction isDescendant(property, possibleParent) {\r\n\tdo {\r\n\t\tif (property === possibleParent)\r\n\t\t\treturn true\r\n\t} while (property = property.parent)\r\n}\r\n// default type for each code\r\nvar types = {\r\n\t6/*DEFAULT_TYPE*/: 'object',\r\n\t7/*ARRAY_TYPE*/: 'array',\r\n\t8/*REFERENCING_TYPE*/: 'string',\r\n\t9/*NUMBER_TYPE*/: 'number'\r\n}\r\n\r\nvar currentAvoidShareUpdate\r\nfunction serializeSharedStructure(property, condition, embedded) {\r\n\tvar serializer = createSerializer()\r\n\tvar writers = serializer.getWriters()\r\n\tserializeSharedProperty(property, !embedded, !embedded)\r\n\tfunction serializeSharedProperty(property, expectsObjectWithNullKey, isRoot) {\r\n\t\tif (property.insertedFrom && property.insertedFrom.serializeCommonStructure) {\r\n\t\t\tproperty = property.insertedFrom\r\n\t\t\treturn writers.writeBuffer(property.serializeCommonStructure(!isRoot))\r\n\t\t}\r\n\t\tvar isArray = property.code === ARRAY_TYPE\r\n\t\tvar commonProperties = condition ? orderProperties(property.filter(condition)) : property\r\n\t\tvar length = commonProperties.length\r\n\t\tif (!(expectsObjectWithNullKey && property.code === DEFAULT_TYPE)) {\r\n\t\t\tlet key = isRoot ? null : property.key\r\n\t\t\twriters.writeProperty(key, types[property.code])\r\n\t\t\tif (length === 0 && key === null && (property.code === DEFAULT_TYPE || property.code === ARRAY_TYPE)) {\r\n\t\t\t\t// the key was elided, but won't be followed by sequence, so write one now\r\n\t\t\t\twriters.writeToken(SEQUENCE_CODE, 0)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (isRoot && length > 0) {\r\n\t\t\twriters.writeToken(TYPE_CODE, TYPE_DEFINITION)\r\n\t\t}\r\n\t\tif (length > 0) {\r\n\t\t\t// we always use open sequence, because writing multiple values of a property use extra property counts,\r\n\t\t\t// plus it is easier to deal with properties without values\r\n\t\t\twriters.writeToken(SEQUENCE_CODE, OPEN_SEQUENCE)\r\n\t\t\tfor (var i = 0; i < length; i++) {\r\n\t\t\t\tvar childProperty = commonProperties[i]\r\n\t\t\t\tchildProperty.index = i\r\n\t\t\t\tif (isArray && i > 0) {\r\n\t\t\t\t\twriters.writeToken(PROPERTY_CODE, i)\r\n\t\t\t\t}\r\n\t\t\t\tserializeSharedProperty(childProperty, commonProperties.code === ARRAY_TYPE && i === 0, false, condition)\r\n\t\t\t}\r\n\t\t\twriters.writeToken(SEQUENCE_CODE, END_SEQUENCE)\r\n\t\t}\r\n\t\tvar first = true\r\n/*\t\tif (property.previousValues) {\r\n\t\t\tfor (let [value, count] of property.previousValues) {\r\n\t\t\t\tif (count >= usageThreshold * 2) {\r\n\t\t\t\t\tif (first)\r\n\t\t\t\t\t\tfirst = false\r\n\t\t\t\t\telse // reset property code for each subsequent value so we don't move on to the next property in parsing\r\n\t\t\t\t\t\twriters.writeToken(PROPERTY_CODE, property.index)\r\n\t\t\t\t\twriters.writeAsDefault(value)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else */\r\n\t\tif (property.lastIndex > 0) {\r\n\t\t\tfor (var i = 0, l = property.lastIndex; i < l; i++) {\r\n\t\t\t\tvar value = property.values[i]\r\n\t\t\t\tif (first)\r\n\t\t\t\t\tfirst = false\r\n\t\t\t\telse // reset property code for each subsequent value so we don't move on to the next property in parsing\r\n\t\t\t\t\twriters.writeToken(PROPERTY_CODE, property.index)\r\n\t\t\t\twriters.writeAsDefault(value)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t}\r\n\tlet serialized = serializer.getSerialized()\r\n\treturn serialized\r\n}\r\nfunction copyProperty(source, target, freezeTarget, startingIndex) {\r\n\tvar compatibility = 0\r\n\ttarget.code = source.code\r\n\ttarget.type = source.type || types[source.code]\r\n\tif (freezeTarget) {\r\n\t\ttarget.isFrozen = true\r\n\t\tif (target.previousValues)\r\n\t\t\ttarget.previousValues = null\r\n\t}\r\n\tlet sourceLength = source.resetTo > -1 ? source.resetTo : source.length\r\n\tif (target.resetTo > -1 && target.resetTo < target.length)\r\n\t\ttarget.length = target.resetTo\r\n\tfor (var i = startingIndex || 0; i < sourceLength; i++) {\r\n\t\tvar targetChild = target[i]\r\n\t\tvar childProperty = source[i]\r\n\t\tif (targetChild && (targetChild.key != childProperty.key || targetChild.extendedType != childProperty.extendedType ||\r\n\t\t\ttargetChild.code != childProperty.code &&\r\n\t\t\t\t!(targetChild.code == 8 && childProperty.code === 6 && (!targetChild.values || !targetChild.values.length)))) { // ok to upgrade from string to default\r\n\t\t\tif (target.isFrozen)\r\n\t\t\t\treturn 2\r\n\t\t\tcompatibility = 2\r\n\t\t}\r\n\t\tif (!targetChild) {\r\n\t\t\tif (target.isFrozen)\r\n\t\t\t\treturn 2\r\n\t\t\tvar targetChild = []\r\n\t\t\ttargetChild.code = childProperty.code\r\n\t\t\tif (target.newProperty) {\r\n\t\t\t\ttargetChild = target.newProperty(targetChild)\r\n\t\t\t}\r\n\t\t\ttarget[i] = targetChild\r\n\t\t\tif (childProperty.metadata)\r\n\t\t\t\ttargetChild.metadata = childProperty.metadata\r\n\t\t\tif (childProperty.insertedFrom) {\r\n\t\t\t\ttargetChild.insertedFrom = childProperty.insertedFrom\r\n\t\t\t\ttargetChild.insertedVersion = childProperty.insertedVersion\r\n\t\t\t}\r\n\t\t\ttargetChild.parent = target\r\n\t\t}\r\n\t\ttargetChild.key = childProperty.key\r\n\r\n// TODO: Check to make sure the values are compatible\r\n\t\tif (childProperty.values && childProperty.values.length > 0) {\r\n\t\t\tif (childProperty.values.resetTo > -1) {\r\n\t\t\t\tchildProperty.values.length = childProperty.values.resetTo\r\n\t\t\t}\r\n\t\t\tif (!targetChild.values || childProperty.values.length > (targetChild.values.resetTo > -1 ? targetChild.values.resetTo : targetChild.values.length)) {\r\n\t\t\t\ttargetChild.values = childProperty.values.slice(0)\r\n\t\t\t\ttargetChild.values.nextPosition = childProperty.values.length\r\n\t\t\t\tif (targetChild.values.length >= 12) {\r\n\t\t\t\t\ttargetChild.previousValues = null\r\n\t\t\t\t}\r\n\t\t\t\tif (compatibility == 0) {\r\n\t\t\t\t\tcompatibility = 1\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar childCompatibility = copyProperty(childProperty, targetChild, freezeTarget)\r\n\t\tif (childCompatibility > compatibility)\r\n\t\t\tcompatibility = childCompatibility\r\n\t}\r\n\tlet targetLength = target.resetTo > -1 ? target.resetTo : target.length\r\n\tif (targetLength > sourceLength) {\r\n\t\tif (target.recordUpdate) {\r\n\t\t\t// reverse freeze if the target has more values, we don't want the source becoming incompatible\r\n\t\t\tsource.metadata = UNSTRUCTURED_MARKER\r\n\t\t\tsource.recordUpdate()\r\n\t\t} else if (target.isFrozen) {\r\n\t\t\treturn 2\r\n\t\t}\r\n\t\t// merge back to the source if there are extra properties on the target\r\n\t\t//copyProperty(target, source, i)\r\n\t\t//source.recordUpdate()\r\n\t}\r\n\t/*if (target.previousValues) {\r\n\t\ttarget.values = target.previousValues\r\n\t\ttarget.previousValues = []\r\n\t}*/\r\n\t//target.length = source.length\r\n\treturn compatibility\r\n}\r\n\r\n// return values:\r\n// 0: identical property structures\r\n// -1: a has less properties, but can be safely upgraded to b and still be compatible with a\r\n// 1: a has more properties, but is compatible and can be used to decode b\r\n// -2: incompatible property structures, can not be used\r\nfunction isCompatibleProperty(a, b) {\r\n\tif (a.blockStructure === b) {\r\n\t\treturn a.version > b.version ? 1 : 0\r\n\t}\r\n\tif (a.code === b.code && a.extendedType === b.extendedType) {\r\n\t\tvar sharedLength = Math.min(a.length, b.length)\r\n\t\tvar compatibility = 0\r\n\t\tfor (var i = 0; i < sharedLength; i++) {\r\n\t\t\tif (a[i].key !== b[i].key)\r\n\t\t\t\treturn -2\r\n\t\t\tvar childCompatibility = isCompatibleProperty(a[i], b[i])\r\n\t\t\tif (childCompatibility === -2)\r\n\t\t\t\treturn -2\r\n\t\t\tif (childCompatibility === -1) {\r\n\t\t\t\tif (compatibility === 1)\r\n\t\t\t\t\treturn -2\r\n\t\t\t\tcompatibility = -1\r\n\t\t\t}\r\n\t\t\tif (childCompatibility === 1) {\r\n\t\t\t\tif (compatibility === -1)\r\n\t\t\t\t\treturn -2\r\n\t\t\t\tcompatibility = 1\r\n\t\t\t}\r\n\t\t}\r\n\t\tvar sharedValuesLength = Math.min(a.values ? a.values.length : 0, b.values ? b.values.length : 0)\r\n\t\tfor (var i = 0; i < sharedValuesLength; i++) {\r\n\t\t\tif (a.values[i] !== b.values[i]) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (a.length < b.length) {\r\n\t\t\tif (compatibility === 1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = -1\r\n\t\t} else if (a.length < b.length) {\r\n\t\t\tif (compatibility === -1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = 1\r\n\t\t}\r\n\t\t/*if (a.values.length < b.values.length) {\r\n\t\t\tif (compatibility === 1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = -1\r\n\t\t} else if (a.values.length < b.values.length) {\r\n\t\t\tif (compatibility === -1) {\r\n\t\t\t\treturn -2\r\n\t\t\t}\r\n\t\t\tcompatibility = 1\r\n\t\t}*/\r\n\t\treturn compatibility\r\n\t} else {\r\n\t\treturn -2\r\n\t}\r\n}\r\n\r\nfunction isolateString(string) {\r\n\t// this is a technique to forcefully recreate a string so it isn't a slice of a larger string. Because shared\r\n\t// structures are long-lived and created from instance structures that are short-lived, the long-lived small\r\n\t// sliced strings can end up pinning (otherwise short-lived) large strings in memory.\r\n\treturn string.slice(0, 1) + string.slice(1)\r\n}\r\n\r\n// order properties by their comesAfter list, to ensure each properties comes after everything in their comesAfter list\r\nfunction orderProperties(properties) {\r\n\tvar ordered = []\r\n\tvar traversed = new Set()\r\n\tfunction addProperty(property) {\r\n\t\tif (traversed.has(property)) // do this first in case of circular ordering\r\n\t\t\treturn\r\n\t\ttraversed.add(property)\r\n\t\tfor (var propertyBefore of property.comesAfter) {\r\n\t\t\taddProperty(propertyBefore)\r\n\t\t}\r\n\t\tordered.push(property)\r\n\t}\r\n\tfor (let property of properties) {\r\n\t\taddProperty(property)\r\n\t}\r\n\treturn ordered\r\n}"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2283, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2287, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/lib/Block.js"],"sourcesContent":["\"use strict\"\r\nconst BLOCK_TYPE = 5\r\nvar makeSymbol = typeof Symbol !== 'undefined' ? Symbol : function(name) {\r\n\treturn 'symbol-' + name\r\n}\r\n\r\n/*\r\nTwo types of blocks, frozen and copy-on-write\r\nFrozen - originating from JS objects\r\n\tObject.freeze() js objects and use symbol for serialized representation\r\nFrozen - originating from dpack, lazy evaluation\r\n\tProxy - get,has,etc. triggers parse, set throws\r\nCopy-on-write from JS objects\r\n\tProxy - get,has,etc. retrieves from source JS object, set copies\r\nCopy-on-write originating from dpack\r\n\tSame\r\n*/\r\n\r\nvar nextVersion = 1\r\nvar bufferSymbol = makeSymbol('buffer')\r\nvar sizeTableSymbol = makeSymbol('sizeTable')\r\nvar headerSymbol = makeSymbol('header')\r\nvar parsedSymbol = makeSymbol('parsed')\r\nvar sharedSymbol = makeSymbol('shared')\r\nvar targetSymbol = makeSymbol('target')\r\nconst freezeObjects = process.env.NODE_ENV != 'production'\r\n\r\nvar DEFAULT_TYPE = 6\r\nvar ARRAY_TYPE = 7\r\n\r\n/*\r\nsize table size types in first 2 bits:\r\n\r\nfirst byte\r\n0 - leaf mode, 6 bit length\r\n1 - leaf mode, 14 bit length\r\n2 - branch/leaf mode, 14, 16, 16 bit our-size length\r\n3 - branch/leaf mode, 30, 48, 48 bit our-size length\r\n*/\r\nfunction Block() {}\r\nvar serializeModule = require('./serialize')\r\n\r\nexports.Block = Block\r\nexports.bufferSymbol = serializeModule.bufferSymbol = bufferSymbol\r\nexports.parsedSymbol = parsedSymbol\r\nexports.sharedSymbol = sharedSymbol\r\nexports.targetSymbol = serializeModule.targetSymbol = targetSymbol\r\nexports.sizeTableSymbol = serializeModule.sizeTableSymbol = sizeTableSymbol\r\nvar serialize = serializeModule.serialize\r\nvar createSerializer = serializeModule.createSerializer\r\nexports.asBlock = asBlock\r\nfunction asBlock(object, shared) {\r\n\tif (object && object[targetSymbol]) {\r\n\t\treturn object // already a block\r\n\t}\r\n\tif (Array.isArray(object)) {\r\n\t\t// if the object is an array, make the taget an array so it passes Array.isArray checks\r\n\t\tlet target = []\r\n\t\ttarget.parsed = object\r\n\t\ttarget.shared = shared\r\n\t\treturn new Proxy(target, onDemandHandler)\r\n\t}\r\n\treturn new Proxy({\r\n\t\tparsed: object,\r\n\t\tshared: shared\r\n\t}, onDemandHandler)\r\n}\r\nexports.isBlock = isBlock\r\nfunction isBlock(object) {\r\n\treturn object && object[targetSymbol]\r\n}\r\n\r\nexports.makeBlockFromBuffer = makeBlockFromBuffer\r\nfunction makeBlockFromBuffer(buffer, shared) {\r\n\tvar dpackBuffer, sizeTableBuffer\r\n\tif (buffer[0] < 0x80) {\r\n\t\tdpackBuffer = buffer\r\n\t} else { // a branch type will always be greater than 0x80\r\n\t\tvar type = buffer[0] >> 6\r\n\t\tvar dpackOffset\r\n\t\tif (type === 2) {\r\n\t\t\tdpackOffset = buffer.readUInt16BE(0) & 0x3fff\r\n\t\t} else {\r\n\t\t\tdpackOffset = buffer.readUInt32BE(0) & 0x3fffffff\r\n\t\t}\r\n\t\tdpackBuffer = buffer.slice(dpackOffset)\r\n\t\tsizeTableBuffer = buffer.slice(0, dpackOffset)\r\n\t}\r\n\r\n\tvar target = {\r\n\t\tdpackBuffer: dpackBuffer,\r\n\t\tsizeTableBuffer: sizeTableBuffer,\r\n\t\tshared: shared,\r\n\t\treassign: function(buffer) { // TODO: don't create each time\r\n\t\t\tthis.buffer = buffer\r\n\t\t}\r\n\t}\r\n\tbuffer.owner = target\r\n\treturn new Proxy(target, onDemandHandler)\r\n}\r\n\r\nexports.getLazyHeader = function(block) {\r\n\treturn block[sizeTableSymbol]\r\n}\r\n\r\nvar onDemandHandler = {\r\n\tget: function(target, key) {\r\n\t\tif (specialGetters.hasOwnProperty(key)) {\r\n\t\t\treturn specialGetters[key].call(target)\r\n\t\t}\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\treturn parsed[key]\r\n\t},\r\n\tset: function(target, key, value) {\r\n\t\t// we allow symbols to set as a form of metadata objects even though the main string keyed properties are frozen\r\n\t\tif (typeof key === 'symbol') {\r\n\t\t\ttarget[key] = value\r\n\t\t\tmakeSymbolGetter(key)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tthrow new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify')\r\n\t},\r\n\tdeleteProperty: function() {\r\n\t\tthrow new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify')\r\n\t},\r\n\tgetOwnPropertyDescriptor: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getOwnPropertyDescriptor(parsed, key)\r\n\t},\r\n\thas: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn key in parsed\r\n\t},\r\n\townKeys: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\tvar keys = Object.keys(parsed)\r\n\t\tif (Array.isArray(parsed)) {\r\n\t\t\tkeys.push('length')\r\n\t\t}\r\n\t\treturn keys\r\n\t},\r\n\tgetPrototypeOf: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getPrototypeOf(parsed)\r\n\t}\r\n}\r\n\r\nexports.reassignBuffers = reassignBuffers\r\nfunction reassignBuffers(block, newParentNodeBuffer, parentArrayBuffer) {\r\n\t\t// if a buffer needs to be moved to a new buffer due to it soon being no longer referenceable, we can reference the new copy\r\n\t\tvar target = block[targetSymbol]\r\n\t\tvar buffer = target.dpackBuffer\r\n\t\tif (!parentArrayBuffer)\r\n\t\t\tparentArrayBuffer = buffer.buffer\r\n\t\tif (buffer && buffer.buffer === parentArrayBuffer) {\r\n\t\t\tvar byteOffset = buffer.byteOffset\r\n\t\t\ttarget.dpackBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length)\r\n\t\t}\r\n\t\tvar buffer = target.sizeTableBuffer\r\n\t\tif (buffer && buffer.buffer === parentArrayBuffer) {\r\n\t\t\tvar byteOffset = buffer.byteOffset\r\n\t\t\ttarget.sizeTableBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length)\r\n\t\t}\r\n\t\tif (target.parsed) {\r\n\t\t\tvar parsed = target.parsed\r\n\t\t\tfor (var key in parsed) {\r\n\t\t\t\tvar value = parsed[key]\r\n\t\t\t\tif (isBlock(value)) {\r\n\t\t\t\t\treassignBuffers(value, newParentNodeBuffer, parentArrayBuffer)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\nvar copyOnWriteHandler = {\r\n\tget: function(target, key) {\r\n\t\tif (specialGetters.hasOwnProperty(key)) {\r\n\t\t\treturn specialGetters[key].call(target)\r\n\t\t}\r\n\t\tvar cachedParsed = target.cachedParsed\r\n\t\tif (cachedParsed && cachedParsed.hasOwnProperty(key) && !(key == 'length' && Array.isArray(cachedParsed))) {\r\n\t\t\treturn cachedParsed[key]\r\n\t\t}\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\tvar value = parsed[key]\r\n\t\t/*if (value && typeof value == 'object') {\r\n\t\t\tif (!cachedParsed) {\r\n\t\t\t\ttarget.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {}\r\n\t\t\t}\r\n\t\t\tif (value instanceof Map)\r\n\t\t\t\tcachedParsed[key] = value\r\n\t\t\telse\r\n\t\t\t\tcachedParsed[key] = value = copyWithParent(value, target)\r\n\t\t}*/\r\n\t\tif (value && value[targetSymbol]) {\r\n\t\t\tif (!cachedParsed) {\r\n\t\t\t\ttarget.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {}\r\n\t\t\t}\r\n\t\t\tcachedParsed[key] = value = copyWithParent(value, target)\r\n\t\t}\r\n\t\treturn value\r\n\t},\r\n\tchanged: function(target) {\r\n\t\ttarget.dpackBuffer = null\r\n\t\ttarget.sizeTableBuffer = null\r\n\t\ttarget.shared = null\r\n\t\tvar parsed = target.parsed\r\n\t\tif (!parsed) {\r\n\t\t\tparsed = getParsed(target)\r\n\t\t}\r\n\t\tif (!target.copied) {\r\n\t\t\tvar cachedParsed = target.cachedParsed\r\n\t\t\tvar copied = target.parsed = target.cachedParsed = parsed instanceof Array ? [] : {}\r\n\t\t\tfor (var key in parsed) {\r\n\t\t\t\tvar value = cachedParsed && cachedParsed[key]\r\n\t\t\t\tif (!value) {\r\n\t\t\t\t\tvalue = parsed[key]\r\n\t\t\t\t\tif (value && value[targetSymbol]) {\r\n\t\t\t\t\t\tvalue = copyWithParent(value, target)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tcopied[key] = value\r\n\t\t\t}\r\n\t\t\tparsed = copied\r\n\t\t\ttarget.copied = true\r\n\t\t}\r\n\t\ttarget.version = nextVersion++\r\n\t\treturn parsed\r\n\t},\r\n\tcheckVersion: function(target) {\r\n\t\tvar cachedParsed = target.cachedParsed\r\n\t\tlet version = target.version || 0\r\n\t\tif (cachedParsed) {\r\n\t\t\tfor (let key in cachedParsed) {\r\n\t\t\t\tvar value = cachedParsed[key]\r\n\t\t\t\tif (value && value[targetSymbol]) {\r\n\t\t\t\t\tversion = Math.max(version, this.checkVersion(value[targetSymbol]))\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (version != (target.version || 0)) {\r\n\t\t\tthis.changed(target)\r\n\t\t\ttarget.version = version\r\n\t\t}\r\n\t\treturn version\r\n\t},\r\n\tset: function(target, key, value, proxy) {\r\n\t\tif (specialSetters.hasOwnProperty(key)) {\r\n\t\t\tspecialSetters[key].call(target, value)\r\n\t\t\treturn true\r\n\t\t}\r\n\t\tvar parsed = copyOnWriteHandler.changed(target)\r\n\t\tparsed[key] = value\r\n\t\treturn true\r\n\t},\r\n\tdeleteProperty: function(target, key) {\r\n\t\tvar parsed = copyOnWriteHandler.changed(target)\r\n\t\treturn delete parsed[key]\r\n\t},\r\n\tgetOwnPropertyDescriptor: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getOwnPropertyDescriptor(parsed, key)\r\n\t},\r\n\thas: function(target, key) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn key in parsed\r\n\t},\r\n\townKeys: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\tvar keys = Object.keys(parsed)\r\n\t\tif (Array.isArray(parsed)) {\r\n\t\t\tkeys.push('length')\r\n\t\t}\r\n\t\tif (target.copied) {\r\n\t\t\tfor (var key in target.copied) {\r\n\t\t\t\tif (keys.indexOf(key) === -1) {\r\n\t\t\t\t\tkeys.push(key)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn keys\r\n\t},\r\n\tgetPrototypeOf: function(target) {\r\n\t\tvar parsed = getParsed(target)\r\n\t\treturn Object.getPrototypeOf(parsed)\r\n\t}\r\n}\r\n\r\nvar specialGetters = {\r\n}\r\nspecialGetters[bufferSymbol] = function() {\r\n\treturn function(property, randomAccess) {\r\n\t\tvar propertyIsShared = property && property.upgrade\r\n\t\tvar buffer\r\n\r\n\t\tif (this.cachedParsed && this.dpackBuffer) {\r\n\t\t\tcopyOnWriteHandler.checkVersion(this)\r\n\t\t}\r\n\t\tif (!(this.shared && this.shared.upgrade) && propertyIsShared) {\r\n\t\t\tif (this.dpackBuffer) {\r\n\t\t\t\t// if the block has been serialized without a shared structure, and it will be used in a shared structure,\r\n\t\t\t\t// we put it in a separate property\r\n\t\t\t\tthis.sizeTableBuffer = null\r\n\t\t\t\treturn inSeparateProperty(this.dpackBuffer, true)\r\n\t\t\t} else {\r\n\t\t\t\treturn getSerialized(this, this.shared = property)\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (!this.dpackBuffer) {\r\n\t\t\tgetSerialized(this, this.shared)\r\n\t\t}\r\n\t\tif (this.shared && this.shared.upgrade && this.shared !== property) {\r\n\t\t\tvar compatibility = this.shared.upgrade(property, randomAccess)\r\n\t\t\tif (compatibility > 0) {\r\n\t\t\t\t// if the property upgrade was incompatible, we have to included the shared structure, and force sequential reading\r\n\t\t\t\tthis.sizeTableBuffer = null\r\n\t\t\t\tvar sharedBuffer = this.shared.serialized\r\n\t\t\t\tif (sharedBuffer.length > 0) {\r\n\t\t\t\t\tif (compatibility == 2 && !(property.isFrozen && property.resetTo === 0))\r\n\t\t\t\t\t\tsharedBuffer = inSeparateProperty(sharedBuffer)\r\n\t\t\t\t\tbuffer = Buffer.concat([sharedBuffer, this.dpackBuffer])\r\n\t\t\t\t\tbuffer.mustSequence = true\r\n\t\t\t\t\treturn buffer\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} else if (property) {\r\n\t\t\tif (!propertyIsShared) {\r\n\t\t\t\t// need to reset this property, if it is a plain sequential property\r\n\t\t\t\tproperty.length = 0\r\n\t\t\t}\r\n\t\t\tif (property.insertedFrom)\r\n\t\t\t\tproperty.insertedFrom = null\r\n\t\t}\r\n\t\treturn this.dpackBuffer\r\n\r\n\t\tfunction inSeparateProperty(dpackBuffer) {\r\n\t\t\tvar serializer = createSerializer()\r\n\t\t\tvar isArray = dpackBuffer[0] === 119\r\n\t\t\tvar writeToken = serializer.getWriters().writeToken\r\n\t\t\tif (isArray) {\r\n\t\t\t\tdpackBuffer = dpackBuffer.slice(1) // replacing the property declaration\r\n\t\t\t}\r\n\t\t\twriteToken(0, 1000)// use a hopefully unused slot (should be unused, block always has a single initial starting slot)\r\n\t\t\twriteToken(3, isArray ? ARRAY_TYPE : DEFAULT_TYPE) // property type\r\n\t\t\tif (property && property.key !== null)\r\n\t\t\t\tserializer.serialize(property.key)\r\n\t\t\tdpackBuffer = Buffer.concat([serializer.getSerialized(), dpackBuffer])\r\n\t\t\tdpackBuffer.mustSequence = true\r\n\t\t\treturn dpackBuffer\r\n\t\t}\r\n\r\n\t}.bind(this)\r\n}\r\nspecialGetters[targetSymbol] = function() {\r\n\treturn this\r\n}\r\nspecialGetters[sharedSymbol] = function() {\r\n\treturn this.shared\r\n}\r\nspecialGetters[parsedSymbol] = function() {\r\n\treturn this.parsed || getParsed(this)\r\n}\r\nspecialGetters[sizeTableSymbol] = function() {\r\n\tif (!this.dpackBuffer) {\r\n\t\tgetSerialized(this)\r\n\t}\r\n\treturn this.sizeTableBuffer\r\n}\r\nspecialGetters.then = function() {\r\n\t// return undefined, this is not a promise\r\n}\r\nspecialGetters.toJSON = function() {\r\n\treturn valueOf\r\n}\r\n\r\nspecialGetters.valueOf = function() {\r\n\treturn valueOf\r\n}\r\nspecialGetters.entries = function() {\r\n\treturn entries\r\n}\r\nfunction entries() {\r\n\treturn this[parsedSymbol].entries()\r\n}\r\nspecialGetters[Symbol.iterator] = function() {\r\n\tvar parsed = this.parsed || getParsed(this)\r\n\treturn parsed && parsed[Symbol.iterator] && iterator\r\n}\r\nfunction iterator() {\r\n\tvar parsed = this[parsedSymbol]\r\n\treturn parsed && parsed[Symbol.iterator] ? parsed[Symbol.iterator]() : [][Symbol.iterator]()\r\n}\r\nspecialGetters.constructor = function() {\r\n\tif (this.parsed) {\r\n\t\treturn this.parsed.constructor\r\n\t}\r\n\t// this is a fast path for getting the constructor without having to parse. this is important\r\n\t// as it enables blocks to be go through the serializer, have it check the constructor, without\r\n\t// requiring parsing, and then they can be directly written from their binary buffer\r\n\tif (this.dpackBuffer) {\r\n\t\tlet firstByte = this.dpackBuffer[0]\r\n\t\tif (firstByte >= 48 && firstByte <= 60) {\r\n\t\t\t// sequence\r\n\t\t\tif (this.shared) {\r\n\t\t\t\tif (this.shared.code == DEFAULT_TYPE) {\r\n\t\t\t\t\treturn Object\r\n\t\t\t\t} else if (this.shared.code == ARRAY_TYPE) {\r\n\t\t\t\t\treturn Array\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\treturn Object\r\n\t\t\t}\r\n\t\t} else if (firstByte === 119) {\r\n\t\t\treturn Array\r\n\t\t}\r\n\t}\r\n\treturn getParsed(this).constructor\r\n}\r\n\r\n\r\nfunction makeSymbolGetter(symbol) {\r\n\tif (!specialGetters[symbol])\r\n\t\tspecialGetters[symbol] = function() {\r\n\t\t\treturn this[symbol]\r\n\t\t}\r\n}\r\nfunction valueOf() {\r\n\treturn this[parsedSymbol]\r\n}\r\nfunction copy(source) {\r\n\treturn copyWithParent(source)\r\n}\r\nfunction copyWithParent(source, parent) {\r\n\tif (!isBlock(source)) {\r\n\t\t/*if (source && typeof source == 'object')\r\n\t\t\tsource = asBlock(source)\r\n\t\telse*/\r\n\t\t\treturn source\r\n\t}\r\n\tlet isArray = Array.isArray(source)\r\n\tlet target = isArray ? [] : {}\r\n\tObject.defineProperties(target, {\r\n\t\tparsed: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[parsedSymbol]\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'parsed', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t},\r\n\t\tshared: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[sharedSymbol]\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'shared', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t\tthis.dpackBuffer = null\r\n\t\t\t\tthis.sizeTableBuffer = null\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t},\r\n\t\tdpackBuffer: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[targetSymbol].dpackBuffer\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'dpackBuffer', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t},\r\n\t\tsizeTableBuffer: {\r\n\t\t\tget() {\r\n\t\t\t\treturn source[sizeTableSymbol]\r\n\t\t\t},\r\n\t\t\tset(value) {\r\n\t\t\t\tObject.defineProperty(this, 'sizeTableBuffer', {\r\n\t\t\t\t\tvalue: value,\r\n\t\t\t\t\twritable: true,\r\n\t\t\t\t\tenumerable: true\r\n\t\t\t\t})\r\n\t\t\t},\r\n\t\t\tconfigurable: true,\r\n\t\t}\r\n\t})\r\n\tif (isArray) {\r\n\t\tObject.define\r\n\t}\r\n\treturn new Proxy(target, copyOnWriteHandler)\r\n}\r\nexports.copy = copy\r\n\r\nvar specialSetters = {\r\n}\r\n/*specialSetters[sharedSymbol] = function(shared) {\r\n\treturn this.shared = shared\r\n}*/\r\n\r\nfunction getParsed(target) {\r\n\tvar parsed = target.parsed\r\n\tif (parsed)\r\n\t\treturn parsed\r\n\t// we check to see if there are multiple blocks that should be deferred into separate blocks\r\n\tvar sizeTableBuffer = target.sizeTableBuffer\r\n\tvar dpackBuffer = target.dpackBuffer\r\n\tif (!sizeTableBuffer) {\r\n\t\t// no child blocks, just dpack, so directly parse\r\n\t\treturn target.parsed = parse(dpackBuffer, {\r\n\t\t\tfreezeObjects: freezeObjects,\r\n\t\t\tshared: target.shared\r\n\t\t})\r\n\t}\r\n\tvar totalSizeTableLength = sizeTableBuffer.length\r\n\tvar totalDPackLength\r\n\tvar rootBlockLength\r\n\tvar type = sizeTableBuffer[0] >> 6\r\n\tvar offset\r\n\tif (type === 2) {\r\n\t\trootBlockLength = sizeTableBuffer.readUInt16BE(4)\r\n\t\toffset = 6\r\n\t} else {\r\n\t\trootBlockLength = sizeTableBuffer.readUIntBE(10, 6)\r\n\t\toffset = 16\r\n\t}\r\n\t// read child block lengths: (could defer this until child access)\r\n\tvar childSizeTables = []\r\n\tvar childDpackBlocks = []\r\n\tvar dpackChildOffset = rootBlockLength\r\n\twhile (offset < totalSizeTableLength) {\r\n\t\tvar type = sizeTableBuffer[offset] >> 6\r\n\t\tvar sizeTableLength\r\n\t\tvar dpackLength\r\n\t\tif (type < 2) { // leaf node\r\n\t\t\tif (type == 0) {\r\n\t\t\t\t// 6 bit\r\n\t\t\t\tsizeTableLength = 1\r\n\t\t\t\tdpackLength = sizeTableBuffer[offset]\r\n\t\t\t} else {\r\n\t\t\t\t// 14 bit\r\n\t\t\t\tsizeTableLength = 2\r\n\t\t\t\tdpackLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff\r\n\t\t\t}\r\n\t\t} else if (type === 2) {\r\n\t\t\tsizeTableLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff\r\n\t\t\tdpackLength = sizeTableBuffer.readUInt16BE(offset + 2)\r\n\t\t} else {\r\n\t\t\tsizeTableLength = sizeTableBuffer.readUInt32BE(offset) & 0x3fffffff\r\n\t\t\tdpackLength = sizeTableBuffer.readUIntBE(offset + 4, 6)\r\n\t\t}\r\n\t\tchildSizeTables.push(type < 2 ||\r\n\t\t\t(type == 3 && sizeTableLength == 16) ? // type 3 with a length of 16 is a long leaf node\r\n\t\t\tundefined : sizeTableBuffer.slice(offset, offset + sizeTableLength))\r\n\t\toffset += sizeTableLength\r\n\t\tchildDpackBlocks.push(dpackBuffer.slice(dpackChildOffset, dpackChildOffset += dpackLength))\r\n\t}\r\n\tvar blockIndex = 0\r\n\tvar rootBlock = target.dpackBuffer.slice(0, rootBlockLength)\r\n\treturn target.parsed = parse(rootBlock, childDpackBlocks.length > 0 ? { // if no child blocks, use normal deferred parsing\r\n\t\tshared: target.shared,\r\n\t\tforDeferred: function(value, property) {\r\n\t\t\tlet target = new value.constructor\r\n\t\t\ttarget.dpackBuffer = childDpackBlocks[blockIndex]\r\n\t\t\ttarget.sizeTableBuffer = childSizeTables[blockIndex++]\r\n\t\t\ttarget.shared = property ?\r\n\t\t\t\t\tproperty.upgrade ?\r\n\t\t\t\t\t\tproperty :\r\n\t\t\t\t\t\t{ code: property.code, key: null, type: property.type } :\r\n\t\t\t\t\tnull\r\n\t\t\treturn new Proxy(target, onDemandHandler)\r\n\t\t},\r\n\t\tfreezeObjects: freezeObjects\r\n\t} : {\r\n\t\tshared: target.shared\r\n\t})\r\n}\r\n\r\nfunction getSerialized(target, shareProperty) {\r\n\tvar childBlocks = []\r\n\tvar childSizeTables = []\r\n\tvar childDpackSizes = 0\r\n\tvar mustSequence // mustSequence is an indication that the blocks must be read in sequence and can't be randomly accessed\r\n\tvar serializerOptions = {\r\n\t\tforBlock: function(block, property) {\r\n\t\t\tvar dpackBuffer = block[bufferSymbol](property, true)\r\n\t\t\tif (dpackBuffer.mustSequence) {\r\n\t\t\t\tmustSequence = true\r\n\t\t\t\tchildBlocks.push(dpackBuffer)\r\n\t\t\t\treturn dpackBuffer\r\n\t\t\t}\r\n\t\t\tvar sizeTableBuffer = block[sizeTableSymbol]\r\n\t\t\tif (!sizeTableBuffer) {\r\n\t\t\t\t// if this child has no children, it won't have have size table, just create a leaf branch buffer\r\n\t\t\t\tvar bufferLength = dpackBuffer.length\r\n\t\t\t\tif (bufferLength < 64) {\r\n\t\t\t\t\t// one byte leaf node\r\n\t\t\t\t\tsizeTableBuffer = Buffer.from([bufferLength])\r\n\t\t\t\t} else if (bufferLength < 0x4000) {\r\n\t\t\t\t\t// binary-10 and then 14 bits\r\n\t\t\t\t\tsizeTableBuffer = Buffer.from([(bufferLength >> 8) | 0x40, bufferLength & 0xff])\r\n\t\t\t\t} else {\r\n\t\t\t\t\tsizeTableBuffer = Buffer.allocUnsafe(16)\r\n\t\t\t\t\tsizeTableBuffer.writeUInt32BE(0xc0000010) // binary-11 and then indicate a size of 16\r\n\t\t\t\t\tsizeTableBuffer.writeUIntBE(bufferLength, 4, 6)\r\n\t\t\t\t\tsizeTableBuffer.writeUIntBE(bufferLength, 10, 6)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tchildSizeTables.push(sizeTableBuffer)\r\n\t\t\tchildDpackSizes += dpackBuffer.length\r\n\t\t\tchildBlocks.push(dpackBuffer)\r\n\t\t\treturn dpackBuffer\r\n\t\t},\r\n\t\tshared: shareProperty,\r\n\t\tfreezeObjects: freezeObjects\r\n\t}\r\n\tvar rootBlock = serialize(target.parsed, serializerOptions)\r\n\tif (childBlocks.length == 0) {\r\n\t\t// no child blocks, just use the root block\r\n\t\treturn target.dpackBuffer = rootBlock\r\n\t}\r\n\tchildBlocks.unshift(rootBlock)\r\n\t// TODO: Do word aligment with any buffer copying, to make sure CPU can copy words instead of bytes\r\n\tvar dpackBuffer = target.dpackBuffer = Buffer.concat(childBlocks)\r\n\tif (mustSequence) {\r\n\t\treturn dpackBuffer\r\n\t}\r\n\tvar ourSizeBlock = Buffer.allocUnsafe(dpackBuffer.length >= 0x10000 ? 16 : 6)\r\n\tchildSizeTables.unshift(ourSizeBlock)\r\n\t// TODO: Add length parameter to concat so it is length % 8 = 0\r\n\tourSizeBlock = target.sizeTableBuffer = Buffer.concat(childSizeTables)\r\n\tif (dpackBuffer.length >= 0x10000) { // || ourSizeBlock.length > 0x4000\r\n\t\tourSizeBlock.writeUInt32BE(ourSizeBlock.length + 0xc0000000, 0) // binary-11 and then 30 bits\r\n\t\tourSizeBlock.writeUIntBE(dpackBuffer.length, 4, 6) // 48 bits\r\n\t\tourSizeBlock.writeUIntBE(rootBlock.length, 10, 6) // 48 bits\r\n\t} else {\r\n\t\tourSizeBlock.writeUInt16BE(ourSizeBlock.length | 0x8000, 0) // binary-10 and then 14 bits\r\n\t\tourSizeBlock.writeUInt16BE(dpackBuffer.length, 2) // 16 bits\r\n\t\tourSizeBlock.writeUInt16BE(rootBlock.length, 4) // 16 bits\r\n\r\n\t}\r\n\treturn dpackBuffer\r\n}\r\n\r\nfunction deepCopy(source) {\r\n\tlet target = new source.constructor()\r\n\tfor (let key in source) {\r\n\t\tlet value = source[key]\r\n\t\tif (value && typeof value == 'object')\r\n\t\t\tvalue = deepCopy(value)\r\n\t\ttarget[key] = value\r\n\t}\r\n\treturn target\r\n}\r\nvar parse = require('./parse').parse\r\nvar serializeSharedBlock = require('./shared').serializeSharedBlock\r\n\r\nexports.parseLazy = function(buffer, options) {\r\n\tif ((buffer[0] & 0x80) || // starts with size table\r\n\t\t(buffer[0] >> 4 === 3) || // sequence (object)\r\n\t\t(buffer[0] === 0x77)) { // array type\r\n\t\treturn makeBlockFromBuffer(buffer, options && options.shared)\r\n\t} else {\r\n\t\treturn parse(buffer, options)\r\n\t}\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2950, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2954, "column": 0}, "map": {"version":3,"sources":["/turbopack/[project]/node_modules/dpack/index.js"],"sourcesContent":["/*\r\nDPack - Fast, compact object structure encoding.\r\n*/\r\n\r\nexports.createSerializeStream = require('./lib/serialize-stream').createSerializeStream\r\nexports.createParseStream = require('./lib/parse-stream').createParseStream\r\nconst serialize = require('./lib/serialize')\r\nserialize.nodeCharEncoder = require('./lib/node-encoder').nodeCharEncoder\r\nconst parse = require('./lib/parse')\r\nconst Options = require('./lib/Options').Options\r\n\r\nexports.serialize = serialize.serialize\r\nexports.parse = parse.parse\r\nexports.createSerializer = serialize.createSerializer\r\nexports.createParser = parse.createParser\r\nconst Block = require('./lib/Block')\r\nexports.parseLazy = Block.parseLazy\r\nexports.asBlock = Block.asBlock\r\nexports.isBlock = Block.isBlock\r\nexports.copy = Block.copy\r\nexports.reassignBuffers = Block.reassignBuffers\r\nexports.Options = Options\r\nexports.createSharedStructure = require('./lib/shared').createSharedStructure\r\nexports.readSharedStructure = require('./lib/shared').readSharedStructure\r\n"],"names":[],"mappings":"AAAA;;AAEA,GAEA,QAAQ,qBAAqB,GAAG,uGAAkC,qBAAqB;AACvF,QAAQ,iBAAiB,GAAG,mGAA8B,iBAAiB;AAC3E,MAAM;AACN,UAAU,eAAe,GAAG,mGAA8B,eAAe;AACzE,MAAM;AACN,MAAM,UAAU,8FAAyB,OAAO;AAEhD,QAAQ,SAAS,GAAG,UAAU,SAAS;AACvC,QAAQ,KAAK,GAAG,MAAM,KAAK;AAC3B,QAAQ,gBAAgB,GAAG,UAAU,gBAAgB;AACrD,QAAQ,YAAY,GAAG,MAAM,YAAY;AACzC,MAAM;AACN,QAAQ,SAAS,GAAG,MAAM,SAAS;AACnC,QAAQ,OAAO,GAAG,MAAM,OAAO;AAC/B,QAAQ,OAAO,GAAG,MAAM,OAAO;AAC/B,QAAQ,IAAI,GAAG,MAAM,IAAI;AACzB,QAAQ,eAAe,GAAG,MAAM,eAAe;AAC/C,QAAQ,OAAO,GAAG;AAClB,QAAQ,qBAAqB,GAAG,6FAAwB,qBAAqB;AAC7E,QAAQ,mBAAmB,GAAG,6FAAwB,mBAAmB"}},
    {"offset": {"line": 2975, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}