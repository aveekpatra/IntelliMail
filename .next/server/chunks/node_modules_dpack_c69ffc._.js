module.exports = {

"[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

"use strict";
// these are the codes that are used to determine the rudimentary type of numbers
var PROPERTY_CODE = 0;
var TYPE_CODE = 3;
var STRING_CODE = 2;
var NUMBER_CODE = 1;
var SEQUENCE_CODE = 7;
// constant codes
var NULL = 0 // p
;
var FALSE = 3 // s
;
var TRUE = 4 // t
;
var UNDEFINED = 5 // u
;
// these are the starting codes (structures also use this space) for complete types
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
var REFERENCING_TYPE = 8;
var NUMBER_TYPE = 9;
var EXTENSIONS = 10;
var METADATA_TYPE = 11;
var COPY_PROPERTY = 12 // for defining a typed object without returning the value
;
var REFERENCING_POSITION = 13;
var TYPE_DEFINITION = 14 // for defining a typed object without returning the value
;
var ERROR_METADATA = 500;
// sequence codes
var OPEN_SEQUENCE = 12 // <
;
var PARTIAL_DEFERRED_REFERENCE = 12 // <
;
var END_SEQUENCE = 14 // >
;
var DEFERRED_REFERENCE = 15 // ?
;
var nextId = 1;
var iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '__iterator_symbol__';
function createSerializer(options) {
    if (!options) options = {};
    var extendedTypes = options.converterByConstructor;
    if (!extendedTypes) {
        extendedTypes = new Map();
    }
    extendedTypes.set(Map, {
        name: 'Map',
        toValue: writeMap
    });
    extendedTypes.set(Set, {
        name: 'Set',
        toValue: writeSet
    });
    extendedTypes.set(Date, {
        name: 'Date',
        toValue: writeDate
    });
    var avoidShareUpdate = options.outlet || options.avoidShareUpdate;
    var charEncoder = typeof global != 'undefined' && global.Buffer && !(options && options.encoding === 'utf16le') ? exports.nodeCharEncoder(options) : browserCharEncoder(options);
    var writeString = charEncoder.writeString;
    var writeToken = charEncoder.writeToken;
    var startSequence = charEncoder.startSequence;
    var endSequence = charEncoder.endSequence;
    var writeBuffer = charEncoder.writeBuffer;
    var forProperty = options.forProperty;
    var propertyUsed;
    var valueUsed;
    if (options.shared) {
        propertyUsed = options.shared.propertyUsed;
        valueUsed = options.shared.propertyUsed;
    }
    var pendingEncodings = [];
    var nextPropertyIndex = 8;
    var property;
    var bufferSymbol = exports.bufferSymbol || '_bufferSymbol_';
    var targetSymbol = exports.targetSymbol || '_targetSymbol_';
    var propertyComparisons = 0;
    var serializerId = nextId++;
    var writers = [
        0,
        1,
        2,
        3,
        4,
        5,
        writeAsDefault,
        writeAsArray,
        writeAsReferencing,
        writeAsNumber,
        writeOnlyNull
    ];
    // write a rudimentary number
    function writeNumber(number) {
        writeToken(NUMBER_CODE, number);
    }
    // write a rudimentary string
    function writeInlineString(string) {
        writeToken(STRING_CODE, string.length);
        writeString(string);
    }
    // writing any value in referencing serialization type mode
    function writeAsReferencing(value) {
        var type, values = property.values;
        if (values) {
            if (values.resetTo > -1 && values.serializer !== serializerId) {
                // if this is a shared values, need to reset on each serialization
                values.serializer = serializerId;
                if (values.resetTo < values.length) values.length = values.resetTo;
                writeToken(TYPE_CODE, REFERENCING_POSITION);
                writeToken(NUMBER_CODE, values.resetTo);
            }
            var reference = values.indexOf(value);
            if (reference > -1) {
                return writeNumber(reference);
            }
        }
        if ((type = typeof value) === 'string' || type === 'object' && value) {
            if (property.writeSharedValue) {
                if (property.writeSharedValue(value, writeToken, serializerId)) return;
            } else if (values) {
                var index = values.length;
                if (index < 12) values[index] = value;
            }
        }
        if (type === 'string') {
            writeInlineString(value);
        } else {
            writeAsDefault(value);
        }
    }
    // writing any value in number serialization type mode
    function writeAsNumber(number) {
        var type = typeof number;
        if (type === 'number') {
            if (number >>> 0 === number || number > 0 && number < 0x400000000000 && number % 1 === 0) {
                // 46 bit unsigned integer
                writeToken(NUMBER_CODE, number);
            } else {
                // decimal number serialized as a string
                var asString = number.toString();
                writeInlineString(asString);
            }
        } else if (type === 'object') {
            writeAsDefault(number);
        } else {
            writeTypedValue(number);
        }
    }
    function writeTypedValue(value) {
        if (value === null) writeToken(TYPE_CODE, NULL);
        else if (value === false) writeToken(TYPE_CODE, FALSE);
        else if (value === true) writeToken(TYPE_CODE, TRUE);
        else if (value === undefined) writeToken(TYPE_CODE, UNDEFINED);
        else {
            writeTypedNonConstant(value);
        }
    }
    function writeTypedNonConstant(value) {
        var type = typeof value;
        var extendedType;
        if (type === 'object') {
            if (value) {
                var constructor = value.constructor;
                if (constructor === Object) {
                // leave type as is
                } else if (constructor === Array) {
                    type = 'array';
                } else {
                    extendedType = extendedTypes.get(constructor);
                    if (extendedType && extendedType.toValue) {
                        value = extendedType.toValue(value);
                        type = typeof value // go through the same logic adjustment here
                        ;
                        if (value && type === 'object' && value.constructor === Array) {
                            type = 'array';
                        }
                        if (property.type === type) {
                            // if we are the right type after doing the conversion, go back to the original property to serialize
                            if (property.extendedType !== extendedType) {
                                property.extendedType = extendedType;
                                writeToken(TYPE_CODE, METADATA_TYPE);
                                writeInlineString(extendedType.name);
                            }
                            return writers[property.code](value);
                        }
                    } else {
                        extendedType = false;
                    }
                }
            } else {
                type = 'undefined' // treat null as same type as undefined, both constants
                ;
            }
        } else if (type === 'boolean') {
            type = 'undefined';
        } else if (type === 'function') {
            value = value.toString();
            type = 'string';
        }
        property = writeProperty(null, type, extendedType);
        writers[property.code](value);
    }
    function writeOnlyNull() {
        writeToken(TYPE_CODE, NULL);
    }
    // writing any value in default serialization type mode
    function writeAsDefault(value, isRoot) {
        var type = typeof value;
        if (type === 'object') {
            if (!value) {
                return writeToken(TYPE_CODE, NULL);
            }
        // else continue with the object code
        } else if (type === 'string') {
            return writeInlineString(value);
        } else if (type === 'number' && (value >>> 0 === value || value > 0 && value < 0x400000000000 && value % 1 === 0)) {
            // 46 bit unsigned integer
            return writeToken(NUMBER_CODE, value);
        } else {
            return writeTypedValue(value);
        }
        var object = value;
        var constructor = object.constructor;
        var notPlainObject;
        if (object[targetSymbol]) {
            return writeBlockReference(value);
        } else if (constructor === Object) {
            notPlainObject = false;
        } else if (constructor === Array) {
            property = writeProperty(property.key, 'array');
            return writers[property.code](value);
        } else {
            if (object.then) {
                return writeBlockReference(value);
            }
            extendedType = extendedTypes.get(constructor);
            if (extendedType) {
                if (extendedType.toValue) {
                    return writeTypedValue(object);
                }
            } else {
                if (object[iteratorSymbol]) {
                    property = writeProperty(property.key, 'array');
                    return writeAsIterable(object, isRoot);
                }
                extendedTypes.set(constructor, extendedType = {
                    name: constructor.name
                });
            }
            if (property.constructs !== constructor) {
                writeToken(TYPE_CODE, METADATA_TYPE);
                writeInlineString(extendedType.name);
                property.constructs = constructor;
            }
            notPlainObject = true;
        }
        var thisProperty = property;
        if (thisProperty.resetTo < thisProperty.length && thisProperty.serializer != serializerId) {
            thisProperty.length = thisProperty.resetTo;
            thisProperty.serializer = serializerId;
        }
        startSequence();
        var i = 0;
        //var sparse = false // densely packed property references can be searched more quickly
        var resumeIndex = -2 // -2 denotes densely packed property references 
        ;
        var propertyIndex = 0;
        for(var key in object){
            if (notPlainObject && !object.hasOwnProperty(key)) continue;
            var value = object[key];
            type = typeof value;
            property = thisProperty[propertyIndex];
            var constructor;
            var extendedType = false;
            if (type === 'object') {
                if (value) {
                    constructor = value.constructor;
                    if (constructor === Object) {
                    // leave type as is
                    } else if (constructor === Array) {
                        type = 'array';
                    } else {
                        extendedType = extendedTypes.get(constructor);
                        if (extendedType && extendedType.toValue) {
                            value = extendedType.toValue(value);
                            type = typeof value // go through the same logic adjustment here
                            ;
                            if (value && type === 'object' && value.constructor === Array) {
                                type = 'array';
                            }
                        } else if (value[iteratorSymbol] && !value.then) {
                            type = 'array';
                        } else {
                            extendedType = false;
                        }
                    }
                } else {
                    type = 'undefined' // treat null as same type as undefined (and boolean), both constants that can go in any type
                    ;
                }
            }
            if (!property || property.key !== key || property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor) {
                var lastPropertyIndex = propertyIndex;
                // property doesn't match, search for it through existing properties
                // note that we are starting at the current propertyIndex, so this makes the assumption that
                // properties are rarely ever swapped, so possible property slots are always forward
                if (resumeIndex > -2) propertyIndex = resumeIndex;
                do {
                    property = thisProperty[++propertyIndex];
                }while (property && (property.key !== key || property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor))
                if (property) {
                    // found a match, reference it
                    writeToken(PROPERTY_CODE, propertyIndex);
                    if (resumeIndex === -2) {
                        resumeIndex = lastPropertyIndex - 1;
                    }
                } else if (thisProperty.getProperty) {
                    // a shared property, let it allocate ids
                    property = thisProperty.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex);
                    propertyIndex = property.index;
                    if (lastPropertyIndex !== propertyIndex && resumeIndex === -2) {
                        resumeIndex = lastPropertyIndex - 1;
                    }
                } else {
                    if (lastPropertyIndex === thisProperty.length) {
                        propertyIndex = lastPropertyIndex;
                    } else {
                        writeToken(PROPERTY_CODE, propertyIndex = thisProperty.length);
                        if (resumeIndex === -2) {
                            resumeIndex = lastPropertyIndex - 1;
                        }
                    }
                    if (propertyIndex < thisProperty.resetTo) {
                        debugger;
                        throw new Error('overwriting frozen property');
                    }
                    property = thisProperty[propertyIndex] = writeProperty(key, type, extendedType);
                }
            }
            if (propertyUsed) propertyUsed(property, object, serializerId, i);
            //			if (property.resumeIndex) // TODO: add a flag to enable this when property ordering can be assumed
            //				resumeIndex = property.resumeIndex
            var code = property.code;
            if (code > 7) {
                if (code === 8) writeAsReferencing(value);
                else writeAsNumber(value);
            } else {
                if (code === 6) writeAsDefault(value);
                else writeAsArray(value);
            }
            propertyIndex++;
            i++;
        }
        property = thisProperty;
        endSequence(i);
    }
    function writeProperty(key, type, extendedType) {
        var property;
        property = [];
        property.key = key;
        property.type = type;
        if (type === 'string') {
            writeToken(TYPE_CODE, REFERENCING_TYPE);
            property.values = [];
            property.code = REFERENCING_TYPE;
        } else if (type === 'number') {
            writeToken(TYPE_CODE, NUMBER_TYPE);
            property.code = NUMBER_TYPE;
        } else if (type === 'object') {
            writeToken(TYPE_CODE, DEFAULT_TYPE);
            property.code = DEFAULT_TYPE;
        } else if (type === 'array') {
            writeToken(TYPE_CODE, ARRAY_TYPE);
            property.code = ARRAY_TYPE;
        } else if (type === 'boolean' || type === 'undefined') {
            property.type = 'object';
            writeToken(TYPE_CODE, DEFAULT_TYPE);
            property.code = DEFAULT_TYPE;
        } else {
            writeToken(TYPE_CODE, DEFAULT_TYPE);
            property.code = 10;
            console.error('Unable to write value of type ' + type);
        }
        if (typeof key === 'string') {
            writeInlineString(key);
        } else if (!(key === null && (type === 'object' || type === 'array'))) {
            writeAsDefault(key);
        }
        if (extendedType) {
            property.extendedType = extendedType;
            writeToken(TYPE_CODE, METADATA_TYPE);
            writeInlineString(extendedType.name);
        }
        return property;
    }
    function writeAsIterable(iterable, isRoot, iterator) {
        // TODO: With top level iterables we could pause for back-pressure
        try {
            if (!iterator) {
                writeToken(SEQUENCE_CODE, OPEN_SEQUENCE);
                iterator = iterable[iteratorSymbol]();
            }
            var arrayProperty = property;
            property = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property
            ;
            // write out the elements
            var result;
            while(!(result = iterator.next()).done){
                writers[property.code](result.value, arrayProperty);
                if (isRoot && charEncoder.hasWritten) {
                    charEncoder.hasWritten = false // reset this property
                    ;
                    property = arrayProperty // restore current property
                    ;
                    pendingEncodings.unshift({
                        then: function(callback) {
                            writeAsIterable(null, true, iterator);
                            return callback();
                        }
                    });
                    return;
                }
            }
        } catch (error) {
            writeToken(TYPE_CODE, METADATA_TYPE);
            writeToken(NUMBER_CODE, ERROR_METADATA);
            writeAsDefault(Object.assign(new (typeof error == 'object' && error ? error.constructor : Error)(), {
                name: error && error.name,
                message: error && error.message || error
            }));
            throw error;
        }
        if (property !== arrayProperty.child) {
            // TODO: This really needs to happen immediately when a property changes, to match the parsing behavior
            arrayProperty.child = property;
        }
        property = arrayProperty // restore current property
        ;
        writeToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence
        ;
    }
    function writeAsArray(array) {
        if (!array) {
            writeTypedValue(array);
        } else if (array[targetSymbol]) {
            return writeBlockReference(array);
        } else if (array.constructor === Array) {
            var length = array.length;
            var needsClosing;
            if (length > 11) {
                writeToken(SEQUENCE_CODE, OPEN_SEQUENCE) // start sequence <
                ;
                needsClosing = true;
            } else {
                writeToken(SEQUENCE_CODE, length) // write out the header token
                ;
            }
            var arrayProperty = property;
            property = arrayProperty[0] // set the current property to the child property
            ;
            // check to see if needs to be reset before starting
            if (arrayProperty.resetTo < arrayProperty.length && arrayProperty.serializer != serializerId) {
                arrayProperty.length = arrayProperty.resetTo;
                arrayProperty.serializer = serializerId;
            }
            var propertyIndex = 0;
            // write out the elements
            for(var i = 0; i < length; i++){
                var value = array[i];
                var type = typeof value;
                if (type === 'object') {
                    if (value) {
                        var constructor = value.constructor;
                        if (constructor === Object) {
                        // leave type as is
                        } else if (constructor === Array) {
                            type = 'array';
                        } else {
                            var extendedType = extendedTypes.get(constructor);
                            if (extendedType && extendedType.toValue) {
                                value = extendedType.toValue(value);
                                type = typeof value // go through the same logic adjustment here
                                ;
                                if (value && type === 'object' && value.constructor === Array) {
                                    type = 'array';
                                }
                            } else {
                                extendedType = false;
                            }
                        }
                    } else {
                        type = 'undefined' // treat null as same type as undefined, both constants
                        ;
                    }
                }
                if (!property) {
                    if (arrayProperty.getProperty) {
                        // a shared property
                        property = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, 0);
                    } else {
                        if (type === 'string' || type === 'number' || type === 'array') property = writeProperty(null, type, extendedType);
                        else {
                            // default doesn't have to be written
                            property = [];
                            property.type = type;
                            property.key = null;
                            property.code = DEFAULT_TYPE;
                        }
                        arrayProperty[0] = property;
                    }
                } else if (property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor) {
                    propertyIndex = -1;
                    do {
                        property = arrayProperty[++propertyIndex];
                    }while (property && (property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor))
                    if (property) {
                        writeToken(PROPERTY_CODE, propertyIndex);
                    } else if (arrayProperty.getProperty) {
                        // a shared property
                        property = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, -1);
                    } else {
                        writeToken(PROPERTY_CODE, propertyIndex);
                        property = writeProperty(null, type, extendedType);
                        arrayProperty[propertyIndex] = property;
                    }
                }
                if (propertyUsed) propertyUsed(property, array, serializerId, i);
                var code = property.code;
                if (code > 7) {
                    if (code === 8) writeAsReferencing(value);
                    else writeAsNumber(value);
                } else {
                    if (code === 6) writeAsDefault(value);
                    else writeAsArray(value);
                }
            }
            if (needsClosing) {
                writeToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence
                ;
            }
            property = arrayProperty // restore current property
            ;
        } else if (typeof array == 'object' && array[iteratorSymbol]) {
            return writeAsIterable(array);
        } else if (type === 'string') {
            return writeInlineString(value);
        } else if (type === 'number' && (value >>> 0 === value || value > 0 && value < 0x400000000000 && value % 1 === 0)) {
            return writeToken(NUMBER_CODE, value);
        } else {
            writeTypedValue(array);
        }
    }
    var blockProperty;
    function writeBlockReference(block, writer) {
        writeToken(SEQUENCE_CODE, DEFERRED_REFERENCE);
        var blockProperty = property;
        var lazyPromise = block[targetSymbol] ? {
            then: then
        } : {
            then: function(callback) {
                return block.then(function(value) {
                    block = value;
                    then(callback);
                }, function(error) {
                    block = Object.assign(new (typeof error == 'object' && error ? error.constructor : Error)(), {
                        name: error && error.name,
                        message: error && error.message || error
                    });
                    if (!blockProperty.upgrade) {
                        writeToken(TYPE_CODE, METADATA_TYPE);
                        writeToken(NUMBER_CODE, ERROR_METADATA);
                    }
                    then(callback);
                });
            }
        };
        function then(callback) {
            if (options.forBlock && block) {
                // this is used by the sizeTable serializer to record the size of each block
                options.forBlock(block, blockProperty);
            } else {
                var buffer = block && block[bufferSymbol] && block[bufferSymbol](blockProperty);
                if (buffer) {
                    writeBuffer(buffer);
                } else {
                    property = blockProperty;
                    var lastPendingEncodings = pendingEncodings;
                    pendingEncodings = [] // record any nested pending encoding separately
                    ;
                    writeAsDefault(block, true) // write it out as the next block
                    ;
                    lastPendingEncodings.unshift.apply(lastPendingEncodings, pendingEncodings) // and splice them in front
                    ;
                    pendingEncodings = lastPendingEncodings;
                }
            }
            callback();
        }
        pendingEncodings.push(lazyPromise);
    }
    var serializer = {
        serialize: function(value, sharedProperty) {
            var buffer = value && value[bufferSymbol] && value[bufferSymbol](sharedProperty);
            if (buffer) {
                charEncoder.writeBuffer(buffer);
                return;
            }
            if (sharedProperty) {
                property = sharedProperty;
                writers[property.code](value);
            } else {
                property = [];
                property.key = null;
                writeAsDefault(value, true);
            }
        },
        getSerialized: function() {
            if (pendingEncodings.length > 0) {
                var promises = [];
                while(pendingEncodings.length > 0){
                    var finished = false;
                    var promise = pendingEncodings.shift().then(function() {
                        finished = true;
                    });
                    if (!finished) {
                        promises.push(promise);
                    }
                }
                if (promises.length > 0) {
                    return Promise.all(promises).then(function() {
                        return serializer.getSerialized();
                    });
                }
            }
            if (options && options.encoding === 'utf16le') {
                return Buffer.from(charEncoder.getSerialized(), 'utf16le');
            }
            return charEncoder.getSerialized();
        },
        flush: charEncoder.flush,
        setOffset: charEncoder.setOffset,
        finish: charEncoder.finish,
        pendingEncodings: pendingEncodings,
        getWriters: function() {
            return {
                writeProperty: writeProperty,
                writeToken: writeToken,
                writeAsDefault: writeAsDefault,
                writeBuffer: writeBuffer
            };
        }
    };
    return serializer;
}
function serialize(value, options) {
    var serializer = createSerializer(options);
    var sharedProperty = options && options.shared;
    var buffer;
    if (sharedProperty && sharedProperty.startWrite) {
        // record the start of each write
        sharedProperty.startWrite(options.avoidShareUpdate, value);
    }
    serializer.serialize(value, sharedProperty);
    buffer = serializer.getSerialized();
    if (sharedProperty && sharedProperty.endWrite) {
        // record the end of each write
        sharedProperty.endWrite(options.avoidShareUpdate, value);
    }
    if (serializer.finish) serializer.finish();
    var sizeTable = value && value[exports.sizeTableSymbol];
    if (sizeTable) {
        buffer.sizeTable = sizeTable;
    }
    if (options && options.lazy) {
        return Buffer.concat([
            value[exports.sizeTableSymbol],
            buffer
        ]);
    }
    return buffer;
}
exports.serialize = serialize;
exports.createSerializer = createSerializer;
function browserCharEncoder() {
    var serialized = '';
    function writeToken(type, number) {
        var serializedToken;
        if (number < 0x10) {
            serializedToken = String.fromCharCode((type << 4 | number) ^ 0x40);
        } else if (number < 0x400) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 6), (number & 0x3f) + 0x40);
        } else if (number < 0x10000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 12), number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x400000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 18), number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x10000000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 24), number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x100000000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 30), number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x400000000) {
            serializedToken = String.fromCharCode((type << 4) + (number / 0x40000000 >>> 0), number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x10000000000) {
            serializedToken = String.fromCharCode((type << 4) + (number / 0x1000000000 >>> 0), number / 0x40000000 & 0x3f, number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x400000000000) {
            serializedToken = String.fromCharCode((type << 4) + (number / 0x40000000000 >>> 0), number / 0x1000000000 & 0x3f, number / 0x40000000 & 0x3f, number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else {
            throw new Error('Too big of number');
        }
        serialized += serializedToken;
    }
    function writeString(string) {
        serialized += string;
    }
    function getSerialized() {
        return serialized;
    }
    return {
        writeToken: writeToken,
        writeString: writeString,
        //writeBuffer,
        getSerialized: getSerialized,
        //insertBuffer,
        //flush,
        startSequence: function() {
            writeToken(SEQUENCE_CODE, OPEN_SEQUENCE);
        },
        endSequence: function() {
            writeToken(SEQUENCE_CODE, END_SEQUENCE);
        },
        getOffset: function() {
            return -1;
        }
    };
}
var ArrayFrom = Array.from || function(iterable, keyValue) {
    var array = [];
    var keyValue = iterable.constructor === Map;
    iterable.forEach(function(key, value) {
        if (keyValue) {
            array.push([
                value,
                key
            ]);
        } else {
            array.push(key);
        }
    });
    return array;
};
function writeMap(map) {
    var keyValues = ArrayFrom(map);
    for(var i = 0, length = keyValues.length; i < length; i++){
        var keyValue = keyValues[i];
        keyValues[i] = {
            key: keyValue[0],
            value: keyValue[1]
        };
    }
    return keyValues;
}
function writeSet(set) {
    return ArrayFrom(set);
}
function writeDate(date) {
    return date.getTime();
}

}.call(this) }),
"[project]/node_modules/dpack/lib/serialize-stream.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

"use strict";
const { Transform } = require("stream");
const { createSerializer } = __turbopack_require__("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)");
// a readable stream for serializing a set of variables to a JSON stream
class DPackSerializeStream extends Transform {
    constructor(options){
        // Calls the stream.Readable(options) constructor
        options = options || {};
        super(options);
        this.options = options;
        this.continueWriting = true;
    }
    write(value) {
        const serializer = this.serializer || (this.serializer = createSerializer({
            asBlock: true
        }));
        serializer.serialize(value);
        const buffer = serializer.getSerialized();
        if (buffer.then) {
            // we need to wait for this to finish, spawn a new serializer to handle any other writes
            buffer.then((buffer)=>this.push(buffer));
            this.serializer = null;
        } else {
            serializer.flush(this);
        }
    }
    end(value) {
        if (value) {
            this.options.outlet = this;
            const serializer = this.serializer || (this.serializer = createSerializer(this.options));
            serializer.serialize(value) // we do not need to write the last value as a block, its state won't affect anything afterwards
            ;
        }
        if (this.serializer.pendingEncodings.length > 0) {
            this.endWhenDone = true;
            this.writeNext();
        } else {
            this.serializer.flush();
            this.push(null);
        }
    }
    writeBytes(buffer) {
        try {
            this.continueWriting = this.push(buffer);
        } catch (error) {
            throw error;
        }
    }
    _read() {
        this.continueWriting = true;
        if (!this.pausedForPromise && this.serializer && this.endWhenDone && this.serializer.pendingEncodings.length > 0) {
            this.writeNext();
        }
    }
    writeNext() {
        var isSync;
        do {
            var hasMoreToSend = this.serializer.pendingEncodings.length > 0;
            isSync = null;
            if (hasMoreToSend) {
                this.serializer.pendingEncodings.shift().then(()=>{
                    if (isSync === false) {
                        // if we are async, call writeNext which will look for more pending encodings
                        this.pausedForPromise = false;
                        if (this.continueWriting || this.serializer.pendingEncodings.length === 0) this.writeNext();
                        else {
                            this.serializer.flush() // flush what we have before waiting for _read call
                            ;
                        }
                    } else {
                        // mark it as sync so we can exit and loop instead of recursing
                        isSync = true;
                    }
                }, (error)=>{
                    // the serializer should handle promise errors, but if that fails, end the stream with the error
                    console.error(error);
                    this.push(error.toString());
                    this.push(null);
                });
                if (!isSync) {
                    isSync = false;
                    // flush what we have so far while waiting for the promise
                    this.pausedForPromise = true;
                    this.serializer.flush();
                } else if (!this.continueWriting && this.serializer.pendingEncodings.length > 0) {
                    this.serializer.flush() // flush what we have
                    ;
                    return;
                }
            } else if (this.endWhenDone) {
                this.serializer.flush();
                this.push(']');
                this.push(null);
            }
        }while (isSync)
    }
}
exports.createSerializeStream = ()=>{
    return new DPackSerializeStream();
};

}.call(this) }),
"[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

"use strict";
// type codes:
// these are the codes that are used to determine the rudimentary type of numbers
var PROPERTY_CODE = 0;
var TYPE_CODE = 3;
var STRING_CODE = 2;
var NUMBER_CODE = 1;
var SEQUENCE_CODE = 7;
// constant codes
var NULL = 0 // p
;
var FALSE = 3 // s
;
var TRUE = 4 // t
;
var UNDEFINED = 5 // u
;
// these are the starting codes (structures also use this space) for complete types
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
var REFERENCING_TYPE = 8;
var NUMBER_TYPE = 9;
var EXTENSIONS = 10;
var METADATA_TYPE = 11;
var COPY_PROPERTY = 12 // for defining a typed object without returning the value
;
var REFERENCING_POSITION = 13;
var TYPE_DEFINITION = 14 // for defining a typed object without returning the value
;
var ERROR_METADATA = 500;
// sequence codes
var OPEN_SEQUENCE = 12 // <
;
var PARTIAL_DEFERRED_REFERENCE = 12 // <
;
var END_SEQUENCE = 14 // >
;
var DEFERRED_REFERENCE = 15 // ?
;
var MAX_LENGTH = 1024 * 1024 * 16;
var PAUSED = {};
function createParser(options) {
    if (!options) options = {};
    var offset;
    var source;
    var isPartial;
    var classByName = options.classByName || new Map();
    classByName.set('Map', readMap);
    classByName.set('Set', readSet);
    classByName.set('Date', readDate);
    var pausedState;
    var deferredReads;
    function pause(state, lastRead) {
        state.previous = pausedState;
        state.resume = true;
        pausedState = state;
        if (!isPartial) throw new Error('Unexpected end of dpack stream');
        if (!parser.onResume) parser.onResume = function(nextString, isPartialString, rebuildString) {
            // top of the resume stack
            var resumeState = pausedState;
            pausedState = null;
            parser.onResume = null;
            // we slice and add these together to generate an entirely new string
            // so we don't cause a memory leak with redundant strings that a retained a slice parents
            if (lastRead < source.length) source = source.slice(lastRead) + nextString;
            else {
                if (rebuildString) source = nextString.slice(0, 1) + nextString.slice(1);
                else source = nextString;
            }
            isPartial = isPartialString;
            disposedChars += lastRead;
            offset = 0;
            return resumeState.reader ? resumeState.reader(resumeState) : readSequence(resumeState.length, resumeState);
        };
        return state.object;
    }
    function readSequence(length, thisProperty) {
        /* propertyStates:
		0 - starting next property slot
		1 - property created, succeeding value should be value of property
		2 - property creation in progress, next value should define key
		11+ - modifying property, next value modifies property (adds metadata, position, type, etc.)
		*/ var propertyState = 0;
        thisProperty = thisProperty || [];
        var property, isArray, object, value, i = 0, propertyIndex = 0;
        if (thisProperty.resume) {
            property = thisProperty.previous;
            if (property) {
                // do the previous/upper stack frame first
                var value = property.reader ? property.reader(property) : readSequence(property.length, property);
                var values = property.values;
                if (values) {
                    // we have an assignment to referencing values that is waiting for pausing to complete
                    if (pausedState) {
                        // if still paused, pass on to next pausedState
                        pausedState.values = values;
                    } else {
                        if (value.nextPosition > -1) {
                            // we use this path for fulfilling forward references, and when the position is reset
                            values[values.nextPosition++] = value;
                        } else {
                            values.push(value);
                        }
                    }
                }
            }
            if (thisProperty.code && thisProperty.code !== thisProperty.thisProperty.code) {
                thisProperty.resume = false // if the resume property has been reassigned to an incompatible type, can't switch
                ;
            } else {
                i = thisProperty.i || 0;
                object = thisProperty.object;
                propertyState = thisProperty.propertyState || 0;
                propertyIndex = thisProperty.propertyIndex || 0;
                thisProperty = thisProperty.thisProperty;
            }
        }
        isArray = thisProperty.code === ARRAY_TYPE /*ARRAY_TYPE*/ ;
        object = object || (thisProperty.constructs ? new thisProperty.constructs() : isArray ? [] : {}) // TODO: we could probably construct a new reader that does this a little faster
        ;
        for(; i < length;){
            var type, number;
            var lastRead = offset;
            var token = source.charCodeAt(offset++);
            if (token >= 0x30) {
                if (token > 0x3000) {
                    type = token >>> 12 ^ 4;
                    number = token & 0xfff;
                } else {
                    type = token >>> 4 ^ 4;
                    number = token & 0xf;
                }
            } else {
                type = token >>> 4 & 11 // shift and omit the stop bit (bit 3)
                ;
                number = token & 0xf;
                token = source.charCodeAt(offset++);
                number = (number << 6) + (token & 0x3f) // 10 bit number
                ;
                if (!(token >= 0x40)) {
                    token = source.charCodeAt(offset++);
                    number = (number << 6) + (token & 0x3f) // 16 bit number
                    ;
                    if (!(token >= 0x40)) {
                        token = source.charCodeAt(offset++);
                        number = (number << 6) + (token & 0x3f) // 22 bit number
                        ;
                        if (!(token >= 0x40)) {
                            token = source.charCodeAt(offset++);
                            number = (number << 6) + (token & 0x3f) // 28 bit number
                            ;
                            if (!(token >= 0x40)) {
                                token = source.charCodeAt(offset++);
                                number = number * 0x40 + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)
                                ;
                                if (!(token >= 0x40)) {
                                    token = source.charCodeAt(offset++);
                                    number = number * 0x40 + (token & 0x3f) // 40 bit number
                                    ;
                                    if (!(token >= 0x40)) {
                                        token = source.charCodeAt(offset++);
                                        number = number * 0x40 + (token & 0x3f) // 46 bit number, we don't go beyond this
                                        ;
                                        if (!(token >= 0)) {
                                            if (offset > source.length) {
                                                return pause({
                                                    length: length,
                                                    thisProperty: thisProperty,
                                                    i: i,
                                                    object: object,
                                                    propertyIndex: propertyIndex,
                                                    propertyState: propertyState
                                                }, lastRead);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (type === 0) {
                propertyIndex = number;
                propertyState = 0;
                continue;
            }
            property = thisProperty[propertyIndex];
            if (type === 3) {
                // we store the previous property state in token, so we can assign the next one
                if (number < 6) {
                    // special values (constants, deferreds)
                    if (number < 3) {
                        if (number === 0) {
                            value = null;
                        } else {
                            value = 'Unknown token, type: ' + type + ' number: ' + number;
                        }
                    } else {
                        if (number === TRUE) {
                            value = true;
                        } else if (number === FALSE) {
                            value = false;
                        } else {
                            value = undefined;
                        }
                    }
                } else {
                    if (number <= NUMBER_TYPE) {
                        // property definition
                        if (propertyState === 1) {
                            // we were in property value position, but no value, so we increment position here
                            propertyIndex++;
                            i++;
                            property = thisProperty[propertyIndex];
                        }
                        if (propertyIndex < thisProperty.resetTo) {
                            throw new Error('Overwriting frozen property');
                        }
                        if (property) {
                            if (!property.resume) {
                                value = property.key // inherit the existing key
                                ;
                                property = thisProperty[propertyIndex] = [];
                                property.key = value;
                            }
                        } else {
                            property = thisProperty[propertyIndex] = [];
                            property.key = null;
                        }
                        property.code = number;
                        property.parent = thisProperty;
                        //property.key = null
                        propertyState = 2 // read next value as the key
                        ;
                        if (number === REFERENCING_TYPE /*REFERENCING_TYPE*/ ) {
                            property.values = [];
                        } else if (number === ARRAY_TYPE) {
                            property[0] = [];
                            property[0].key = null;
                            property[0].code = DEFAULT_TYPE;
                            property[0].parent = property;
                        }
                    } else {
                        // property modification
                        propertyState = number;
                    }
                    continue;
                }
            } else {
                if (type === 2 /*STRING_CODE*/ ) {
                    value = source.slice(offset, offset += number);
                    if (offset > source.length) {
                        return pause({
                            length: length,
                            thisProperty: thisProperty,
                            i: i,
                            object: object,
                            propertyIndex: propertyIndex,
                            propertyState: propertyState
                        }, lastRead);
                    }
                    if (propertyState < 2) {
                        if (property.code === NUMBER_TYPE /*NUMBER_TYPE*/ ) {
                            value = +value;
                        }
                    }
                } else if (type === 1) {
                    value = number;
                } else {
                    if (number > 13) {
                        if (number === END_SEQUENCE) return object;
                        else if (number === DEFERRED_REFERENCE) {
                            value = readSequence(0, property);
                            propertyState = 0;
                            if (options.forDeferred) {
                                value = options.forDeferred(value, property);
                            } else {
                                (deferredReads || (deferredReads = [])).push({
                                    property: property,
                                    value: value
                                });
                            }
                        }
                    } else {
                        if (number >= OPEN_SEQUENCE) {
                            number = 2000000000;
                        }
                        if (propertyState > 1) {
                            if (propertyState === 2) {
                                propertyState = 0 // if the property key was skipped, go directly into value mode
                                ;
                                value = readSequence(number, property);
                            } else if (propertyState === METADATA_TYPE) value = readSequence(number, [
                                {
                                    key: null,
                                    code: 6
                                }
                            ]);
                            else if (property.resume && (property.code || DEFAULT_TYPE) === property.thisProperty.code) value = readSequence(number, property.thisProperty);
                            else value = readSequence(number, property);
                        } else value = readSequence(number, property);
                        if (pausedState) {
                            if (value === undefined) {
                                pausedState = null // erase anything further up in the stack, as this means the sequence couldn't start, so we need to re-parse from here
                                ;
                                parser.onResume = null;
                                return pause({
                                    length: length,
                                    thisProperty: thisProperty,
                                    i: i,
                                    object: object,
                                    property: property,
                                    propertyIndex: propertyIndex,
                                    previousProperty: previousProperty,
                                    propertyState: propertyState
                                }, lastRead);
                            } else {
                                // need to assign the values *after* the completion of the sequence if it is a forward reference
                                pausedState.values = property.values instanceof Array ? property.values : undefined;
                            }
                        } /*else if (values) {
							
						}*/ 
                    }
                }
            }
            if (!property) {
                throw new Error('No property defined for slot' + (thisProperty.key ? ' in ' + thisProperty.key : ''));
            }
            if (propertyState < 2 && property && property.code === REFERENCING_TYPE /*REFERENCING_TYPE*/ ) {
                var values = property.values;
                if (typeof value === 'number') {
                    value = values[number];
                    if (value === undefined && !(number in values)) {
                        throw new Error('Referencing value that has not been read yet');
                    }
                } else if ((type === 2 || type === 7) && values) {
                    if (values.nextPosition > -1) {
                        // we use this path for fulfilling forward references
                        if (property.recordValueReference) {
                            property.recordValueReference(values);
                        }
                        values[values.nextPosition++] = value;
                    } else {
                        values.push(value);
                    }
                }
            }
            if (propertyState > 1) {
                // 0, 1: values are the value of the property
                if (propertyState === 2) {
                    property.key = value;
                } else if (propertyState === METADATA_TYPE) {
                    if (typeof value === 'string') {
                        var extendedType = classByName.get(value);
                        if (extendedType) {
                            if (extendedType.fromValue) {
                                property.fromValue = extendedType.fromValue;
                            } else {
                                property.constructs = extendedType;
                            }
                        } else if (options.errorOnUnknownClass) {
                            throw new Error('Attempt to deserialize to unknown class ' + parameter);
                        } else {
                        // if no warning, just parse as a plain value/object
                        }
                        property.extendedType = extendedType // if this gets used for serialization, this is needed
                        ;
                    } else {
                        // extended metadata assignment (used by shared structures to mark objects as unstructured)
                        property.metadata = value;
                        if (value === ERROR_METADATA) property.fromValue = onError;
                    }
                } else if (propertyState === REFERENCING_POSITION) {
                    var values = property.values || (property.values = []);
                    //values.splice(value, values.length)
                    values.nextPosition = value;
                } else if (propertyState === TYPE_DEFINITION) {
                // throw away this value and read next value as the real value
                } else {
                    throw new Error('Unknown property type ' + propertyState);
                }
                propertyState = 1 // property value after definition position
                ;
                continue; // read next value as the property value
            } else {
                propertyState = 0;
            }
            if (property.fromValue) {
                value = property.fromValue(value);
            }
            if (isArray && property.key === null) {
                object.push(value);
            } else if (value !== undefined) {
                object[property.key] = value;
            }
            i++;
            if (!isArray) propertyIndex++;
        }
        return object;
    }
    function unknownType(number) {
        throw new Error('Unknown type ' + number);
    }
    var nonParsingError;
    function onError(error) {
        var g = typeof global != 'undefined' ? global : window;
        if (error && error.name && g[error.name]) error = new g[error.name](error.message);
        else if (typeof error == 'string') error = new Error(error);
        if (options.onError) options.onError(error);
        else {
            nonParsingError = true;
            throw error;
        }
    }
    var disposedChars = 0;
    function read(property) {
        try {
            if (property && property.resume) {
                var previous = property.previous;
                value = readSequence(previous.length, previous);
                // once we get the value, we don't know which point in the stack could still be resolving
                value = property.object || value;
                property = property.property;
            } else {
                property = property || [
                    options && options.shared || {
                        key: null,
                        code: 6
                    }
                ];
                var value = readSequence(1, property)[property[0].key];
            }
            while(true){
                if (pausedState) {
                    return pause({
                        reader: read,
                        object: value,
                        property: property
                    });
                }
                if (!deferredReads) {
                    return value;
                }
                var index = deferredReads.index || 0;
                var deferredRead = deferredReads[index];
                deferredReads.index = index + 1;
                if (!deferredRead) {
                    deferredReads = deferredReads.parent;
                    continue;
                }
                var target = deferredRead.value;
                var parentDeferredReads = deferredReads;
                deferredReads = [];
                deferredReads.parent = parentDeferredReads;
                var targetProperty = deferredRead.property;
                var result = readSequence(1, property = [
                    {
                        resume: true,
                        key: null,
                        thisProperty: targetProperty,
                        object: target
                    }
                ]);
                result = result.null || result[targetProperty.key] // Blocks should use null as the root key, but could have the target property key as well
                ;
                if (result != target) {
                    // object was replaced with something else (an array, presumably)
                    Object.assign(target, result);
                    if (pausedState && pausedState.object === result) {
                        pausedState.object = target;
                    }
                    if (result && result.constructor === Array) {
                        target.length = result.length;
                        Object.setPrototypeOf(target, Object.getPrototypeOf(result)) // do our best to make it array like
                        ;
                    }
                }
            }
        } catch (error) {
            if (!nonParsingError) error.message = 'DPack parsing error: ' + error.message + ' at position: ' + (offset + disposedChars) + ' near: ' + source.slice(offset - 10, offset + 10);
            throw error;
        }
    }
    var parser = {
        setSource: function(string, startOffset, isPartialString) {
            source = string;
            offset = startOffset || 0;
            disposedChars = 0;
            isPartial = isPartialString;
            return this;
        },
        hasMoreData: function() {
            return source.length > offset;
        },
        isPaused: function() {
            return pausedState;
        },
        hasUnfulfilledReferences: function() {
            return deferredReads && deferredReads.length > deferredReads.index;
        },
        getOffset: function() {
            return offset + disposedChars;
        },
        read: read
    };
    return parser;
}
exports.parse = function(stringOrBuffer, options) {
    var source;
    if (typeof stringOrBuffer === 'string') {
        source = stringOrBuffer;
    } else if (stringOrBuffer && stringOrBuffer.toString) {
        source = stringOrBuffer.toString(options && options.encoding || 'utf8');
    } else {
        return stringOrBuffer;
    }
    var parser = createParser(options).setSource(source);
    if (options && options.shared) return parser.read([
        options.shared
    ]);
    return parser.read();
};
exports.createParser = createParser;
var readMap = {
    fromValue: function(entries) {
        var map = new Map();
        for(var i = 0, l = entries.length; i < l; i++){
            var entry = entries[i];
            map.set(entry.key, entry.value);
        }
        return map;
    }
};
var readSet = {
    fromValue: function(values) {
        var set = new Set(values);
        if (set.size === 0 && values.length > 0) {
            for(var i = 0, l = values.length; i < l; i++){
                set.add(values[i]);
            }
        }
        return set;
    }
};
var readDate = {
    fromValue: function(time) {
        return new Date(time);
    }
};

}.call(this) }),
"[project]/node_modules/dpack/lib/parse-stream.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

"use strict";
var Transform = require("stream").Transform;
var createParser = __turbopack_require__("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)").createParser;
var DEFAULT_OPTIONS = {
    objectMode: true
};
class DPackParseStream extends Transform {
    constructor(options){
        if (options) {
            options.objectMode = true;
        } else {
            options = DEFAULT_OPTIONS;
        }
        super(options);
        this.parser = createParser(options);
        this.waitingValues = [];
    }
    _transform(chunk, encoding, callback) {
        var value;
        try {
            var sourceString = chunk.toString();
            var parser = this.parser;
            if (parser.onResume) {
                value = parser.onResume(sourceString, true);
                if (!parser.isPaused()) this.sendValue(value);
            } else {
                parser.setSource(sourceString, 0, true);
            }
            while(parser.hasMoreData()){
                value = parser.read();
                if (parser.isPaused()) break;
                else this.sendValue(value);
            }
        } catch (error) {
            console.error(error);
        }
        if (callback) callback();
    }
    sendValue(value) {
        if (this.parser.hasUnfulfilledReferences()) {
            if (value !== undefined) {
                this.waitingValues.push(value);
            }
        } else {
            while(this.waitingValues.length > 0){
                this.push(this.waitingValues.shift());
            }
            if (value !== undefined) {
                this.push(value);
            }
        }
    }
}
exports.createParseStream = ()=>new DPackParseStream();

}.call(this) }),
"[project]/node_modules/dpack/lib/node-encoder.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

var PREFERRED_MAX_BUFFER_SIZE = 0x8000;
var availableBuffers = [];
function nodeCharEncoder(options) {
    var offset = options.startOffset || 0;
    var bufferSize;
    var outlet = options.outlet;
    var buffer = availableBuffers.pop();
    if (buffer && buffer.length > offset + 0x80) {
        // reuse existing buffer if we can
        bufferSize = buffer.length;
    } else {
        bufferSize = (offset >> 12 << 12) + 0x2000;
        buffer = Buffer.allocUnsafeSlow(bufferSize);
    }
    var encoding = options.encoding;
    var sequences = [];
    function makeRoom(bytesNeeded) {
        if (outlet) {
            outlet.writeBytes(buffer.slice(0, offset));
            if (bufferSize < PREFERRED_MAX_BUFFER_SIZE || bytesNeeded > PREFERRED_MAX_BUFFER_SIZE) {
                bufferSize = Math.max(bufferSize * 4, bytesNeeded);
            }
            buffer = Buffer.allocUnsafeSlow(bufferSize);
            offset = 0;
            sequences = [] // clear insertion points
            ;
            encoder.hasWritten = true;
        } else {
            bufferSize = Math.max(bufferSize * 4, bufferSize + bytesNeeded, 0x2000);
            var oldBuffer = buffer;
            buffer = Buffer.allocUnsafeSlow(bufferSize);
            oldBuffer.copy(buffer, 0, 0, offset);
        }
    }
    function flush(specifiedOutlet) {
        (specifiedOutlet || outlet).writeBytes(buffer.slice(0, offset));
        if (offset + 0x80 > buffer.length) buffer = Buffer.allocUnsafeSlow(bufferSize = Math.min(Math.max((offset >> 10 << 10) + 0x2000, bufferSize), 0x8000)) // allocate a new buffer, don't want to overwrite the bytes in the old one while they are in use!
        ;
        else {
            buffer = buffer.slice(offset);
            bufferSize = buffer.length;
        }
        offset = 0;
        sequences = [] // clear insertion points
        ;
    }
    function writeToken(type, number) {
        if (number < 0x10) {
            buffer[offset++] = (type << 4) + number ^ 0x40;
        } else if (number < 0x400) {
            buffer[offset++] = (type << 4) + (number >>> 6);
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x10000) {
            buffer[offset++] = (type << 4) + (number >>> 12);
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x400000) {
            buffer[offset++] = (type << 4) + (number >>> 18);
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x10000000) {
            buffer[offset++] = (type << 4) + (number >>> 24);
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x100000000) {
            buffer[offset++] = (type << 4) + (number >>> 30);
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x400000000) {
            buffer[offset++] = (type << 4) + (number / 0x40000000 >>> 0);
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x10000000000) {
            buffer[offset++] = (type << 4) + (number / 0x1000000000 >>> 0);
            buffer[offset++] = number / 0x40000000 & 0x3f;
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x400000000000) {
            buffer[offset++] = (type << 4) + (number / 0x40000000000 >>> 0);
            buffer[offset++] = number / 0x1000000000 & 0x3f;
            buffer[offset++] = number / 0x40000000 & 0x3f;
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else {
            throw new Error('Invalid number ' + number);
        }
        if (offset > bufferSize - 10) {
            makeRoom(0);
        }
    }
    function writeBuffer(source) {
        var sourceLength = source.length;
        if (sourceLength + offset + 10 > bufferSize) {
            makeRoom(sourceLength + 10);
        }
        source.copy(buffer, offset);
        offset += sourceLength;
    }
    function writeString(string) {
        var length = string.length;
        var maxStringLength = length * 3 + 10;
        if (offset + maxStringLength > bufferSize) {
            makeRoom(maxStringLength + 10);
        }
        var bytesWritten = encoding ? buffer.write(string, offset, buffer.length, encoding) : buffer.utf8Write(string, offset, buffer.length);
        offset += bytesWritten;
    }
    function getSerialized() {
        return buffer.slice(0, offset);
    }
    function insertBuffer(headerBuffer, position) {
        var headerLength = headerBuffer.length;
        if (offset + headerLength + 10 > bufferSize) {
            makeRoom(headerLength + 10);
        }
        buffer.copy(buffer, headerLength + position, position, offset);
        headerBuffer.copy(buffer, position);
        offset += headerLength;
    }
    var encoder = {
        writeToken,
        writeString,
        writeBuffer,
        getSerialized,
        insertBuffer,
        flush,
        startSequence () {
            var currentOffset = offset;
            buffer[offset++] = 60;
            sequences.push(currentOffset);
            if (offset > bufferSize - 10) {
                makeRoom(0);
            }
        },
        endSequence (length) {
            var startOffset = sequences.pop();
            if (length < 12 && startOffset > -1) {
                buffer[startOffset] = 48 + length;
                return;
            }
            buffer[offset++] = 62 // else we need to put an end sequence token in
            ;
        },
        finish () {
            if (buffer.length - offset > 0x90) availableBuffers.push(buffer.slice(offset));
        },
        getOffset () {
            return offset;
        },
        setOffset (newOffset) {
            offset = newOffset;
        }
    };
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    return encoder;
}
exports.nodeCharEncoder = nodeCharEncoder;

}.call(this) }),
"[project]/node_modules/dpack/lib/Options.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

"use strict";
function Options() {
    var classByName = this.classByName = new Map();
    this.converterByConstructor = new Map();
//writerByConstructor.set(Map, writeMap)
//writerByConstructor.set(Set, writeSet)
}
Options.prototype.addExtension = function(Class, name, options) {
    if (name && Class.name !== name) {
        Class.name = name;
    }
    this.classByName.set(Class.name, options && options.fromArray ? options : Class);
    this.converterByConstructor.set(Class, options && options.toArray ? options : Class);
};
exports.Options = Options;

}.call(this) }),
"[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

const createSerializer = __turbopack_require__("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)").createSerializer;
const serialize = __turbopack_require__("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)").serialize;
const createParser = __turbopack_require__("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)").createParser;
const Options = __turbopack_require__("[project]/node_modules/dpack/lib/Options.js [app-route] (ecmascript)").Options;
const STRING_CODE = 2;
var PROPERTY_CODE = 0;
var NUMBER_CODE = 1;
var TYPE_CODE = 3;
var SEQUENCE_CODE = 7;
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
var REFERENCING_TYPE = 8;
var NUMBER_TYPE = 9;
var NULL = 0 // p
;
var METADATA_TYPE = 11;
var REFERENCING_POSITION = 13;
var TYPE_DEFINITION = 14 // ~  // for defining a typed object without returning the value
;
var UNSTRUCTURED_MARKER = 11;
var OPEN_SEQUENCE = 12 // <
;
var END_SEQUENCE = 14 // >
;
var COUNT_THRESHOLD = 2;
exports.createSharedStructure = createSharedStructure;
exports.readSharedStructure = readSharedStructure;
function readSharedStructure(from) {
    var parser = createParser();
    var sharedProperty = [];
    sharedProperty.code = 6;
    sharedProperty.key = null;
    // end with with NULL (p) value to return something from type definition
    parser.setSource(from + 'p').read([
        sharedProperty
    ]);
    setupShared(sharedProperty);
    sharedProperty.serialized = from;
    return sharedProperty;
}
function setupShared(property) {
    property.resetTo = property.length;
    property.upgrade = upgrade;
    property.type = types[property.code];
    property.isFrozen = true;
    Object.defineProperty(property, 'serialized', {
        get () {
            return this._serialized || (this._serialized = serializeSharedStructure(this));
        }
    });
    if (typeof property.values === 'object' && property.values) {
        property.values.resetTo = property.values.length;
        property.lastIndex = property.values.length;
    }
    for(var i = 0, l = property.length; i < l; i++){
        property[i].index = i;
        property[i].resumeIndex = i;
        setupShared(property[i]);
    }
}
function startWrite() {
    for(var i = 0, l = this.length; i < l; i++){
        startWrite.call(this[i]);
    }
    this.length = this.resetTo || 0;
    if (typeof this.values === 'object' && this.values) {
        this.values.length = this.values.resetTo || 0;
    }
}
// upgrades the property to output this block
// return 0 if the property was upgraded, or is compatible,
// 1 if the shared information needs to be written out, but the property was upgraded
// 2 if the shared information needs to be reserialized
function upgrade(property) {
    if (!property) {
        return 1;
    }
    var compatibility;
    if (property) {
        // same block was serialized last time, fast path to compatility
        if (property.insertedFrom === this && property.insertedVersion === this.version && (property.recordUpdate || property.isFrozen || property.length == 0 && property.code == this.code && property.values == null)) {
            // but if the version incremented, we need to update
            return 0;
        }
        var changedCode;
        if (this.code !== property.code) changedCode = true;
        if (property.upgrade) {
            var compatibility = copyProperty(this, property);
            if (changedCode) compatibility = 2;
            if (property.isFrozen && compatibility > 0) {
                return 2;
            }
            property.insertedFrom = this;
            property.insertedVersion = this.version;
            if (compatibility === 2) {
                debugger;
                console.error('Inserting incompatible block into property');
                return 2;
            } else return 0;
        } else {
            property.insertedFrom = this;
            property.insertedVersion = this.version;
            // if this is not a shared property that tracks changes, we have reset and ensure that it doesn't change when we reuse it
            property.length = 0;
            property.values = null;
            if (property.fromValue) property.fromValue = null;
            return 1;
        }
    } else {
        if (this.length > 0) {
            // no property, (but block is shared) so just write the buffer with its shared part (if there is one)
            blockBuffer = Buffer.concat([
                this.serialized,
                blockBuffer
            ]);
        }
    }
    return 1;
}
var typeToCode = {
    string: REFERENCING_TYPE,
    number: NUMBER_TYPE,
    object: DEFAULT_TYPE,
    boolean: DEFAULT_TYPE,
    undefined: DEFAULT_TYPE,
    array: ARRAY_TYPE
};
var lastPropertyOnObject = new WeakMap();
function createSharedStructure(from, options) {
    var instanceProperty = [];
    instanceProperty.key = null;
    instanceProperty.code = 6;
    instanceProperty.type = 'object';
    let activeList = [];
    let needsCleanup = [];
    activeList.iteration = 0;
    var previousAvoidShareUpdate;
    // property id ranges:
    // shared: 0 - 511
    // instance: 512+
    // shared: 
    class Shared extends Array {
        constructor(instanceProperty){
            super();
            let hasUpdates;
            this.key = typeof instanceProperty.key == 'string' ? isolateString(instanceProperty.key) : instanceProperty.key;
            this.type = instanceProperty.type;
            this.code = instanceProperty.code;
            this.count = 0;
            this.comesAfter = [];
            if (this.code == REFERENCING_TYPE) {
                this.values = [];
                this.values.resetTo = 512;
                this.values.nextPosition = 512;
                this.previousValues = new Map();
                this.lastIndex = 0;
                this.repetitions = 0;
            }
        }
        newProperty(instance) {
            return new Shared(instance);
        }
        getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex) {
            let property;
            if (this.insertedFrom) {
                propertySearch(this.insertedFrom);
                if (property) {
                    if (lastPropertyIndex !== property.index) {
                        writeToken(PROPERTY_CODE, propertyIndex);
                    }
                    return property;
                }
                if (this.insertedFrom.getProperty) {
                    //this.recordUpdate()
                    return this.insertedFrom.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex);
                } else {
                    debugger;
                }
            }
            this.recordUpdate();
            let propertyIndex = this.length;
            if (lastPropertyIndex !== propertyIndex) {
                writeToken(PROPERTY_CODE, propertyIndex);
            }
            if (type === 'boolean' || type === 'undefined') {
                type = 'object';
            }
            property = this[propertyIndex] = new Shared({
                key,
                type,
                code: typeToCode[type]
            });
            property.parent = this;
            property.index = propertyIndex;
            return property;
            function propertySearch(parentProperty) {
                let propertyIndex = -1;
                do {
                    property = parentProperty[++propertyIndex];
                }while (property && (property.key !== key || property.type !== type && type !== 'boolean' && type !== 'undefined' || extendedType && property.extendedType !== constructor))
            }
        }
        writeSharedValue(value, writeToken, serializerId) {
            // there are several possible states of a property:
            // 1) Non-referencing state (initial state) - We don't reset position indices, and we never reference previous values
            // 2) Shared/repetitive state - We can have shared values (<12 position) and we can reference properties in an instance (>=12 position)
            // 3) Non-repetitive - If repetition is rare, goes to default type
            let valueEntry = this.previousValues.get(value);
            if (valueEntry) {
                if (valueEntry.serializer == serializerId) {
                    this.repetitions++;
                } else {
                    valueEntry.serializations++;
                    valueEntry.serializer = serializerId;
                }
            } else {
                this.previousValues.set(value, valueEntry = {
                    serializations: 1,
                    serializer: serializerId
                });
            }
            if (!this.active) {
                this.active = 2;
                activeList.push(this);
            }
            return false;
        /*var index = this.values.length
			if (index < 12)
				this.values[index] = value*/ }
        propertyUsed(property, object, serializerId, i) {
            if (property.lastSerializer !== serializerId) {
                property.lastSerializer = serializerId;
                property.count++;
            }
            if (i !== 0) {
                let lastProperty = lastPropertyOnObject.get(object);
                // record what has come before so we can order them when creating a common structure
                if (lastProperty && property.comesAfter.indexOf(lastProperty) === -1) property.comesAfter.push(lastProperty);
            }
            lastPropertyOnObject.set(object, property);
        }
        recordUpdate() {
            var property = this;
            do {
                property.version = (property.version || 0) + 1;
                if (property.insertedFrom) {
                    // or we could try to upgrade the latest inserted property?
                    property.insertedFrom = null;
                }
                if (property._serialized) property._serialized = null;
            }while (property = property.parent)
        }
        readingBlock(parse) {
            //var blockStructure = this.asBlockStructure()
            try {
                return parse();
            } finally{
                this.readReset();
                if (this.length > 500) {
                    debugger;
                }
            }
        }
        //active:
        // 0 - not-actively being monitored
        // 1 - being monitored, but an iteration hasn't started for this
        // 2 - being monitored, and an iteration has started
        startWrite(avoidShareUpdate, value) {
            activeList.iteration++;
            if (value && value.constructor === Array) {
                if (this.code !== ARRAY_TYPE && this.version > 0) {
                    throw new Error('Can not change the root type of a shared object to an array');
                }
                if (this.code != ARRAY_TYPE) this.recordUpdate();
                this.code = ARRAY_TYPE;
                this.type = 'array';
            }
            if (this.writing) return;
            else this.writing = true;
            return;
            previousAvoidShareUpdate = currentAvoidShareUpdate;
            if (avoidShareUpdate) currentAvoidShareUpdate = true;
        }
        endWrite() {
            if (this.writing) this.writing = false;
            else return;
            let iterations = this.iterations = (this.iterations || 0) + 1;
            for(let i = 0; i < activeList.length; i++){
                let activeSharedProperty = activeList[i];
                let previousValues = activeSharedProperty.previousValues;
                if (previousValues && previousValues.size && !activeSharedProperty.isFrozen) {
                    if (!currentAvoidShareUpdate) {
                        if (activeSharedProperty.values.length == 0 && iterations > ((activeSharedProperty.repetitions || 0) + 10) * 5) {
                            // move to permanently non-repetitive
                            console.log('changing referenceable to default', activeSharedProperty.key);
                            activeSharedProperty.previousValues = null;
                            activeSharedProperty.code = DEFAULT_TYPE;
                            activeSharedProperty.type = 'object';
                            activeSharedProperty.recordUpdate();
                            activeList.splice(i--, 1);
                            previousValues = [];
                        }
                        for (let [value, entry] of previousValues){
                            let values = activeSharedProperty.values;
                            if ((entry.serializations + 3) * 8 < iterations - (entry.startingIteration || (entry.startingIteration = iterations)) || values.length > 500) {
                                previousValues.delete(value);
                            }
                            if (entry.serializations > 50 && entry.serializations * 3 > iterations) {
                                values[activeSharedProperty.lastIndex++] = value;
                                activeSharedProperty.recordUpdate();
                                console.log('adding value', value, 'to', activeSharedProperty.key);
                                previousValues.delete(value) // done with tracking, it has been accepted as a common value
                                ;
                            }
                        }
                    }
                } else {
                    activeSharedProperty.active = 0;
                    activeList.splice(i--, 1);
                }
            }
            if (activeList.hasUpdates) {
                activeList.hasUpdates = false;
                this.version++;
                if (!this._serialized) this._serialized = null;
                if (options && options.onUpdate) options.onUpdate();
            }
            currentAvoidShareUpdate = previousAvoidShareUpdate;
        }
        upgrade(property) {
            return upgrade.call(this, property);
        }
        get serialized() {
            return this._serialized || (this._serialized = serializeSharedStructure(this));
        }
        serializeCommonStructure(embedded) {
            var usageThreshold = Math.sqrt(activeList.iteration);
            return serializeSharedStructure(this, (childProperty)=>childProperty.count >= usageThreshold, embedded);
        }
    }
    var sharedStructure = new Shared(instanceProperty);
    sharedStructure.version = 0;
    sharedStructure.freeze = function() {
        this.isFrozen = true;
        this.reset();
    };
    if (from) {
        var parser = createParser({
            forDeferred (block, property) {
                property.isBlock = true;
                return block;
            },
            parseDeferreds: true
        });
        // concatenate shared structure with null so there is a value to parse
        var readProperty = [];
        readProperty.code = 6;
        readProperty.key = null;
        // end with with NULL (p) value to return something from type definition
        parser.setSource(from + 'p').read([
            readProperty
        ]);
        copyProperty(readProperty, sharedStructure);
        activeList.hasUpdates = false;
        sharedStructure.version = 1;
    }
    sharedStructure.key = null // root must be null (for the parser to work properly)
    ;
    return sharedStructure;
}
function isDescendant(property, possibleParent) {
    do {
        if (property === possibleParent) return true;
    }while (property = property.parent)
}
// default type for each code
var types = {
    6: 'object',
    7: 'array',
    8: 'string',
    9: 'number'
};
var currentAvoidShareUpdate;
function serializeSharedStructure(property, condition, embedded) {
    var serializer = createSerializer();
    var writers = serializer.getWriters();
    serializeSharedProperty(property, !embedded, !embedded);
    function serializeSharedProperty(property, expectsObjectWithNullKey, isRoot) {
        if (property.insertedFrom && property.insertedFrom.serializeCommonStructure) {
            property = property.insertedFrom;
            return writers.writeBuffer(property.serializeCommonStructure(!isRoot));
        }
        var isArray = property.code === ARRAY_TYPE;
        var commonProperties = condition ? orderProperties(property.filter(condition)) : property;
        var length = commonProperties.length;
        if (!(expectsObjectWithNullKey && property.code === DEFAULT_TYPE)) {
            let key = isRoot ? null : property.key;
            writers.writeProperty(key, types[property.code]);
            if (length === 0 && key === null && (property.code === DEFAULT_TYPE || property.code === ARRAY_TYPE)) {
                // the key was elided, but won't be followed by sequence, so write one now
                writers.writeToken(SEQUENCE_CODE, 0);
            }
        }
        if (isRoot && length > 0) {
            writers.writeToken(TYPE_CODE, TYPE_DEFINITION);
        }
        if (length > 0) {
            // we always use open sequence, because writing multiple values of a property use extra property counts,
            // plus it is easier to deal with properties without values
            writers.writeToken(SEQUENCE_CODE, OPEN_SEQUENCE);
            for(var i = 0; i < length; i++){
                var childProperty = commonProperties[i];
                childProperty.index = i;
                if (isArray && i > 0) {
                    writers.writeToken(PROPERTY_CODE, i);
                }
                serializeSharedProperty(childProperty, commonProperties.code === ARRAY_TYPE && i === 0, false, condition);
            }
            writers.writeToken(SEQUENCE_CODE, END_SEQUENCE);
        }
        var first = true;
        /*		if (property.previousValues) {
			for (let [value, count] of property.previousValues) {
				if (count >= usageThreshold * 2) {
					if (first)
						first = false
					else // reset property code for each subsequent value so we don't move on to the next property in parsing
						writers.writeToken(PROPERTY_CODE, property.index)
					writers.writeAsDefault(value)
				}
			}
		} else */ if (property.lastIndex > 0) {
            for(var i = 0, l = property.lastIndex; i < l; i++){
                var value = property.values[i];
                if (first) first = false;
                else writers.writeToken(PROPERTY_CODE, property.index);
                writers.writeAsDefault(value);
            }
        }
    }
    let serialized = serializer.getSerialized();
    return serialized;
}
function copyProperty(source, target, freezeTarget, startingIndex) {
    var compatibility = 0;
    target.code = source.code;
    target.type = source.type || types[source.code];
    if (freezeTarget) {
        target.isFrozen = true;
        if (target.previousValues) target.previousValues = null;
    }
    let sourceLength = source.resetTo > -1 ? source.resetTo : source.length;
    if (target.resetTo > -1 && target.resetTo < target.length) target.length = target.resetTo;
    for(var i = startingIndex || 0; i < sourceLength; i++){
        var targetChild = target[i];
        var childProperty = source[i];
        if (targetChild && (targetChild.key != childProperty.key || targetChild.extendedType != childProperty.extendedType || targetChild.code != childProperty.code && !(targetChild.code == 8 && childProperty.code === 6 && (!targetChild.values || !targetChild.values.length)))) {
            if (target.isFrozen) return 2;
            compatibility = 2;
        }
        if (!targetChild) {
            if (target.isFrozen) return 2;
            var targetChild = [];
            targetChild.code = childProperty.code;
            if (target.newProperty) {
                targetChild = target.newProperty(targetChild);
            }
            target[i] = targetChild;
            if (childProperty.metadata) targetChild.metadata = childProperty.metadata;
            if (childProperty.insertedFrom) {
                targetChild.insertedFrom = childProperty.insertedFrom;
                targetChild.insertedVersion = childProperty.insertedVersion;
            }
            targetChild.parent = target;
        }
        targetChild.key = childProperty.key;
        // TODO: Check to make sure the values are compatible
        if (childProperty.values && childProperty.values.length > 0) {
            if (childProperty.values.resetTo > -1) {
                childProperty.values.length = childProperty.values.resetTo;
            }
            if (!targetChild.values || childProperty.values.length > (targetChild.values.resetTo > -1 ? targetChild.values.resetTo : targetChild.values.length)) {
                targetChild.values = childProperty.values.slice(0);
                targetChild.values.nextPosition = childProperty.values.length;
                if (targetChild.values.length >= 12) {
                    targetChild.previousValues = null;
                }
                if (compatibility == 0) {
                    compatibility = 1;
                }
            }
        }
        var childCompatibility = copyProperty(childProperty, targetChild, freezeTarget);
        if (childCompatibility > compatibility) compatibility = childCompatibility;
    }
    let targetLength = target.resetTo > -1 ? target.resetTo : target.length;
    if (targetLength > sourceLength) {
        if (target.recordUpdate) {
            // reverse freeze if the target has more values, we don't want the source becoming incompatible
            source.metadata = UNSTRUCTURED_MARKER;
            source.recordUpdate();
        } else if (target.isFrozen) {
            return 2;
        }
    // merge back to the source if there are extra properties on the target
    //copyProperty(target, source, i)
    //source.recordUpdate()
    }
    /*if (target.previousValues) {
		target.values = target.previousValues
		target.previousValues = []
	}*/ //target.length = source.length
    return compatibility;
}
// return values:
// 0: identical property structures
// -1: a has less properties, but can be safely upgraded to b and still be compatible with a
// 1: a has more properties, but is compatible and can be used to decode b
// -2: incompatible property structures, can not be used
function isCompatibleProperty(a, b) {
    if (a.blockStructure === b) {
        return a.version > b.version ? 1 : 0;
    }
    if (a.code === b.code && a.extendedType === b.extendedType) {
        var sharedLength = Math.min(a.length, b.length);
        var compatibility = 0;
        for(var i = 0; i < sharedLength; i++){
            if (a[i].key !== b[i].key) return -2;
            var childCompatibility = isCompatibleProperty(a[i], b[i]);
            if (childCompatibility === -2) return -2;
            if (childCompatibility === -1) {
                if (compatibility === 1) return -2;
                compatibility = -1;
            }
            if (childCompatibility === 1) {
                if (compatibility === -1) return -2;
                compatibility = 1;
            }
        }
        var sharedValuesLength = Math.min(a.values ? a.values.length : 0, b.values ? b.values.length : 0);
        for(var i = 0; i < sharedValuesLength; i++){
            if (a.values[i] !== b.values[i]) {
                return -2;
            }
        }
        if (a.length < b.length) {
            if (compatibility === 1) {
                return -2;
            }
            compatibility = -1;
        } else if (a.length < b.length) {
            if (compatibility === -1) {
                return -2;
            }
            compatibility = 1;
        }
        /*if (a.values.length < b.values.length) {
			if (compatibility === 1) {
				return -2
			}
			compatibility = -1
		} else if (a.values.length < b.values.length) {
			if (compatibility === -1) {
				return -2
			}
			compatibility = 1
		}*/ return compatibility;
    } else {
        return -2;
    }
}
function isolateString(string) {
    // this is a technique to forcefully recreate a string so it isn't a slice of a larger string. Because shared
    // structures are long-lived and created from instance structures that are short-lived, the long-lived small
    // sliced strings can end up pinning (otherwise short-lived) large strings in memory.
    return string.slice(0, 1) + string.slice(1);
}
// order properties by their comesAfter list, to ensure each properties comes after everything in their comesAfter list
function orderProperties(properties) {
    var ordered = [];
    var traversed = new Set();
    function addProperty(property) {
        if (traversed.has(property)) return;
        traversed.add(property);
        for (var propertyBefore of property.comesAfter){
            addProperty(propertyBefore);
        }
        ordered.push(property);
    }
    for (let property of properties){
        addProperty(property);
    }
    return ordered;
}

}.call(this) }),
"[project]/node_modules/dpack/lib/Block.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

"use strict";
const BLOCK_TYPE = 5;
var makeSymbol = typeof Symbol !== 'undefined' ? Symbol : function(name) {
    return 'symbol-' + name;
};
/*
Two types of blocks, frozen and copy-on-write
Frozen - originating from JS objects
	Object.freeze() js objects and use symbol for serialized representation
Frozen - originating from dpack, lazy evaluation
	Proxy - get,has,etc. triggers parse, set throws
Copy-on-write from JS objects
	Proxy - get,has,etc. retrieves from source JS object, set copies
Copy-on-write originating from dpack
	Same
*/ var nextVersion = 1;
var bufferSymbol = makeSymbol('buffer');
var sizeTableSymbol = makeSymbol('sizeTable');
var headerSymbol = makeSymbol('header');
var parsedSymbol = makeSymbol('parsed');
var sharedSymbol = makeSymbol('shared');
var targetSymbol = makeSymbol('target');
const freezeObjects = ("TURBOPACK compile-time value", "development") != 'production';
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
/*
size table size types in first 2 bits:

first byte
0 - leaf mode, 6 bit length
1 - leaf mode, 14 bit length
2 - branch/leaf mode, 14, 16, 16 bit our-size length
3 - branch/leaf mode, 30, 48, 48 bit our-size length
*/ function Block() {}
var serializeModule = __turbopack_require__("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)");
exports.Block = Block;
exports.bufferSymbol = serializeModule.bufferSymbol = bufferSymbol;
exports.parsedSymbol = parsedSymbol;
exports.sharedSymbol = sharedSymbol;
exports.targetSymbol = serializeModule.targetSymbol = targetSymbol;
exports.sizeTableSymbol = serializeModule.sizeTableSymbol = sizeTableSymbol;
var serialize = serializeModule.serialize;
var createSerializer = serializeModule.createSerializer;
exports.asBlock = asBlock;
function asBlock(object, shared) {
    if (object && object[targetSymbol]) {
        return object // already a block
        ;
    }
    if (Array.isArray(object)) {
        // if the object is an array, make the taget an array so it passes Array.isArray checks
        let target = [];
        target.parsed = object;
        target.shared = shared;
        return new Proxy(target, onDemandHandler);
    }
    return new Proxy({
        parsed: object,
        shared: shared
    }, onDemandHandler);
}
exports.isBlock = isBlock;
function isBlock(object) {
    return object && object[targetSymbol];
}
exports.makeBlockFromBuffer = makeBlockFromBuffer;
function makeBlockFromBuffer(buffer, shared) {
    var dpackBuffer, sizeTableBuffer;
    if (buffer[0] < 0x80) {
        dpackBuffer = buffer;
    } else {
        var type = buffer[0] >> 6;
        var dpackOffset;
        if (type === 2) {
            dpackOffset = buffer.readUInt16BE(0) & 0x3fff;
        } else {
            dpackOffset = buffer.readUInt32BE(0) & 0x3fffffff;
        }
        dpackBuffer = buffer.slice(dpackOffset);
        sizeTableBuffer = buffer.slice(0, dpackOffset);
    }
    var target = {
        dpackBuffer: dpackBuffer,
        sizeTableBuffer: sizeTableBuffer,
        shared: shared,
        reassign: function(buffer) {
            this.buffer = buffer;
        }
    };
    buffer.owner = target;
    return new Proxy(target, onDemandHandler);
}
exports.getLazyHeader = function(block) {
    return block[sizeTableSymbol];
};
var onDemandHandler = {
    get: function(target, key) {
        if (specialGetters.hasOwnProperty(key)) {
            return specialGetters[key].call(target);
        }
        var parsed = target.parsed;
        if (!parsed) {
            parsed = getParsed(target);
        }
        return parsed[key];
    },
    set: function(target, key, value) {
        // we allow symbols to set as a form of metadata objects even though the main string keyed properties are frozen
        if (typeof key === 'symbol') {
            target[key] = value;
            makeSymbolGetter(key);
            return true;
        }
        throw new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify');
    },
    deleteProperty: function() {
        throw new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify');
    },
    getOwnPropertyDescriptor: function(target, key) {
        var parsed = getParsed(target);
        return Object.getOwnPropertyDescriptor(parsed, key);
    },
    has: function(target, key) {
        var parsed = getParsed(target);
        return key in parsed;
    },
    ownKeys: function(target) {
        var parsed = getParsed(target);
        var keys = Object.keys(parsed);
        if (Array.isArray(parsed)) {
            keys.push('length');
        }
        return keys;
    },
    getPrototypeOf: function(target) {
        var parsed = getParsed(target);
        return Object.getPrototypeOf(parsed);
    }
};
exports.reassignBuffers = reassignBuffers;
function reassignBuffers(block, newParentNodeBuffer, parentArrayBuffer) {
    // if a buffer needs to be moved to a new buffer due to it soon being no longer referenceable, we can reference the new copy
    var target = block[targetSymbol];
    var buffer = target.dpackBuffer;
    if (!parentArrayBuffer) parentArrayBuffer = buffer.buffer;
    if (buffer && buffer.buffer === parentArrayBuffer) {
        var byteOffset = buffer.byteOffset;
        target.dpackBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length);
    }
    var buffer = target.sizeTableBuffer;
    if (buffer && buffer.buffer === parentArrayBuffer) {
        var byteOffset = buffer.byteOffset;
        target.sizeTableBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length);
    }
    if (target.parsed) {
        var parsed = target.parsed;
        for(var key in parsed){
            var value = parsed[key];
            if (isBlock(value)) {
                reassignBuffers(value, newParentNodeBuffer, parentArrayBuffer);
            }
        }
    }
}
var copyOnWriteHandler = {
    get: function(target, key) {
        if (specialGetters.hasOwnProperty(key)) {
            return specialGetters[key].call(target);
        }
        var cachedParsed = target.cachedParsed;
        if (cachedParsed && cachedParsed.hasOwnProperty(key) && !(key == 'length' && Array.isArray(cachedParsed))) {
            return cachedParsed[key];
        }
        var parsed = target.parsed;
        if (!parsed) {
            parsed = getParsed(target);
        }
        var value = parsed[key];
        /*if (value && typeof value == 'object') {
			if (!cachedParsed) {
				target.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {}
			}
			if (value instanceof Map)
				cachedParsed[key] = value
			else
				cachedParsed[key] = value = copyWithParent(value, target)
		}*/ if (value && value[targetSymbol]) {
            if (!cachedParsed) {
                target.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {};
            }
            cachedParsed[key] = value = copyWithParent(value, target);
        }
        return value;
    },
    changed: function(target) {
        target.dpackBuffer = null;
        target.sizeTableBuffer = null;
        target.shared = null;
        var parsed = target.parsed;
        if (!parsed) {
            parsed = getParsed(target);
        }
        if (!target.copied) {
            var cachedParsed = target.cachedParsed;
            var copied = target.parsed = target.cachedParsed = parsed instanceof Array ? [] : {};
            for(var key in parsed){
                var value = cachedParsed && cachedParsed[key];
                if (!value) {
                    value = parsed[key];
                    if (value && value[targetSymbol]) {
                        value = copyWithParent(value, target);
                    }
                }
                copied[key] = value;
            }
            parsed = copied;
            target.copied = true;
        }
        target.version = nextVersion++;
        return parsed;
    },
    checkVersion: function(target) {
        var cachedParsed = target.cachedParsed;
        let version = target.version || 0;
        if (cachedParsed) {
            for(let key in cachedParsed){
                var value = cachedParsed[key];
                if (value && value[targetSymbol]) {
                    version = Math.max(version, this.checkVersion(value[targetSymbol]));
                }
            }
        }
        if (version != (target.version || 0)) {
            this.changed(target);
            target.version = version;
        }
        return version;
    },
    set: function(target, key, value, proxy) {
        if (specialSetters.hasOwnProperty(key)) {
            specialSetters[key].call(target, value);
            return true;
        }
        var parsed = copyOnWriteHandler.changed(target);
        parsed[key] = value;
        return true;
    },
    deleteProperty: function(target, key) {
        var parsed = copyOnWriteHandler.changed(target);
        return delete parsed[key];
    },
    getOwnPropertyDescriptor: function(target, key) {
        var parsed = getParsed(target);
        return Object.getOwnPropertyDescriptor(parsed, key);
    },
    has: function(target, key) {
        var parsed = getParsed(target);
        return key in parsed;
    },
    ownKeys: function(target) {
        var parsed = getParsed(target);
        var keys = Object.keys(parsed);
        if (Array.isArray(parsed)) {
            keys.push('length');
        }
        if (target.copied) {
            for(var key in target.copied){
                if (keys.indexOf(key) === -1) {
                    keys.push(key);
                }
            }
        }
        return keys;
    },
    getPrototypeOf: function(target) {
        var parsed = getParsed(target);
        return Object.getPrototypeOf(parsed);
    }
};
var specialGetters = {};
specialGetters[bufferSymbol] = function() {
    return (function(property, randomAccess) {
        var propertyIsShared = property && property.upgrade;
        var buffer;
        if (this.cachedParsed && this.dpackBuffer) {
            copyOnWriteHandler.checkVersion(this);
        }
        if (!(this.shared && this.shared.upgrade) && propertyIsShared) {
            if (this.dpackBuffer) {
                // if the block has been serialized without a shared structure, and it will be used in a shared structure,
                // we put it in a separate property
                this.sizeTableBuffer = null;
                return inSeparateProperty(this.dpackBuffer, true);
            } else {
                return getSerialized(this, this.shared = property);
            }
        }
        if (!this.dpackBuffer) {
            getSerialized(this, this.shared);
        }
        if (this.shared && this.shared.upgrade && this.shared !== property) {
            var compatibility = this.shared.upgrade(property, randomAccess);
            if (compatibility > 0) {
                // if the property upgrade was incompatible, we have to included the shared structure, and force sequential reading
                this.sizeTableBuffer = null;
                var sharedBuffer = this.shared.serialized;
                if (sharedBuffer.length > 0) {
                    if (compatibility == 2 && !(property.isFrozen && property.resetTo === 0)) sharedBuffer = inSeparateProperty(sharedBuffer);
                    buffer = Buffer.concat([
                        sharedBuffer,
                        this.dpackBuffer
                    ]);
                    buffer.mustSequence = true;
                    return buffer;
                }
            }
        } else if (property) {
            if (!propertyIsShared) {
                // need to reset this property, if it is a plain sequential property
                property.length = 0;
            }
            if (property.insertedFrom) property.insertedFrom = null;
        }
        return this.dpackBuffer;
        function inSeparateProperty(dpackBuffer) {
            var serializer = createSerializer();
            var isArray = dpackBuffer[0] === 119;
            var writeToken = serializer.getWriters().writeToken;
            if (isArray) {
                dpackBuffer = dpackBuffer.slice(1) // replacing the property declaration
                ;
            }
            writeToken(0, 1000) // use a hopefully unused slot (should be unused, block always has a single initial starting slot)
            ;
            writeToken(3, isArray ? ARRAY_TYPE : DEFAULT_TYPE) // property type
            ;
            if (property && property.key !== null) serializer.serialize(property.key);
            dpackBuffer = Buffer.concat([
                serializer.getSerialized(),
                dpackBuffer
            ]);
            dpackBuffer.mustSequence = true;
            return dpackBuffer;
        }
    }).bind(this);
};
specialGetters[targetSymbol] = function() {
    return this;
};
specialGetters[sharedSymbol] = function() {
    return this.shared;
};
specialGetters[parsedSymbol] = function() {
    return this.parsed || getParsed(this);
};
specialGetters[sizeTableSymbol] = function() {
    if (!this.dpackBuffer) {
        getSerialized(this);
    }
    return this.sizeTableBuffer;
};
specialGetters.then = function() {
// return undefined, this is not a promise
};
specialGetters.toJSON = function() {
    return valueOf;
};
specialGetters.valueOf = function() {
    return valueOf;
};
specialGetters.entries = function() {
    return entries;
};
function entries() {
    return this[parsedSymbol].entries();
}
specialGetters[Symbol.iterator] = function() {
    var parsed = this.parsed || getParsed(this);
    return parsed && parsed[Symbol.iterator] && iterator;
};
function iterator() {
    var parsed = this[parsedSymbol];
    return parsed && parsed[Symbol.iterator] ? parsed[Symbol.iterator]() : [][Symbol.iterator]();
}
specialGetters.constructor = function() {
    if (this.parsed) {
        return this.parsed.constructor;
    }
    // this is a fast path for getting the constructor without having to parse. this is important
    // as it enables blocks to be go through the serializer, have it check the constructor, without
    // requiring parsing, and then they can be directly written from their binary buffer
    if (this.dpackBuffer) {
        let firstByte = this.dpackBuffer[0];
        if (firstByte >= 48 && firstByte <= 60) {
            // sequence
            if (this.shared) {
                if (this.shared.code == DEFAULT_TYPE) {
                    return Object;
                } else if (this.shared.code == ARRAY_TYPE) {
                    return Array;
                }
            } else {
                return Object;
            }
        } else if (firstByte === 119) {
            return Array;
        }
    }
    return getParsed(this).constructor;
};
function makeSymbolGetter(symbol) {
    if (!specialGetters[symbol]) specialGetters[symbol] = function() {
        return this[symbol];
    };
}
function valueOf() {
    return this[parsedSymbol];
}
function copy(source) {
    return copyWithParent(source);
}
function copyWithParent(source, parent) {
    if (!isBlock(source)) {
        /*if (source && typeof source == 'object')
			source = asBlock(source)
		else*/ return source;
    }
    let isArray = Array.isArray(source);
    let target = isArray ? [] : {};
    Object.defineProperties(target, {
        parsed: {
            get () {
                return source[parsedSymbol];
            },
            set (value) {
                Object.defineProperty(this, 'parsed', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
            },
            configurable: true
        },
        shared: {
            get () {
                return source[sharedSymbol];
            },
            set (value) {
                Object.defineProperty(this, 'shared', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
                this.dpackBuffer = null;
                this.sizeTableBuffer = null;
            },
            configurable: true
        },
        dpackBuffer: {
            get () {
                return source[targetSymbol].dpackBuffer;
            },
            set (value) {
                Object.defineProperty(this, 'dpackBuffer', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
            },
            configurable: true
        },
        sizeTableBuffer: {
            get () {
                return source[sizeTableSymbol];
            },
            set (value) {
                Object.defineProperty(this, 'sizeTableBuffer', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
            },
            configurable: true
        }
    });
    if (isArray) {
        Object.define;
    }
    return new Proxy(target, copyOnWriteHandler);
}
exports.copy = copy;
var specialSetters = {};
/*specialSetters[sharedSymbol] = function(shared) {
	return this.shared = shared
}*/ function getParsed(target) {
    var parsed = target.parsed;
    if (parsed) return parsed;
    // we check to see if there are multiple blocks that should be deferred into separate blocks
    var sizeTableBuffer = target.sizeTableBuffer;
    var dpackBuffer = target.dpackBuffer;
    if (!sizeTableBuffer) {
        // no child blocks, just dpack, so directly parse
        return target.parsed = parse(dpackBuffer, {
            freezeObjects: freezeObjects,
            shared: target.shared
        });
    }
    var totalSizeTableLength = sizeTableBuffer.length;
    var totalDPackLength;
    var rootBlockLength;
    var type = sizeTableBuffer[0] >> 6;
    var offset;
    if (type === 2) {
        rootBlockLength = sizeTableBuffer.readUInt16BE(4);
        offset = 6;
    } else {
        rootBlockLength = sizeTableBuffer.readUIntBE(10, 6);
        offset = 16;
    }
    // read child block lengths: (could defer this until child access)
    var childSizeTables = [];
    var childDpackBlocks = [];
    var dpackChildOffset = rootBlockLength;
    while(offset < totalSizeTableLength){
        var type = sizeTableBuffer[offset] >> 6;
        var sizeTableLength;
        var dpackLength;
        if (type < 2) {
            if (type == 0) {
                // 6 bit
                sizeTableLength = 1;
                dpackLength = sizeTableBuffer[offset];
            } else {
                // 14 bit
                sizeTableLength = 2;
                dpackLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff;
            }
        } else if (type === 2) {
            sizeTableLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff;
            dpackLength = sizeTableBuffer.readUInt16BE(offset + 2);
        } else {
            sizeTableLength = sizeTableBuffer.readUInt32BE(offset) & 0x3fffffff;
            dpackLength = sizeTableBuffer.readUIntBE(offset + 4, 6);
        }
        childSizeTables.push(type < 2 || type == 3 && sizeTableLength == 16 ? undefined : sizeTableBuffer.slice(offset, offset + sizeTableLength));
        offset += sizeTableLength;
        childDpackBlocks.push(dpackBuffer.slice(dpackChildOffset, dpackChildOffset += dpackLength));
    }
    var blockIndex = 0;
    var rootBlock = target.dpackBuffer.slice(0, rootBlockLength);
    return target.parsed = parse(rootBlock, childDpackBlocks.length > 0 ? {
        shared: target.shared,
        forDeferred: function(value, property) {
            let target = new value.constructor;
            target.dpackBuffer = childDpackBlocks[blockIndex];
            target.sizeTableBuffer = childSizeTables[blockIndex++];
            target.shared = property ? property.upgrade ? property : {
                code: property.code,
                key: null,
                type: property.type
            } : null;
            return new Proxy(target, onDemandHandler);
        },
        freezeObjects: freezeObjects
    } : {
        shared: target.shared
    });
}
function getSerialized(target, shareProperty) {
    var childBlocks = [];
    var childSizeTables = [];
    var childDpackSizes = 0;
    var mustSequence // mustSequence is an indication that the blocks must be read in sequence and can't be randomly accessed
    ;
    var serializerOptions = {
        forBlock: function(block, property) {
            var dpackBuffer = block[bufferSymbol](property, true);
            if (dpackBuffer.mustSequence) {
                mustSequence = true;
                childBlocks.push(dpackBuffer);
                return dpackBuffer;
            }
            var sizeTableBuffer = block[sizeTableSymbol];
            if (!sizeTableBuffer) {
                // if this child has no children, it won't have have size table, just create a leaf branch buffer
                var bufferLength = dpackBuffer.length;
                if (bufferLength < 64) {
                    // one byte leaf node
                    sizeTableBuffer = Buffer.from([
                        bufferLength
                    ]);
                } else if (bufferLength < 0x4000) {
                    // binary-10 and then 14 bits
                    sizeTableBuffer = Buffer.from([
                        bufferLength >> 8 | 0x40,
                        bufferLength & 0xff
                    ]);
                } else {
                    sizeTableBuffer = Buffer.allocUnsafe(16);
                    sizeTableBuffer.writeUInt32BE(0xc0000010) // binary-11 and then indicate a size of 16
                    ;
                    sizeTableBuffer.writeUIntBE(bufferLength, 4, 6);
                    sizeTableBuffer.writeUIntBE(bufferLength, 10, 6);
                }
            }
            childSizeTables.push(sizeTableBuffer);
            childDpackSizes += dpackBuffer.length;
            childBlocks.push(dpackBuffer);
            return dpackBuffer;
        },
        shared: shareProperty,
        freezeObjects: freezeObjects
    };
    var rootBlock = serialize(target.parsed, serializerOptions);
    if (childBlocks.length == 0) {
        // no child blocks, just use the root block
        return target.dpackBuffer = rootBlock;
    }
    childBlocks.unshift(rootBlock);
    // TODO: Do word aligment with any buffer copying, to make sure CPU can copy words instead of bytes
    var dpackBuffer = target.dpackBuffer = Buffer.concat(childBlocks);
    if (mustSequence) {
        return dpackBuffer;
    }
    var ourSizeBlock = Buffer.allocUnsafe(dpackBuffer.length >= 0x10000 ? 16 : 6);
    childSizeTables.unshift(ourSizeBlock);
    // TODO: Add length parameter to concat so it is length % 8 = 0
    ourSizeBlock = target.sizeTableBuffer = Buffer.concat(childSizeTables);
    if (dpackBuffer.length >= 0x10000) {
        ourSizeBlock.writeUInt32BE(ourSizeBlock.length + 0xc0000000, 0) // binary-11 and then 30 bits
        ;
        ourSizeBlock.writeUIntBE(dpackBuffer.length, 4, 6) // 48 bits
        ;
        ourSizeBlock.writeUIntBE(rootBlock.length, 10, 6) // 48 bits
        ;
    } else {
        ourSizeBlock.writeUInt16BE(ourSizeBlock.length | 0x8000, 0) // binary-10 and then 14 bits
        ;
        ourSizeBlock.writeUInt16BE(dpackBuffer.length, 2) // 16 bits
        ;
        ourSizeBlock.writeUInt16BE(rootBlock.length, 4) // 16 bits
        ;
    }
    return dpackBuffer;
}
function deepCopy(source) {
    let target = new source.constructor();
    for(let key in source){
        let value = source[key];
        if (value && typeof value == 'object') value = deepCopy(value);
        target[key] = value;
    }
    return target;
}
var parse = __turbopack_require__("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)").parse;
var serializeSharedBlock = __turbopack_require__("[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)").serializeSharedBlock;
exports.parseLazy = function(buffer, options) {
    if (buffer[0] & 0x80 || buffer[0] >> 4 === 3 || buffer[0] === 0x77) {
        return makeBlockFromBuffer(buffer, options && options.shared);
    } else {
        return parse(buffer, options);
    }
};

}.call(this) }),
"[project]/node_modules/dpack/index.js [app-route] (ecmascript)": (function({ r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, m: module, e: exports, t: require }) { !function() {

/*
DPack - Fast, compact object structure encoding.
*/ exports.createSerializeStream = __turbopack_require__("[project]/node_modules/dpack/lib/serialize-stream.js [app-route] (ecmascript)").createSerializeStream;
exports.createParseStream = __turbopack_require__("[project]/node_modules/dpack/lib/parse-stream.js [app-route] (ecmascript)").createParseStream;
const serialize = __turbopack_require__("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)");
serialize.nodeCharEncoder = __turbopack_require__("[project]/node_modules/dpack/lib/node-encoder.js [app-route] (ecmascript)").nodeCharEncoder;
const parse = __turbopack_require__("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)");
const Options = __turbopack_require__("[project]/node_modules/dpack/lib/Options.js [app-route] (ecmascript)").Options;
exports.serialize = serialize.serialize;
exports.parse = parse.parse;
exports.createSerializer = serialize.createSerializer;
exports.createParser = parse.createParser;
const Block = __turbopack_require__("[project]/node_modules/dpack/lib/Block.js [app-route] (ecmascript)");
exports.parseLazy = Block.parseLazy;
exports.asBlock = Block.asBlock;
exports.isBlock = Block.isBlock;
exports.copy = Block.copy;
exports.reassignBuffers = Block.reassignBuffers;
exports.Options = Options;
exports.createSharedStructure = __turbopack_require__("[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)").createSharedStructure;
exports.readSharedStructure = __turbopack_require__("[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)").readSharedStructure;

}.call(this) }),

};

//# sourceMappingURL=node_modules_dpack_c69ffc._.js.map