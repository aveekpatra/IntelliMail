{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 270, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/stripe.ts"],"sourcesContent":["'server-only'\nimport Stripe from 'stripe'\n\nexport const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n    apiVersion: '2024-06-20',\n})\n\n"],"names":[],"mappings":";;;AACA;AADA;;AAGO,MAAM,SAAS,IAAI,wJAAA,CAAA,UAAM,CAAC,QAAQ,GAAG,CAAC,iBAAiB,EAAG;IAC7D,YAAY;AAChB","debugId":null}},
    {"offset": {"line": 293, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/env.js"],"sourcesContent":["import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .default(\"development\"),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE;IAC3B;;;GAGC,GACD,QAAQ;QACN,cAAc,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG;QAC5B,UAAU,sIAAA,CAAA,IAAC,CACR,IAAI,CAAC;YAAC;YAAe;YAAQ;SAAa,EAC1C,OAAO,CAAC;IACb;IAEA;;;;GAIC,GACD,QAAQ;IAER;IAEA;;;GAGC,GACD,YAAY;QACV,cAAc,QAAQ,GAAG,CAAC,YAAY;QACtC,QAAQ;IAEV;IACA;;;GAGC,GACD,gBAAgB,CAAC,CAAC,QAAQ,GAAG,CAAC,mBAAmB;IACjD;;;GAGC,GACD,wBAAwB;AAC1B","debugId":null}},
    {"offset": {"line": 340, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"@/env\";\n\nconst createPrismaClient = () =>\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"error\", \"warn\"] : [\"error\"],\n  });\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\n};\n\nexport const db = globalForPrisma.prisma ?? createPrismaClient();\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,qBAAqB,IACzB,IAAI,6HAAA,CAAA,eAAY,CAAC;QACf,KACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBAAgB;YAAC;YAAS;SAAO,GAAG;YAAC;SAAQ;IAClE;AAEF,MAAM,kBAAkB;AAIjB,MAAM,KAAK,gBAAgB,MAAM,IAAI;AAE5C,IAAI,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,cAAc,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/stripe-actions.ts"],"sourcesContent":["'use server'\n\nimport { auth } from \"@clerk/nextjs/server\";\nimport { stripe } from \"./stripe\";\nimport { redirect } from \"next/navigation\";\nimport { db } from \"@/server/db\";\n\nexport async function createCheckoutSession() {\n    const { userId } = await auth();\n\n    if (!userId) {\n        throw new Error('User not found');\n    }\n\n    const session = await stripe.checkout.sessions.create({\n        payment_method_types: ['card'],\n        line_items: [\n            {\n                price: process.env.STRIPE_PRICE_ID,\n                quantity: 1,\n            },\n        ],\n        mode: 'subscription',\n        success_url: `${process.env.NEXT_PUBLIC_URL}/mail`,\n        cancel_url: `${process.env.NEXT_PUBLIC_URL}/pricing`,\n        client_reference_id: userId.toString(),\n    });\n\n    redirect(session.url!);\n}\n\nexport async function createBillingPortalSession() {\n    const { userId } = await auth();\n    if (!userId) {\n        return false\n    }\n    const subscription = await db.stripeSubscription.findUnique({\n        where: { userId: userId },\n    });\n    if (!subscription?.customerId) {\n        throw new Error('Subscription not found');\n    }\n    const session = await stripe.billingPortal.sessions.create({\n        customer: subscription.customerId,\n        return_url: `${process.env.NEXT_PUBLIC_URL}/pricing`,\n    });\n    redirect(session.url!)\n}\n\nexport async function getSubscriptionStatus() {\n    const { userId } = await auth();\n    if (!userId) {\n        return false\n    }\n    const subscription = await db.stripeSubscription.findUnique({\n        where: { userId: userId },\n    });\n    if (!subscription) {\n        return false;\n    }\n    return subscription.currentPeriodEnd > new Date();\n}\n\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AAAA;AACA;;;;;;;;AAEO,eAAe,uCAAmB,GAAnB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAE5B,IAAI,CAAC,QAAQ;QACT,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,UAAU,MAAM,sHAAA,CAAA,SAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;QAClD,sBAAsB;YAAC;SAAO;QAC9B,YAAY;YACR;gBACI,OAAO,QAAQ,GAAG,CAAC,eAAe;gBAClC,UAAU;YACd;SACH;QACD,MAAM;QACN,aAAa,6DAA+B,KAAK,CAAC;QAClD,YAAY,6DAA+B,QAAQ,CAAC;QACpD,qBAAqB,OAAO,QAAQ;IACxC;IAEA,CAAA,GAAA,uLAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG;AACxB;AAEO,eAAe,uCAAwB,GAAxB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAC5B,IAAI,CAAC,QAAQ;QACT,OAAO;IACX;IACA,MAAM,eAAe,MAAM,qHAAA,CAAA,KAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC;QACxD,OAAO;YAAE,QAAQ;QAAO;IAC5B;IACA,IAAI,CAAC,cAAc,YAAY;QAC3B,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,UAAU,MAAM,sHAAA,CAAA,SAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC;QACvD,UAAU,aAAa,UAAU;QACjC,YAAY,6DAA+B,QAAQ,CAAC;IACxD;IACA,CAAA,GAAA,uLAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG;AACxB;AAEO,eAAe,uCAAmB,GAAnB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAC5B,IAAI,CAAC,QAAQ;QACT,OAAO;IACX;IACA,MAAM,eAAe,MAAM,qHAAA,CAAA,KAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC;QACxD,OAAO;YAAE,QAAQ;QAAO;IAC5B;IACA,IAAI,CAAC,cAAc;QACf,OAAO;IACX;IACA,OAAO,aAAa,gBAAgB,GAAG,IAAI;AAC/C;;;IAtDsB;IAwBA;IAkBA;;AA1CA,iPAAA;AAwBA,iPAAA;AAkBA,iPAAA","debugId":null}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/app/constants.ts"],"sourcesContent":["export const FREE_CREDITS_PER_DAY = 15\nexport const FREE_ACCOUNTS_PER_USER = 1\nexport const PRO_ACCOUNTS_PER_USER = 3"],"names":[],"mappings":";;;;;AAAO,MAAM,uBAAuB;AAC7B,MAAM,yBAAyB;AAC/B,MAAM,wBAAwB","debugId":null}},
    {"offset": {"line": 468, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/gmail.ts"],"sourcesContent":["\"use server\";\n\nimport { google } from \"googleapis\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { getSubscriptionStatus } from \"./stripe-actions\";\nimport { db } from \"@/server/db\";\nimport { FREE_ACCOUNTS_PER_USER, PRO_ACCOUNTS_PER_USER } from \"@/app/constants\";\n\n// Create OAuth2 client\nfunction getOAuth2Client() {\n  console.log(\"Creating OAuth2 client with credentials...\");\n  return new google.auth.OAuth2(\n    process.env.GOOGLE_CLIENT_ID,\n    process.env.GOOGLE_CLIENT_SECRET,\n    `${process.env.NEXT_PUBLIC_URL}/api/auth/callback/gmail`,\n  );\n}\n\n/**\n * Generate the authorization URL for Gmail OAuth\n */\nexport const getGmailAuthUrl = async () => {\n  try {\n    console.log(\"Starting Gmail auth URL generation...\");\n    const { userId } = await auth();\n    if (!userId) {\n      console.error(\"No user ID found in auth\");\n      throw new Error(\"User not found\");\n    }\n    console.log(\"Got user ID:\", userId);\n\n    const user = await db.user.upsert({\n      where: { id: userId },\n      update: {},\n      create: {\n        id: userId,\n        emailAddress: \"temp@example.com\", // This will be updated by the webhook\n        role: \"user\",\n      },\n    });\n    console.log(\"User record created/updated:\", user);\n\n    // Check subscription limits\n    console.log(\"Checking subscription limits...\");\n    const isSubscribed = await getSubscriptionStatus();\n    console.log(\"Subscription status:\", isSubscribed);\n\n    const accounts = await db.account.count({\n      where: { userId },\n    });\n    console.log(\"Current account count:\", accounts);\n    console.log(\n      \"Account limit:\",\n      isSubscribed ? PRO_ACCOUNTS_PER_USER : FREE_ACCOUNTS_PER_USER,\n    );\n\n    // Temporarily disabled account limits\n    /*\n    if (user.role === \"user\") {\n      if (isSubscribed) {\n        if (accounts >= PRO_ACCOUNTS_PER_USER) {\n          console.error(\"User has reached maximum accounts for subscription\", {\n            currentAccounts: accounts,\n            maxAccounts: PRO_ACCOUNTS_PER_USER,\n            isSubscribed: true,\n          });\n          throw new Error(\n            \"You have reached the maximum number of accounts for your subscription\",\n          );\n        }\n      } else {\n        if (accounts >= FREE_ACCOUNTS_PER_USER) {\n          console.error(\"User has reached maximum free accounts\", {\n            currentAccounts: accounts,\n            maxAccounts: FREE_ACCOUNTS_PER_USER,\n            isSubscribed: false,\n          });\n          throw new Error(\n            \"You have reached the maximum number of accounts for your subscription\",\n          );\n        }\n      }\n    }\n    */\n\n    console.log(\"Creating OAuth2 client...\");\n    const oauth2Client = getOAuth2Client();\n    const scopes = [\n      \"https://www.googleapis.com/auth/gmail.readonly\",\n      \"https://www.googleapis.com/auth/gmail.send\",\n      \"https://www.googleapis.com/auth/gmail.compose\",\n      \"https://www.googleapis.com/auth/gmail.modify\",\n      \"https://www.googleapis.com/auth/userinfo.email\",\n      \"https://www.googleapis.com/auth/userinfo.profile\",\n    ];\n    console.log(\"Using scopes:\", scopes);\n\n    console.log(\"Generating auth URL with state:\", userId);\n    const authUrl = oauth2Client.generateAuthUrl({\n      access_type: \"offline\",\n      scope: scopes,\n      prompt: \"consent\",\n      state: userId,\n      include_granted_scopes: true,\n    });\n    console.log(\"Auth URL generated successfully:\", authUrl);\n\n    return authUrl;\n  } catch (error) {\n    console.error(\"Error in getGmailAuthUrl:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Exchange authorization code for tokens\n */\nexport const getGmailTokens = async (code: string) => {\n  try {\n    console.log(\"Starting token exchange process...\");\n    console.log(\"Creating OAuth2 client for token exchange...\");\n    const oauth2Client = getOAuth2Client();\n\n    console.log(\"Exchanging code for tokens...\");\n    const { tokens } = await oauth2Client.getToken(code);\n\n    console.log(\"Token exchange successful\");\n    if (!tokens.access_token) {\n      console.error(\"No access token received\");\n      throw new Error(\"Failed to get access token\");\n    }\n\n    console.log(\"Tokens received:\", {\n      accessTokenExists: !!tokens.access_token,\n      refreshTokenExists: !!tokens.refresh_token,\n      expiryDate: tokens.expiry_date,\n    });\n\n    return {\n      accessToken: tokens.access_token,\n      refreshToken: tokens.refresh_token,\n      expiryDate: tokens.expiry_date,\n    };\n  } catch (error) {\n    console.error(\"Error in getGmailTokens:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Get Gmail user information\n */\nexport const getGmailUserInfo = async (accessToken: string) => {\n  try {\n    console.log(\"Starting user info fetch process...\");\n    console.log(\"Setting up OAuth2 client with access token...\");\n    const oauth2Client = getOAuth2Client();\n    oauth2Client.setCredentials({ access_token: accessToken });\n\n    console.log(\"Creating People API client...\");\n    const peopleApi = google.people({ version: \"v1\", auth: oauth2Client });\n\n    console.log(\"Fetching user profile...\");\n    const profile = await peopleApi.people.get({\n      resourceName: \"people/me\",\n      personFields: \"emailAddresses,names\",\n    });\n\n    console.log(\"User profile fetched successfully\");\n    const userInfo = {\n      email: profile.data.emailAddresses?.[0]?.value || \"\",\n      name: profile.data.names?.[0]?.displayName || \"\",\n    };\n    console.log(\"User info:\", userInfo);\n\n    return userInfo;\n  } catch (error) {\n    console.error(\"Error in getGmailUserInfo:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Create a Gmail account for syncing emails\n */\nexport async function createGmailAccount(\n  accessToken: string,\n  refreshToken: string | null | undefined,\n) {\n  try {\n    console.log(\"Creating Gmail account with tokens...\");\n    console.log(\"Token info:\", {\n      accessTokenExists: !!accessToken,\n      refreshTokenExists: !!refreshToken,\n    });\n\n    // Implementation for syncing emails and sending\n    const gmailAccount = {\n      accessToken,\n      refreshToken,\n\n      async syncEmails() {\n        console.log(\"Starting email sync process...\");\n        // Implement email syncing logic here\n        return { success: true, count: 0 };\n      },\n\n      async sendEmail(options: { to: string; subject: string; body: string }) {\n        console.log(\"Sending email:\", options);\n        const oauth2Client = getOAuth2Client();\n        oauth2Client.setCredentials({ access_token: accessToken });\n\n        const gmail = google.gmail({ version: \"v1\", auth: oauth2Client });\n\n        // Format the email according to Gmail API requirements\n        const message = [\n          `To: ${options.to}`,\n          `Subject: ${options.subject}`,\n          \"Content-Type: text/html; charset=utf-8\",\n          \"\",\n          options.body,\n        ].join(\"\\n\");\n\n        const encodedMessage = Buffer.from(message)\n          .toString(\"base64\")\n          .replace(/\\+/g, \"-\")\n          .replace(/\\//g, \"_\")\n          .replace(/=+$/, \"\");\n\n        console.log(\"Sending email via Gmail API...\");\n        await gmail.users.messages.send({\n          userId: \"me\",\n          requestBody: {\n            raw: encodedMessage,\n          },\n        });\n\n        console.log(\"Email sent successfully\");\n        return { success: true };\n      },\n    };\n\n    console.log(\"Gmail account created successfully\");\n    return gmailAccount;\n  } catch (error) {\n    console.error(\"Error in createGmailAccount:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n}\n\n/**\n * Refresh the Gmail access token using the refresh token\n */\nexport const refreshGmailToken = async (refreshToken: string) => {\n  try {\n    console.log(\"Starting token refresh process...\");\n    const oauth2Client = getOAuth2Client();\n\n    console.log(\"Setting refresh token...\");\n    oauth2Client.setCredentials({\n      refresh_token: refreshToken,\n    });\n\n    console.log(\"Refreshing access token...\");\n    const { credentials } = await oauth2Client.refreshAccessToken();\n\n    console.log(\"Access token refreshed successfully\");\n    return {\n      accessToken: credentials.access_token,\n      expiryDate: credentials.expiry_date,\n    };\n  } catch (error) {\n    console.error(\"Error refreshing Gmail token:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Fetch Gmail emails directly from Gmail API\n */\nexport const fetchGmailEmails = async (\n  accessToken: string,\n  maxResults = 20,\n  refreshToken?: string | null,\n) => {\n  try {\n    console.log(\"Starting Gmail email fetch process...\");\n    console.log(\"Setting up OAuth2 client with access token...\");\n    const oauth2Client = getOAuth2Client();\n    oauth2Client.setCredentials({\n      access_token: accessToken,\n      refresh_token: refreshToken || undefined,\n    });\n\n    console.log(\"Creating Gmail API client...\");\n    const gmail = google.gmail({ version: \"v1\", auth: oauth2Client });\n\n    console.log(\"Fetching emails from Gmail API...\");\n    const response = await gmail.users.messages.list({\n      userId: \"me\",\n      maxResults: maxResults,\n      q: \"in:inbox\",\n    });\n\n    console.log(`Retrieved ${response.data.messages?.length || 0} email IDs`);\n\n    if (!response.data.messages || response.data.messages.length === 0) {\n      console.log(\"No emails found\");\n      return [];\n    }\n\n    // Get email details for each message ID\n    console.log(\"Fetching email details...\");\n    const emails = await Promise.all(\n      response.data.messages.map(async (message) => {\n        if (!message.id) return null;\n\n        const emailDetail = await gmail.users.messages.get({\n          userId: \"me\",\n          id: message.id,\n        });\n\n        const headers = emailDetail.data.payload?.headers || [];\n\n        // Extract email headers\n        const subject =\n          headers.find((h) => h.name === \"Subject\")?.value || \"(No subject)\";\n        const from = headers.find((h) => h.name === \"From\")?.value || \"\";\n        const to = headers.find((h) => h.name === \"To\")?.value || \"\";\n        const date = headers.find((h) => h.name === \"Date\")?.value || \"\";\n\n        // Extract email body (text or HTML)\n        let body = \"\";\n        const parts = emailDetail.data.payload?.parts || [];\n\n        if (parts.length > 0) {\n          // Try to find HTML body first\n          const htmlPart = parts.find((p) => p.mimeType === \"text/html\");\n          const textPart = parts.find((p) => p.mimeType === \"text/plain\");\n\n          if (htmlPart && htmlPart.body && htmlPart.body.data) {\n            body = Buffer.from(htmlPart.body.data, \"base64\").toString(\"utf-8\");\n          } else if (textPart && textPart.body && textPart.body.data) {\n            body = Buffer.from(textPart.body.data, \"base64\").toString(\"utf-8\");\n          }\n        } else if (emailDetail.data.payload?.body?.data) {\n          // For single-part messages\n          body = Buffer.from(\n            emailDetail.data.payload.body.data,\n            \"base64\",\n          ).toString(\"utf-8\");\n        }\n\n        // Create a snippet from the body (first 100 chars)\n        const snippet =\n          body.substring(0, 100) + (body.length > 100 ? \"...\" : \"\");\n\n        return {\n          id: message.id,\n          threadId: emailDetail.data.threadId,\n          labelIds: emailDetail.data.labelIds || [],\n          snippet: emailDetail.data.snippet || snippet,\n          subject,\n          from,\n          to,\n          date,\n          body,\n        };\n      }),\n    );\n\n    console.log(`Fetched details for ${emails.filter(Boolean).length} emails`);\n    return emails.filter(Boolean);\n  } catch (error) {\n    console.error(\"Error in fetchGmailEmails:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 849, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/app/api/auth/callback/gmail/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { getGmailTokens, getGmailUserInfo } from \"@/lib/gmail\";\nimport { db } from \"@/server/db\";\n\nexport const GET = async (req: Request) => {\n  console.log(\"[GMAIL CALLBACK] Processing Gmail OAuth callback...\");\n\n  try {\n    // Get the user ID from the URL state parameter\n    const url = new URL(req.url);\n    const errorParam = url.searchParams.get(\"error\");\n\n    if (errorParam) {\n      console.error(\"[GMAIL CALLBACK] Auth error from Google:\", errorParam);\n      return NextResponse.redirect(\n        new URL(`/mail?error=${errorParam}`, req.url),\n      );\n    }\n\n    // Get the authorization code from the URL\n    const code = url.searchParams.get(\"code\");\n    if (!code) {\n      console.error(\n        \"[GMAIL CALLBACK] No authorization code provided in callback\",\n      );\n      return NextResponse.redirect(new URL(\"/mail?error=no_code\", req.url));\n    }\n\n    console.log(\"[GMAIL CALLBACK] Received authorization code\");\n\n    // Get the user ID from the state parameter\n    const userState = url.searchParams.get(\"state\");\n    if (!userState) {\n      console.error(\"[GMAIL CALLBACK] No user ID found in state parameter\");\n      return NextResponse.redirect(new URL(\"/mail?error=no_user\", req.url));\n    }\n\n    console.log(\"[GMAIL CALLBACK] User ID from state:\", userState);\n\n    // Get the tokens from the authorization code\n    console.log(\"[GMAIL CALLBACK] Exchanging code for tokens...\");\n    const tokens = await getGmailTokens(code);\n    console.log(\"[GMAIL CALLBACK] Tokens received successfully:\", {\n      accessTokenLength: tokens.accessToken?.length,\n      hasRefreshToken: !!tokens.refreshToken,\n      refreshTokenLength: tokens.refreshToken?.length,\n    });\n\n    // Check if we have a refresh token\n    if (!tokens.refreshToken) {\n      console.warn(\n        \"[GMAIL CALLBACK] No refresh token received - this will limit token refresh capabilities\",\n      );\n    }\n\n    // Get the user info\n    console.log(\"[GMAIL CALLBACK] Fetching user info...\");\n    const userInfo = await getGmailUserInfo(tokens.accessToken);\n    console.log(\"[GMAIL CALLBACK] User info fetched:\", userInfo);\n\n    // Generate a unique account ID\n    const accountId = `gmail_${crypto.randomUUID()}`;\n    console.log(\"[GMAIL CALLBACK] Generated account ID:\", accountId);\n\n    // Check if an account with this email already exists\n    const existingAccount = await db.account.findFirst({\n      where: {\n        userId: userState,\n        emailAddress: userInfo.email,\n        provider: \"Gmail\",\n      },\n    });\n\n    if (existingAccount) {\n      console.log(\n        \"[GMAIL CALLBACK] Account already exists, updating tokens instead of creating new account\",\n      );\n      // Update the existing account with new tokens\n      const updatedAccount = await db.account.update({\n        where: { id: existingAccount.id },\n        data: {\n          token: tokens.accessToken,\n          refreshToken:\n            tokens.refreshToken || existingAccount.refreshToken || \"\",\n        },\n      });\n      console.log(\"[GMAIL CALLBACK] Account tokens updated successfully:\", {\n        id: updatedAccount.id,\n        email: updatedAccount.emailAddress,\n        hasRefreshToken: !!updatedAccount.refreshToken,\n      });\n    } else {\n      // Save the account to the database\n      console.log(\"[GMAIL CALLBACK] Creating new account in database...\");\n      try {\n        // Check if user exists in database\n        const user = await db.user.findUnique({\n          where: { id: userState },\n        });\n\n        if (!user) {\n          console.error(\n            \"[GMAIL CALLBACK] User not found in database:\",\n            userState,\n          );\n          // Create user if they don't exist\n          await db.user.create({\n            data: {\n              id: userState,\n              emailAddress: userInfo.email,\n            },\n          });\n          console.log(\n            \"[GMAIL CALLBACK] Created new user in database:\",\n            userState,\n          );\n        }\n\n        const createdAccount = await db.account.create({\n          data: {\n            id: accountId,\n            userId: userState,\n            provider: \"Gmail\",\n            emailAddress: userInfo.email,\n            name: userInfo.name,\n            token: tokens.accessToken,\n            refreshToken: tokens.refreshToken || \"\",\n            nextDeltaToken: \"\",\n          },\n        });\n        console.log(\"[GMAIL CALLBACK] ✅ GMAIL ACCOUNT CREATED SUCCESSFULLY!\", {\n          id: createdAccount.id,\n          email: createdAccount.emailAddress,\n          userId: createdAccount.userId,\n          hasRefreshToken: !!createdAccount.refreshToken,\n        });\n      } catch (dbError) {\n        console.error(\n          \"[GMAIL CALLBACK] Error creating account in database:\",\n          dbError,\n        );\n        console.error(\"[GMAIL CALLBACK] Account data:\", {\n          id: accountId,\n          userId: userState,\n          provider: \"Gmail\",\n          emailAddress: userInfo.email,\n          name: userInfo.name,\n          tokenLength: tokens.accessToken.length,\n          hasRefreshToken: !!tokens.refreshToken,\n        });\n        throw dbError;\n      }\n    }\n\n    // Get total Gmail accounts for this user\n    const totalGmailAccounts = await db.account.count({\n      where: {\n        userId: userState,\n        provider: \"Gmail\",\n      },\n    });\n    console.log(\n      `[GMAIL CALLBACK] User now has ${totalGmailAccounts} Gmail ${totalGmailAccounts === 1 ? \"account\" : \"accounts\"} connected.`,\n    );\n\n    // Start initial email sync in the background\n    console.log(\"[GMAIL CALLBACK] Starting background initial sync...\");\n    try {\n      const syncResponse = await fetch(\n        `${process.env.NEXT_PUBLIC_URL}/api/initial-sync`,\n        {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            accountId,\n            userId: userState,\n          }),\n        },\n      );\n\n      if (syncResponse.ok) {\n        console.log(\"[GMAIL CALLBACK] Initial sync request successful\");\n      } else {\n        console.error(\n          \"[GMAIL CALLBACK] Initial sync request failed:\",\n          await syncResponse.text(),\n        );\n      }\n    } catch (syncError) {\n      console.error(\n        \"[GMAIL CALLBACK] Error requesting initial sync:\",\n        syncError,\n      );\n    }\n\n    console.log(\"[GMAIL CALLBACK] Redirecting to mail page...\");\n    return NextResponse.redirect(new URL(\"/mail?success=true\", req.url));\n  } catch (error) {\n    console.error(\"[GMAIL CALLBACK] Error in Gmail callback:\", error);\n    if (error instanceof Error) {\n      console.error(\"[GMAIL CALLBACK] Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n\n    return NextResponse.redirect(\n      new URL(\"/mail?error=callback_failed\", req.url),\n    );\n  }\n};\n"],"names":[],"mappings":"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","debugId":null}}]
}