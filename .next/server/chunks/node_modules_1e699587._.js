module.exports = {

"[project]/node_modules/@t3-oss/env-core/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createEnv": (()=>createEnv)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/zod/lib/index.mjs [app-route] (ecmascript)");
;
function createEnv(opts) {
    const runtimeEnv = opts.runtimeEnvStrict ?? opts.runtimeEnv ?? process.env;
    const emptyStringAsUndefined = opts.emptyStringAsUndefined ?? false;
    if (emptyStringAsUndefined) {
        for (const [key, value] of Object.entries(runtimeEnv)){
            if (value === "") {
                delete runtimeEnv[key];
            }
        }
    }
    const skip = !!opts.skipValidation;
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    if (skip) return runtimeEnv;
    const _client = typeof opts.client === "object" ? opts.client : {};
    const _server = typeof opts.server === "object" ? opts.server : {};
    const _shared = typeof opts.shared === "object" ? opts.shared : {};
    const client = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["object"])(_client);
    const server = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["object"])(_server);
    const shared = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$lib$2f$index$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["object"])(_shared);
    const isServer = opts.isServer ?? ("undefined" === "undefined" || "Deno" in window);
    const allClient = client.merge(shared);
    const allServer = server.merge(shared).merge(client);
    const parsed = isServer ? allServer.safeParse(runtimeEnv) // on server we can validate all env vars
     : allClient.safeParse(runtimeEnv); // on client we can only validate the ones that are exposed
    const onValidationError = opts.onValidationError ?? ((error)=>{
        console.error("❌ Invalid environment variables:", error.flatten().fieldErrors);
        throw new Error("Invalid environment variables");
    });
    const onInvalidAccess = opts.onInvalidAccess ?? ((_variable)=>{
        throw new Error("❌ Attempted to access a server-side environment variable on the client");
    });
    if (parsed.success === false) {
        return onValidationError(parsed.error);
    }
    const isServerAccess = (prop)=>{
        if (!opts.clientPrefix) return true;
        return !prop.startsWith(opts.clientPrefix) && !(prop in shared.shape);
    };
    const isValidServerAccess = (prop)=>{
        return isServer || !isServerAccess(prop);
    };
    const ignoreProp = (prop)=>{
        return prop === "__esModule" || prop === "$$typeof";
    };
    const extendedObj = (opts.extends ?? []).reduce((acc, curr)=>{
        return Object.assign(acc, curr);
    }, {});
    const fullObj = Object.assign(parsed.data, extendedObj);
    const env = new Proxy(fullObj, {
        get (target, prop) {
            if (typeof prop !== "string") return undefined;
            if (ignoreProp(prop)) return undefined;
            if (!isValidServerAccess(prop)) return onInvalidAccess(prop);
            return Reflect.get(target, prop);
        }
    });
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    return env;
}
;
}}),
"[project]/node_modules/@t3-oss/env-nextjs/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createEnv": (()=>createEnv)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$t3$2d$oss$2f$env$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@t3-oss/env-core/dist/index.js [app-route] (ecmascript)");
;
const CLIENT_PREFIX = "NEXT_PUBLIC_";
function createEnv(opts) {
    const client = typeof opts.client === "object" ? opts.client : {};
    const server = typeof opts.server === "object" ? opts.server : {};
    const shared = opts.shared;
    const runtimeEnv = opts.runtimeEnv ? opts.runtimeEnv : {
        ...process.env,
        ...opts.experimental__runtimeEnv
    };
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$t3$2d$oss$2f$env$2d$core$2f$dist$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createEnv"])({
        ...opts,
        shared,
        client,
        server,
        clientPrefix: CLIENT_PREFIX,
        runtimeEnv
    });
}
;
}}),
"[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
module.exports = DelayedStream;
function DelayedStream() {
    this.source = null;
    this.dataSize = 0;
    this.maxDataSize = 1024 * 1024;
    this.pauseStream = true;
    this._maxDataSizeExceeded = false;
    this._released = false;
    this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);
DelayedStream.create = function(source, options) {
    var delayedStream = new this();
    options = options || {};
    for(var option in options){
        delayedStream[option] = options[option];
    }
    delayedStream.source = source;
    var realEmit = source.emit;
    source.emit = function() {
        delayedStream._handleEmit(arguments);
        return realEmit.apply(source, arguments);
    };
    source.on('error', function() {});
    if (delayedStream.pauseStream) {
        source.pause();
    }
    return delayedStream;
};
Object.defineProperty(DelayedStream.prototype, 'readable', {
    configurable: true,
    enumerable: true,
    get: function() {
        return this.source.readable;
    }
});
DelayedStream.prototype.setEncoding = function() {
    return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream.prototype.resume = function() {
    if (!this._released) {
        this.release();
    }
    this.source.resume();
};
DelayedStream.prototype.pause = function() {
    this.source.pause();
};
DelayedStream.prototype.release = function() {
    this._released = true;
    this._bufferedEvents.forEach((function(args) {
        this.emit.apply(this, args);
    }).bind(this));
    this._bufferedEvents = [];
};
DelayedStream.prototype.pipe = function() {
    var r = Stream.prototype.pipe.apply(this, arguments);
    this.resume();
    return r;
};
DelayedStream.prototype._handleEmit = function(args) {
    if (this._released) {
        this.emit.apply(this, args);
        return;
    }
    if (args[0] === 'data') {
        this.dataSize += args[1].length;
        this._checkIfMaxDataSizeExceeded();
    }
    this._bufferedEvents.push(args);
};
DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
    if (this._maxDataSizeExceeded) {
        return;
    }
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    this._maxDataSizeExceeded = true;
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this.emit('error', new Error(message));
};
}}),
"[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var DelayedStream = __turbopack_context__.r("[project]/node_modules/delayed-stream/lib/delayed_stream.js [app-route] (ecmascript)");
module.exports = CombinedStream;
function CombinedStream() {
    this.writable = false;
    this.readable = true;
    this.dataSize = 0;
    this.maxDataSize = 2 * 1024 * 1024;
    this.pauseStreams = true;
    this._released = false;
    this._streams = [];
    this._currentStream = null;
    this._insideLoop = false;
    this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);
CombinedStream.create = function(options) {
    var combinedStream = new this();
    options = options || {};
    for(var option in options){
        combinedStream[option] = options[option];
    }
    return combinedStream;
};
CombinedStream.isStreamLike = function(stream) {
    return typeof stream !== 'function' && typeof stream !== 'string' && typeof stream !== 'boolean' && typeof stream !== 'number' && !Buffer.isBuffer(stream);
};
CombinedStream.prototype.append = function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        if (!(stream instanceof DelayedStream)) {
            var newStream = DelayedStream.create(stream, {
                maxDataSize: Infinity,
                pauseStream: this.pauseStreams
            });
            stream.on('data', this._checkDataSize.bind(this));
            stream = newStream;
        }
        this._handleErrors(stream);
        if (this.pauseStreams) {
            stream.pause();
        }
    }
    this._streams.push(stream);
    return this;
};
CombinedStream.prototype.pipe = function(dest, options) {
    Stream.prototype.pipe.call(this, dest, options);
    this.resume();
    return dest;
};
CombinedStream.prototype._getNext = function() {
    this._currentStream = null;
    if (this._insideLoop) {
        this._pendingNext = true;
        return; // defer call
    }
    this._insideLoop = true;
    try {
        do {
            this._pendingNext = false;
            this._realGetNext();
        }while (this._pendingNext)
    } finally{
        this._insideLoop = false;
    }
};
CombinedStream.prototype._realGetNext = function() {
    var stream = this._streams.shift();
    if (typeof stream == 'undefined') {
        this.end();
        return;
    }
    if (typeof stream !== 'function') {
        this._pipeNext(stream);
        return;
    }
    var getStream = stream;
    getStream((function(stream) {
        var isStreamLike = CombinedStream.isStreamLike(stream);
        if (isStreamLike) {
            stream.on('data', this._checkDataSize.bind(this));
            this._handleErrors(stream);
        }
        this._pipeNext(stream);
    }).bind(this));
};
CombinedStream.prototype._pipeNext = function(stream) {
    this._currentStream = stream;
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
        stream.on('end', this._getNext.bind(this));
        stream.pipe(this, {
            end: false
        });
        return;
    }
    var value = stream;
    this.write(value);
    this._getNext();
};
CombinedStream.prototype._handleErrors = function(stream) {
    var self = this;
    stream.on('error', function(err) {
        self._emitError(err);
    });
};
CombinedStream.prototype.write = function(data) {
    this.emit('data', data);
};
CombinedStream.prototype.pause = function() {
    if (!this.pauseStreams) {
        return;
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == 'function') this._currentStream.pause();
    this.emit('pause');
};
CombinedStream.prototype.resume = function() {
    if (!this._released) {
        this._released = true;
        this.writable = true;
        this._getNext();
    }
    if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == 'function') this._currentStream.resume();
    this.emit('resume');
};
CombinedStream.prototype.end = function() {
    this._reset();
    this.emit('end');
};
CombinedStream.prototype.destroy = function() {
    this._reset();
    this.emit('close');
};
CombinedStream.prototype._reset = function() {
    this.writable = false;
    this._streams = [];
    this._currentStream = null;
};
CombinedStream.prototype._checkDataSize = function() {
    this._updateDataSize();
    if (this.dataSize <= this.maxDataSize) {
        return;
    }
    var message = 'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
    this._emitError(new Error(message));
};
CombinedStream.prototype._updateDataSize = function() {
    this.dataSize = 0;
    var self = this;
    this._streams.forEach(function(stream) {
        if (!stream.dataSize) {
            return;
        }
        self.dataSize += stream.dataSize;
    });
    if (this._currentStream && this._currentStream.dataSize) {
        this.dataSize += this._currentStream.dataSize;
    }
};
CombinedStream.prototype._emitError = function(err) {
    this._reset();
    this.emit('error', err);
};
}}),
"[project]/node_modules/mime-types/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 'use strict';
/**
 * Module dependencies.
 * @private
 */ var db = __turbopack_context__.r("[project]/node_modules/mime-db/index.js [app-route] (ecmascript)");
var extname = __turbopack_context__.r("[externals]/path [external] (path, cjs)").extname;
/**
 * Module variables.
 * @private
 */ var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */ exports.charset = charset;
exports.charsets = {
    lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);
// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function charset(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    var mime = match && db[match[1].toLowerCase()];
    if (mime && mime.charset) {
        return mime.charset;
    }
    // default text/* to utf-8
    if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return 'UTF-8';
    }
    return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */ function contentType(str) {
    // TODO: should this even be in this module?
    if (!str || typeof str !== 'string') {
        return false;
    }
    var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;
    if (!mime) {
        return false;
    }
    // TODO: use content-type or other module
    if (mime.indexOf('charset') === -1) {
        var charset = exports.charset(mime);
        if (charset) mime += '; charset=' + charset.toLowerCase();
    }
    return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */ function extension(type) {
    if (!type || typeof type !== 'string') {
        return false;
    }
    // TODO: use media-typer
    var match = EXTRACT_TYPE_REGEXP.exec(type);
    // get extensions
    var exts = match && exports.extensions[match[1].toLowerCase()];
    if (!exts || !exts.length) {
        return false;
    }
    return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */ function lookup(path) {
    if (!path || typeof path !== 'string') {
        return false;
    }
    // get the extension ("ext" or ".ext" or full path)
    var extension = extname('x.' + path).toLowerCase().substr(1);
    if (!extension) {
        return false;
    }
    return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */ function populateMaps(extensions, types) {
    // source preference (least -> most)
    var preference = [
        'nginx',
        'apache',
        undefined,
        'iana'
    ];
    Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
            return;
        }
        // mime -> extensions
        extensions[type] = exts;
        // extension -> mime
        for(var i = 0; i < exts.length; i++){
            var extension = exts[i];
            if (types[extension]) {
                var from = preference.indexOf(db[types[extension]].source);
                var to = preference.indexOf(mime.source);
                if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
                    continue;
                }
            }
            // set the extension -> mime
            types[extension] = type;
        }
    });
}
}}),
"[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = defer;
/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */ function defer(fn) {
    var nextTick = typeof setImmediate == 'function' ? setImmediate : typeof process == 'object' && typeof process.nextTick == 'function' ? process.nextTick : null;
    if (nextTick) {
        nextTick(fn);
    } else {
        setTimeout(fn, 0);
    }
}
}}),
"[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var defer = __turbopack_context__.r("[project]/node_modules/asynckit/lib/defer.js [app-route] (ecmascript)");
// API
module.exports = async;
/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */ function async(callback) {
    var isAsync = false;
    // check if async happened
    defer(function() {
        isAsync = true;
    });
    return function async_callback(err, result) {
        if (isAsync) {
            callback(err, result);
        } else {
            defer(function nextTick_callback() {
                callback(err, result);
            });
        }
    };
}
}}),
"[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// API
module.exports = abort;
/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */ function abort(state) {
    Object.keys(state.jobs).forEach(clean.bind(state));
    // reset leftover jobs
    state.jobs = {};
}
/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */ function clean(key) {
    if (typeof this.jobs[key] == 'function') {
        this.jobs[key]();
    }
}
}}),
"[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)"), abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)");
// API
module.exports = iterate;
/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */ function iterate(list, iterator, state, callback) {
    // store current index
    var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;
    state.jobs[key] = runJob(iterator, key, list[key], function(error, output) {
        // don't repeat yourself
        // skip secondary callbacks
        if (!(key in state.jobs)) {
            return;
        }
        // clean up jobs
        delete state.jobs[key];
        if (error) {
            // don't process rest of the results
            // stop still active jobs
            // and reset the list
            abort(state);
        } else {
            state.results[key] = output;
        }
        // return salvaged results
        callback(error, state.results);
    });
}
/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */ function runJob(iterator, key, item, callback) {
    var aborter;
    // allow shortcut if iterator expects only two arguments
    if (iterator.length == 2) {
        aborter = iterator(item, async(callback));
    } else {
        aborter = iterator(item, key, async(callback));
    }
    return aborter;
}
}}),
"[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// API
module.exports = state;
/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */ function state(list, sortMethod) {
    var isNamedList = !Array.isArray(list), initState = {
        index: 0,
        keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
        jobs: {},
        results: isNamedList ? {} : [],
        size: isNamedList ? Object.keys(list).length : list.length
    };
    if (sortMethod) {
        // sort array keys based on it's values
        // sort object's keys just on own merit
        initState.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
            return sortMethod(list[a], list[b]);
        });
    }
    return initState;
}
}}),
"[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var abort = __turbopack_context__.r("[project]/node_modules/asynckit/lib/abort.js [app-route] (ecmascript)"), async = __turbopack_context__.r("[project]/node_modules/asynckit/lib/async.js [app-route] (ecmascript)");
// API
module.exports = terminator;
/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */ function terminator(callback) {
    if (!Object.keys(this.jobs).length) {
        return;
    }
    // fast forward iteration index
    this.index = this.size;
    // abort jobs
    abort(this);
    // send back results we have so far
    async(callback)(null, this.results);
}
}}),
"[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = parallel;
/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function parallel(list, iterator, callback) {
    var state = initState(list);
    while(state.index < (state['keyedList'] || list).length){
        iterate(list, iterator, state, function(error, result) {
            if (error) {
                callback(error, result);
                return;
            }
            // looks like it's the last one
            if (Object.keys(state.jobs).length === 0) {
                callback(null, state.results);
                return;
            }
        });
        state.index++;
    }
    return terminator.bind(state, callback);
}
}}),
"[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var iterate = __turbopack_context__.r("[project]/node_modules/asynckit/lib/iterate.js [app-route] (ecmascript)"), initState = __turbopack_context__.r("[project]/node_modules/asynckit/lib/state.js [app-route] (ecmascript)"), terminator = __turbopack_context__.r("[project]/node_modules/asynckit/lib/terminator.js [app-route] (ecmascript)");
// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending = ascending;
module.exports.descending = descending;
/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serialOrdered(list, iterator, sortMethod, callback) {
    var state = initState(list, sortMethod);
    iterate(list, iterator, state, function iteratorHandler(error, result) {
        if (error) {
            callback(error, result);
            return;
        }
        state.index++;
        // are we there yet?
        if (state.index < (state['keyedList'] || list).length) {
            iterate(list, iterator, state, iteratorHandler);
            return;
        }
        // done here
        callback(null, state.results);
    });
    return terminator.bind(state, callback);
}
/*
 * -- Sort methods
 */ /**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}
/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */ function descending(a, b) {
    return -1 * ascending(a, b);
}
}}),
"[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var serialOrdered = __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)");
// Public API
module.exports = serial;
/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */ function serial(list, iterator, callback) {
    return serialOrdered(list, iterator, null, callback);
}
}}),
"[project]/node_modules/asynckit/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = {
    parallel: __turbopack_context__.r("[project]/node_modules/asynckit/parallel.js [app-route] (ecmascript)"),
    serial: __turbopack_context__.r("[project]/node_modules/asynckit/serial.js [app-route] (ecmascript)"),
    serialOrdered: __turbopack_context__.r("[project]/node_modules/asynckit/serialOrdered.js [app-route] (ecmascript)")
};
}}),
"[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ module.exports = Object;
}}),
"[project]/node_modules/es-errors/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ module.exports = Error;
}}),
"[project]/node_modules/es-errors/eval.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./eval')} */ module.exports = EvalError;
}}),
"[project]/node_modules/es-errors/range.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./range')} */ module.exports = RangeError;
}}),
"[project]/node_modules/es-errors/ref.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./ref')} */ module.exports = ReferenceError;
}}),
"[project]/node_modules/es-errors/syntax.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./syntax')} */ module.exports = SyntaxError;
}}),
"[project]/node_modules/es-errors/type.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./type')} */ module.exports = TypeError;
}}),
"[project]/node_modules/es-errors/uri.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./uri')} */ module.exports = URIError;
}}),
"[project]/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./abs')} */ module.exports = Math.abs;
}}),
"[project]/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./floor')} */ module.exports = Math.floor;
}}),
"[project]/node_modules/math-intrinsics/max.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./max')} */ module.exports = Math.max;
}}),
"[project]/node_modules/math-intrinsics/min.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./min')} */ module.exports = Math.min;
}}),
"[project]/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./pow')} */ module.exports = Math.pow;
}}),
"[project]/node_modules/math-intrinsics/round.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./round')} */ module.exports = Math.round;
}}),
"[project]/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./isNaN')} */ module.exports = Number.isNaN || function isNaN(a) {
    return a !== a;
};
}}),
"[project]/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var $isNaN = __turbopack_context__.r("[project]/node_modules/math-intrinsics/isNaN.js [app-route] (ecmascript)");
/** @type {import('./sign')} */ module.exports = function sign(number) {
    if ($isNaN(number) || number === 0) {
        return number;
    }
    return number < 0 ? -1 : +1;
};
}}),
"[project]/node_modules/gopd/gOPD.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./gOPD')} */ module.exports = Object.getOwnPropertyDescriptor;
}}),
"[project]/node_modules/gopd/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/gOPD.js [app-route] (ecmascript)");
if ($gOPD) {
    try {
        $gOPD([], 'length');
    } catch (e) {
        // IE 8 has a broken gOPD
        $gOPD = null;
    }
}
module.exports = $gOPD;
}}),
"[project]/node_modules/es-define-property/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('.')} */ var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
    try {
        $defineProperty({}, 'a', {
            value: 1
        });
    } catch (e) {
        // IE 8 has a broken defineProperty
        $defineProperty = false;
    }
}
module.exports = $defineProperty;
}}),
"[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./shams')} */ /* eslint complexity: [2, 18], max-statements: [2, 33] */ module.exports = function hasSymbols() {
    if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') {
        return false;
    }
    if (typeof Symbol.iterator === 'symbol') {
        return true;
    }
    /** @type {{ [k in symbol]?: unknown }} */ var obj = {};
    var sym = Symbol('test');
    var symObj = Object(sym);
    if (typeof sym === 'string') {
        return false;
    }
    if (Object.prototype.toString.call(sym) !== '[object Symbol]') {
        return false;
    }
    if (Object.prototype.toString.call(symObj) !== '[object Symbol]') {
        return false;
    }
    // temp disabled per https://github.com/ljharb/object.assign/issues/17
    // if (sym instanceof Symbol) { return false; }
    // temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
    // if (!(symObj instanceof Symbol)) { return false; }
    // if (typeof Symbol.prototype.toString !== 'function') { return false; }
    // if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }
    var symVal = 42;
    obj[sym] = symVal;
    for(var _ in obj){
        return false;
    } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
    if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) {
        return false;
    }
    if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
        return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === 'function') {
        // eslint-disable-next-line no-extra-parens
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
            return false;
        }
    }
    return true;
};
}}),
"[project]/node_modules/has-symbols/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== 'function') {
        return false;
    }
    if (typeof Symbol !== 'function') {
        return false;
    }
    if (typeof origSymbol('foo') !== 'symbol') {
        return false;
    }
    if (typeof Symbol('bar') !== 'symbol') {
        return false;
    }
    return hasSymbolSham();
};
}}),
"[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./Reflect.getPrototypeOf')} */ module.exports = typeof Reflect !== 'undefined' && Reflect.getPrototypeOf || null;
}}),
"[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
/** @type {import('./Object.getPrototypeOf')} */ module.exports = $Object.getPrototypeOf || null;
}}),
"[project]/node_modules/get-proto/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var reflectGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var originalGetProto = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var getDunderProto = __turbopack_context__.r("[project]/node_modules/dunder-proto/get.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = reflectGetProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return reflectGetProto(O);
} : originalGetProto ? function getProto(O) {
    if (!O || typeof O !== 'object' && typeof O !== 'function') {
        throw new TypeError('getProto: not an object');
    }
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return originalGetProto(O);
} : getDunderProto ? function getProto(O) {
    // @ts-expect-error TS can't narrow inside a closure, for some reason
    return getDunderProto(O);
} : null;
}}),
"[project]/node_modules/function-bind/implementation.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/* eslint no-invalid-this: 1 */ var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';
var concatty = function concatty(a, b) {
    var arr = [];
    for(var i = 0; i < a.length; i += 1){
        arr[i] = a[i];
    }
    for(var j = 0; j < b.length; j += 1){
        arr[j + a.length] = b[j];
    }
    return arr;
};
var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for(var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1){
        arr[j] = arrLike[i];
    }
    return arr;
};
var joiny = function(arr, joiner) {
    var str = '';
    for(var i = 0; i < arr.length; i += 1){
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};
module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
        if (this instanceof bound) {
            var result = target.apply(this, concatty(args, arguments));
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(that, concatty(args, arguments));
    };
    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for(var i = 0; i < boundLength; i++){
        boundArgs[i] = '$' + i;
    }
    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);
    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }
    return bound;
};
}}),
"[project]/node_modules/function-bind/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var implementation = __turbopack_context__.r("[project]/node_modules/function-bind/implementation.js [app-route] (ecmascript)");
module.exports = Function.prototype.bind || implementation;
}}),
"[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./functionCall')} */ module.exports = Function.prototype.call;
}}),
"[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./functionApply')} */ module.exports = Function.prototype.apply;
}}),
"[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
/** @type {import('./reflectApply')} */ module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;
}}),
"[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $reflectApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/reflectApply.js [app-route] (ecmascript)");
/** @type {import('./actualApply')} */ module.exports = $reflectApply || bind.call($call, $apply);
}}),
"[project]/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var $actualApply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/actualApply.js [app-route] (ecmascript)");
/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */ module.exports = function callBindBasic(args) {
    if (args.length < 1 || typeof args[0] !== 'function') {
        throw new $TypeError('a function is required');
    }
    return $actualApply(bind, $call, args);
};
}}),
"[project]/node_modules/dunder-proto/get.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var callBind = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/index.js [app-route] (ecmascript)");
var gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-route] (ecmascript)");
var hasProtoAccessor;
try {
    // eslint-disable-next-line no-extra-parens, no-proto
    hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ [].__proto__ === Array.prototype;
} catch (e) {
    if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
        throw e;
    }
}
// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, '__proto__');
var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;
/** @type {import('./get')} */ module.exports = desc && typeof desc.get === 'function' ? callBind([
    desc.get
]) : typeof $getPrototypeOf === 'function' ? /** @type {import('./get')} */ function getDunder(value) {
    // eslint-disable-next-line eqeqeq
    return $getPrototypeOf(value == null ? value : $Object(value));
} : false;
}}),
"[project]/node_modules/hasown/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = bind.call(call, $hasOwn);
}}),
"[project]/node_modules/get-intrinsic/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var undefined1;
var $Object = __turbopack_context__.r("[project]/node_modules/es-object-atoms/index.js [app-route] (ecmascript)");
var $Error = __turbopack_context__.r("[project]/node_modules/es-errors/index.js [app-route] (ecmascript)");
var $EvalError = __turbopack_context__.r("[project]/node_modules/es-errors/eval.js [app-route] (ecmascript)");
var $RangeError = __turbopack_context__.r("[project]/node_modules/es-errors/range.js [app-route] (ecmascript)");
var $ReferenceError = __turbopack_context__.r("[project]/node_modules/es-errors/ref.js [app-route] (ecmascript)");
var $SyntaxError = __turbopack_context__.r("[project]/node_modules/es-errors/syntax.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var $URIError = __turbopack_context__.r("[project]/node_modules/es-errors/uri.js [app-route] (ecmascript)");
var abs = __turbopack_context__.r("[project]/node_modules/math-intrinsics/abs.js [app-route] (ecmascript)");
var floor = __turbopack_context__.r("[project]/node_modules/math-intrinsics/floor.js [app-route] (ecmascript)");
var max = __turbopack_context__.r("[project]/node_modules/math-intrinsics/max.js [app-route] (ecmascript)");
var min = __turbopack_context__.r("[project]/node_modules/math-intrinsics/min.js [app-route] (ecmascript)");
var pow = __turbopack_context__.r("[project]/node_modules/math-intrinsics/pow.js [app-route] (ecmascript)");
var round = __turbopack_context__.r("[project]/node_modules/math-intrinsics/round.js [app-route] (ecmascript)");
var sign = __turbopack_context__.r("[project]/node_modules/math-intrinsics/sign.js [app-route] (ecmascript)");
var $Function = Function;
// eslint-disable-next-line consistent-return
var getEvalledConstructor = function(expressionSyntax) {
    try {
        return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
    } catch (e) {}
};
var $gOPD = __turbopack_context__.r("[project]/node_modules/gopd/index.js [app-route] (ecmascript)");
var $defineProperty = __turbopack_context__.r("[project]/node_modules/es-define-property/index.js [app-route] (ecmascript)");
var throwTypeError = function() {
    throw new $TypeError();
};
var ThrowTypeError = $gOPD ? function() {
    try {
        // eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
        arguments.callee; // IE 8 does not throw here
        return throwTypeError;
    } catch (calleeThrows) {
        try {
            // IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
            return $gOPD(arguments, 'callee').get;
        } catch (gOPDthrows) {
            return throwTypeError;
        }
    }
}() : throwTypeError;
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/index.js [app-route] (ecmascript)")();
var getProto = __turbopack_context__.r("[project]/node_modules/get-proto/index.js [app-route] (ecmascript)");
var $ObjectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Object.getPrototypeOf.js [app-route] (ecmascript)");
var $ReflectGPO = __turbopack_context__.r("[project]/node_modules/get-proto/Reflect.getPrototypeOf.js [app-route] (ecmascript)");
var $apply = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionApply.js [app-route] (ecmascript)");
var $call = __turbopack_context__.r("[project]/node_modules/call-bind-apply-helpers/functionCall.js [app-route] (ecmascript)");
var needsEval = {};
var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);
var INTRINSICS = {
    __proto__: null,
    '%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
    '%Array%': Array,
    '%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
    '%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
    '%AsyncFromSyncIteratorPrototype%': undefined,
    '%AsyncFunction%': needsEval,
    '%AsyncGenerator%': needsEval,
    '%AsyncGeneratorFunction%': needsEval,
    '%AsyncIteratorPrototype%': needsEval,
    '%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
    '%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
    '%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
    '%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
    '%Boolean%': Boolean,
    '%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
    '%Date%': Date,
    '%decodeURI%': decodeURI,
    '%decodeURIComponent%': decodeURIComponent,
    '%encodeURI%': encodeURI,
    '%encodeURIComponent%': encodeURIComponent,
    '%Error%': $Error,
    '%eval%': eval,
    '%EvalError%': $EvalError,
    '%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
    '%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
    '%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
    '%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
    '%Function%': $Function,
    '%GeneratorFunction%': needsEval,
    '%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
    '%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
    '%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
    '%isFinite%': isFinite,
    '%isNaN%': isNaN,
    '%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
    '%JSON%': typeof JSON === 'object' ? JSON : undefined,
    '%Map%': typeof Map === 'undefined' ? undefined : Map,
    '%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
    '%Math%': Math,
    '%Number%': Number,
    '%Object%': $Object,
    '%Object.getOwnPropertyDescriptor%': $gOPD,
    '%parseFloat%': parseFloat,
    '%parseInt%': parseInt,
    '%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
    '%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
    '%RangeError%': $RangeError,
    '%ReferenceError%': $ReferenceError,
    '%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
    '%RegExp%': RegExp,
    '%Set%': typeof Set === 'undefined' ? undefined : Set,
    '%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
    '%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
    '%String%': String,
    '%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
    '%Symbol%': hasSymbols ? Symbol : undefined,
    '%SyntaxError%': $SyntaxError,
    '%ThrowTypeError%': ThrowTypeError,
    '%TypedArray%': TypedArray,
    '%TypeError%': $TypeError,
    '%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
    '%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
    '%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
    '%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
    '%URIError%': $URIError,
    '%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
    '%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
    '%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,
    '%Function.prototype.call%': $call,
    '%Function.prototype.apply%': $apply,
    '%Object.defineProperty%': $defineProperty,
    '%Object.getPrototypeOf%': $ObjectGPO,
    '%Math.abs%': abs,
    '%Math.floor%': floor,
    '%Math.max%': max,
    '%Math.min%': min,
    '%Math.pow%': pow,
    '%Math.round%': round,
    '%Math.sign%': sign,
    '%Reflect.getPrototypeOf%': $ReflectGPO
};
if (getProto) {
    try {
        null.error; // eslint-disable-line no-unused-expressions
    } catch (e) {
        // https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
        var errorProto = getProto(getProto(e));
        INTRINSICS['%Error.prototype%'] = errorProto;
    }
}
var doEval = function doEval(name) {
    var value;
    if (name === '%AsyncFunction%') {
        value = getEvalledConstructor('async function () {}');
    } else if (name === '%GeneratorFunction%') {
        value = getEvalledConstructor('function* () {}');
    } else if (name === '%AsyncGeneratorFunction%') {
        value = getEvalledConstructor('async function* () {}');
    } else if (name === '%AsyncGenerator%') {
        var fn = doEval('%AsyncGeneratorFunction%');
        if (fn) {
            value = fn.prototype;
        }
    } else if (name === '%AsyncIteratorPrototype%') {
        var gen = doEval('%AsyncGenerator%');
        if (gen && getProto) {
            value = getProto(gen.prototype);
        }
    }
    INTRINSICS[name] = value;
    return value;
};
var LEGACY_ALIASES = {
    __proto__: null,
    '%ArrayBufferPrototype%': [
        'ArrayBuffer',
        'prototype'
    ],
    '%ArrayPrototype%': [
        'Array',
        'prototype'
    ],
    '%ArrayProto_entries%': [
        'Array',
        'prototype',
        'entries'
    ],
    '%ArrayProto_forEach%': [
        'Array',
        'prototype',
        'forEach'
    ],
    '%ArrayProto_keys%': [
        'Array',
        'prototype',
        'keys'
    ],
    '%ArrayProto_values%': [
        'Array',
        'prototype',
        'values'
    ],
    '%AsyncFunctionPrototype%': [
        'AsyncFunction',
        'prototype'
    ],
    '%AsyncGenerator%': [
        'AsyncGeneratorFunction',
        'prototype'
    ],
    '%AsyncGeneratorPrototype%': [
        'AsyncGeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%BooleanPrototype%': [
        'Boolean',
        'prototype'
    ],
    '%DataViewPrototype%': [
        'DataView',
        'prototype'
    ],
    '%DatePrototype%': [
        'Date',
        'prototype'
    ],
    '%ErrorPrototype%': [
        'Error',
        'prototype'
    ],
    '%EvalErrorPrototype%': [
        'EvalError',
        'prototype'
    ],
    '%Float32ArrayPrototype%': [
        'Float32Array',
        'prototype'
    ],
    '%Float64ArrayPrototype%': [
        'Float64Array',
        'prototype'
    ],
    '%FunctionPrototype%': [
        'Function',
        'prototype'
    ],
    '%Generator%': [
        'GeneratorFunction',
        'prototype'
    ],
    '%GeneratorPrototype%': [
        'GeneratorFunction',
        'prototype',
        'prototype'
    ],
    '%Int8ArrayPrototype%': [
        'Int8Array',
        'prototype'
    ],
    '%Int16ArrayPrototype%': [
        'Int16Array',
        'prototype'
    ],
    '%Int32ArrayPrototype%': [
        'Int32Array',
        'prototype'
    ],
    '%JSONParse%': [
        'JSON',
        'parse'
    ],
    '%JSONStringify%': [
        'JSON',
        'stringify'
    ],
    '%MapPrototype%': [
        'Map',
        'prototype'
    ],
    '%NumberPrototype%': [
        'Number',
        'prototype'
    ],
    '%ObjectPrototype%': [
        'Object',
        'prototype'
    ],
    '%ObjProto_toString%': [
        'Object',
        'prototype',
        'toString'
    ],
    '%ObjProto_valueOf%': [
        'Object',
        'prototype',
        'valueOf'
    ],
    '%PromisePrototype%': [
        'Promise',
        'prototype'
    ],
    '%PromiseProto_then%': [
        'Promise',
        'prototype',
        'then'
    ],
    '%Promise_all%': [
        'Promise',
        'all'
    ],
    '%Promise_reject%': [
        'Promise',
        'reject'
    ],
    '%Promise_resolve%': [
        'Promise',
        'resolve'
    ],
    '%RangeErrorPrototype%': [
        'RangeError',
        'prototype'
    ],
    '%ReferenceErrorPrototype%': [
        'ReferenceError',
        'prototype'
    ],
    '%RegExpPrototype%': [
        'RegExp',
        'prototype'
    ],
    '%SetPrototype%': [
        'Set',
        'prototype'
    ],
    '%SharedArrayBufferPrototype%': [
        'SharedArrayBuffer',
        'prototype'
    ],
    '%StringPrototype%': [
        'String',
        'prototype'
    ],
    '%SymbolPrototype%': [
        'Symbol',
        'prototype'
    ],
    '%SyntaxErrorPrototype%': [
        'SyntaxError',
        'prototype'
    ],
    '%TypedArrayPrototype%': [
        'TypedArray',
        'prototype'
    ],
    '%TypeErrorPrototype%': [
        'TypeError',
        'prototype'
    ],
    '%Uint8ArrayPrototype%': [
        'Uint8Array',
        'prototype'
    ],
    '%Uint8ClampedArrayPrototype%': [
        'Uint8ClampedArray',
        'prototype'
    ],
    '%Uint16ArrayPrototype%': [
        'Uint16Array',
        'prototype'
    ],
    '%Uint32ArrayPrototype%': [
        'Uint32Array',
        'prototype'
    ],
    '%URIErrorPrototype%': [
        'URIError',
        'prototype'
    ],
    '%WeakMapPrototype%': [
        'WeakMap',
        'prototype'
    ],
    '%WeakSetPrototype%': [
        'WeakSet',
        'prototype'
    ]
};
var bind = __turbopack_context__.r("[project]/node_modules/function-bind/index.js [app-route] (ecmascript)");
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);
/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */ var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */ 
var stringToPath = function stringToPath(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === '%' && last !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
    } else if (last === '%' && first !== '%') {
        throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
    });
    return result;
};
/* end adaptation */ var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = '%' + alias[0] + '%';
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
            value = doEval(intrinsicName);
        }
        if (typeof value === 'undefined' && !allowMissing) {
            throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
        }
        return {
            alias: alias,
            name: intrinsicName,
            value: value
        };
    }
    throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};
module.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== 'string' || name.length === 0) {
        throw new $TypeError('intrinsic name must be a non-empty string');
    }
    if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
        throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : '';
    var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([
            0,
            1
        ], alias));
    }
    for(var i = 1, isOwn = true; i < parts.length; i += 1){
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === '`' || last === '"' || last === "'" || last === '`') && first !== last) {
            throw new $SyntaxError('property names with quotes must have matching quotes');
        }
        if (part === 'constructor' || !isOwn) {
            skipFurtherCaching = true;
        }
        intrinsicBaseName += '.' + part;
        intrinsicRealName = '%' + intrinsicBaseName + '%';
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
            value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
            if (!(part in value)) {
                if (!allowMissing) {
                    throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
                }
                return void undefined;
            }
            if ($gOPD && i + 1 >= parts.length) {
                var desc = $gOPD(value, part);
                isOwn = !!desc;
                // By convention, when a data property is converted to an accessor
                // property to emulate a data property that does not suffer from
                // the override mistake, that accessor's getter is marked with
                // an `originalValue` property. Here, when we detect this, we
                // uphold the illusion by pretending to see that original data
                // property, i.e., returning the value rather than the getter
                // itself.
                if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
                    value = desc.get;
                } else {
                    value = value[part];
                }
            } else {
                isOwn = hasOwn(value, part);
                value = value[part];
            }
            if (isOwn && !skipFurtherCaching) {
                INTRINSICS[intrinsicRealName] = value;
            }
        }
    }
    return value;
};
}}),
"[project]/node_modules/has-tostringtag/shams.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var hasSymbols = __turbopack_context__.r("[project]/node_modules/has-symbols/shams.js [app-route] (ecmascript)");
/** @type {import('.')} */ module.exports = function hasToStringTagShams() {
    return hasSymbols() && !!Symbol.toStringTag;
};
}}),
"[project]/node_modules/es-set-tostringtag/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var GetIntrinsic = __turbopack_context__.r("[project]/node_modules/get-intrinsic/index.js [app-route] (ecmascript)");
var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);
var hasToStringTag = __turbopack_context__.r("[project]/node_modules/has-tostringtag/shams.js [app-route] (ecmascript)")();
var hasOwn = __turbopack_context__.r("[project]/node_modules/hasown/index.js [app-route] (ecmascript)");
var $TypeError = __turbopack_context__.r("[project]/node_modules/es-errors/type.js [app-route] (ecmascript)");
var toStringTag = hasToStringTag ? Symbol.toStringTag : null;
/** @type {import('.')} */ module.exports = function setToStringTag(object, value) {
    var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
    var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
    if (typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean' || typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean') {
        throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
    }
    if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
        if ($defineProperty) {
            $defineProperty(object, toStringTag, {
                configurable: !nonConfigurable,
                enumerable: false,
                value: value,
                writable: false
            });
        } else {
            object[toStringTag] = value; // eslint-disable-line no-param-reassign
        }
    }
};
}}),
"[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
// populates missing values
module.exports = function(dst, src) {
    Object.keys(src).forEach(function(prop) {
        dst[prop] = dst[prop] || src[prop];
    });
    return dst;
};
}}),
"[project]/node_modules/form-data/lib/form_data.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var CombinedStream = __turbopack_context__.r("[project]/node_modules/combined-stream/lib/combined_stream.js [app-route] (ecmascript)");
var util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
var path = __turbopack_context__.r("[externals]/path [external] (path, cjs)");
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var fs = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
var Stream = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Stream;
var mime = __turbopack_context__.r("[project]/node_modules/mime-types/index.js [app-route] (ecmascript)");
var asynckit = __turbopack_context__.r("[project]/node_modules/asynckit/index.js [app-route] (ecmascript)");
var setToStringTag = __turbopack_context__.r("[project]/node_modules/es-set-tostringtag/index.js [app-route] (ecmascript)");
var populate = __turbopack_context__.r("[project]/node_modules/form-data/lib/populate.js [app-route] (ecmascript)");
// Public API
module.exports = FormData;
// make it a Stream
util.inherits(FormData, CombinedStream);
/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */ function FormData(options) {
    if (!(this instanceof FormData)) {
        return new FormData(options);
    }
    this._overheadLength = 0;
    this._valueLength = 0;
    this._valuesToMeasure = [];
    CombinedStream.call(this);
    options = options || {};
    for(var option in options){
        this[option] = options[option];
    }
}
FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';
FormData.prototype.append = function(field, value, options) {
    options = options || {};
    // allow filename as single option
    if (typeof options == 'string') {
        options = {
            filename: options
        };
    }
    var append = CombinedStream.prototype.append.bind(this);
    // all that streamy business can't handle numbers
    if (typeof value == 'number') {
        value = '' + value;
    }
    // https://github.com/felixge/node-form-data/issues/38
    if (Array.isArray(value)) {
        // Please convert your array into string
        // the way web server expects it
        this._error(new Error('Arrays are not supported.'));
        return;
    }
    var header = this._multiPartHeader(field, value, options);
    var footer = this._multiPartFooter();
    append(header);
    append(value);
    append(footer);
    // pass along options.knownLength
    this._trackLength(header, value, options);
};
FormData.prototype._trackLength = function(header, value, options) {
    var valueLength = 0;
    // used w/ getLengthSync(), when length is known.
    // e.g. for streaming directly from a remote server,
    // w/ a known file a size, and not wanting to wait for
    // incoming file to finish to get its size.
    if (options.knownLength != null) {
        valueLength += +options.knownLength;
    } else if (Buffer.isBuffer(value)) {
        valueLength = value.length;
    } else if (typeof value === 'string') {
        valueLength = Buffer.byteLength(value);
    }
    this._valueLength += valueLength;
    // @check why add CRLF? does this account for custom/multiple CRLFs?
    this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;
    // empty or either doesn't have path or not an http response or not a stream
    if (!value || !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) && !(value instanceof Stream)) {
        return;
    }
    // no need to bother with the length
    if (!options.knownLength) {
        this._valuesToMeasure.push(value);
    }
};
FormData.prototype._lengthRetriever = function(value, callback) {
    if (Object.prototype.hasOwnProperty.call(value, 'fd')) {
        // take read range into a account
        // `end` = Infinity –> read file till the end
        //
        // TODO: Looks like there is bug in Node fs.createReadStream
        // it doesn't respect `end` options without `start` options
        // Fix it when node fixes it.
        // https://github.com/joyent/node/issues/7819
        if (value.end != undefined && value.end != Infinity && value.start != undefined) {
            // when end specified
            // no need to calculate range
            // inclusive, starts with 0
            callback(null, value.end + 1 - (value.start ? value.start : 0));
        // not that fast snoopy
        } else {
            // still need to fetch file size from fs
            fs.stat(value.path, function(err, stat) {
                var fileSize;
                if (err) {
                    callback(err);
                    return;
                }
                // update final size based on the range options
                fileSize = stat.size - (value.start ? value.start : 0);
                callback(null, fileSize);
            });
        }
    // or http response
    } else if (Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
        callback(null, +value.headers['content-length']);
    // or request stream http://github.com/mikeal/request
    } else if (Object.prototype.hasOwnProperty.call(value, 'httpModule')) {
        // wait till response come back
        value.on('response', function(response) {
            value.pause();
            callback(null, +response.headers['content-length']);
        });
        value.resume();
    // something else
    } else {
        callback('Unknown stream');
    }
};
FormData.prototype._multiPartHeader = function(field, value, options) {
    // custom header specified (as string)?
    // it becomes responsible for boundary
    // (e.g. to handle extra CRLFs on .NET servers)
    if (typeof options.header == 'string') {
        return options.header;
    }
    var contentDisposition = this._getContentDisposition(value, options);
    var contentType = this._getContentType(value, options);
    var contents = '';
    var headers = {
        // add custom disposition as third element or keep it two elements if not
        'Content-Disposition': [
            'form-data',
            'name="' + field + '"'
        ].concat(contentDisposition || []),
        // if no content type. allow it to be empty array
        'Content-Type': [].concat(contentType || [])
    };
    // allow custom headers.
    if (typeof options.header == 'object') {
        populate(headers, options.header);
    }
    var header;
    for(var prop in headers){
        if (Object.prototype.hasOwnProperty.call(headers, prop)) {
            header = headers[prop];
            // skip nullish headers.
            if (header == null) {
                continue;
            }
            // convert all headers to arrays.
            if (!Array.isArray(header)) {
                header = [
                    header
                ];
            }
            // add non-empty headers.
            if (header.length) {
                contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
            }
        }
    }
    return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};
FormData.prototype._getContentDisposition = function(value, options) {
    var filename, contentDisposition;
    if (typeof options.filepath === 'string') {
        // custom filepath for relative paths
        filename = path.normalize(options.filepath).replace(/\\/g, '/');
    } else if (options.filename || value.name || value.path) {
        // custom filename take precedence
        // formidable and the browser add a name property
        // fs- and request- streams have path property
        filename = path.basename(options.filename || value.name || value.path);
    } else if (value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
        // or try http response
        filename = path.basename(value.client._httpMessage.path || '');
    }
    if (filename) {
        contentDisposition = 'filename="' + filename + '"';
    }
    return contentDisposition;
};
FormData.prototype._getContentType = function(value, options) {
    // use custom content-type above all
    var contentType = options.contentType;
    // or try `name` from formidable, browser
    if (!contentType && value.name) {
        contentType = mime.lookup(value.name);
    }
    // or try `path` from fs-, request- streams
    if (!contentType && value.path) {
        contentType = mime.lookup(value.path);
    }
    // or if it's http-reponse
    if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
        contentType = value.headers['content-type'];
    }
    // or guess it from the filepath or filename
    if (!contentType && (options.filepath || options.filename)) {
        contentType = mime.lookup(options.filepath || options.filename);
    }
    // fallback to the default content type if `value` is not simple value
    if (!contentType && typeof value == 'object') {
        contentType = FormData.DEFAULT_CONTENT_TYPE;
    }
    return contentType;
};
FormData.prototype._multiPartFooter = function() {
    return (function(next) {
        var footer = FormData.LINE_BREAK;
        var lastPart = this._streams.length === 0;
        if (lastPart) {
            footer += this._lastBoundary();
        }
        next(footer);
    }).bind(this);
};
FormData.prototype._lastBoundary = function() {
    return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};
FormData.prototype.getHeaders = function(userHeaders) {
    var header;
    var formHeaders = {
        'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
    };
    for(header in userHeaders){
        if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
            formHeaders[header.toLowerCase()] = userHeaders[header];
        }
    }
    return formHeaders;
};
FormData.prototype.setBoundary = function(boundary) {
    this._boundary = boundary;
};
FormData.prototype.getBoundary = function() {
    if (!this._boundary) {
        this._generateBoundary();
    }
    return this._boundary;
};
FormData.prototype.getBuffer = function() {
    var dataBuffer = new Buffer.alloc(0);
    var boundary = this.getBoundary();
    // Create the form content. Add Line breaks to the end of data.
    for(var i = 0, len = this._streams.length; i < len; i++){
        if (typeof this._streams[i] !== 'function') {
            // Add content to the buffer.
            if (Buffer.isBuffer(this._streams[i])) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    this._streams[i]
                ]);
            } else {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(this._streams[i])
                ]);
            }
            // Add break after content.
            if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
                dataBuffer = Buffer.concat([
                    dataBuffer,
                    Buffer.from(FormData.LINE_BREAK)
                ]);
            }
        }
    }
    // Add the footer and return the Buffer object.
    return Buffer.concat([
        dataBuffer,
        Buffer.from(this._lastBoundary())
    ]);
};
FormData.prototype._generateBoundary = function() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    var boundary = '--------------------------';
    for(var i = 0; i < 24; i++){
        boundary += Math.floor(Math.random() * 10).toString(16);
    }
    this._boundary = boundary;
};
// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
    var knownLength = this._overheadLength + this._valueLength;
    // Don't get confused, there are 3 "internal" streams for each keyval pair
    // so it basically checks if there is any value added to the form
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    // https://github.com/form-data/form-data/issues/40
    if (!this.hasKnownLength()) {
        // Some async length retrievers are present
        // therefore synchronous length calculation is false.
        // Please use getLength(callback) to get proper length
        this._error(new Error('Cannot calculate proper length in synchronous way.'));
    }
    return knownLength;
};
// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
    var hasKnownLength = true;
    if (this._valuesToMeasure.length) {
        hasKnownLength = false;
    }
    return hasKnownLength;
};
FormData.prototype.getLength = function(cb) {
    var knownLength = this._overheadLength + this._valueLength;
    if (this._streams.length) {
        knownLength += this._lastBoundary().length;
    }
    if (!this._valuesToMeasure.length) {
        process.nextTick(cb.bind(this, null, knownLength));
        return;
    }
    asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
        if (err) {
            cb(err);
            return;
        }
        values.forEach(function(length) {
            knownLength += length;
        });
        cb(null, knownLength);
    });
};
FormData.prototype.submit = function(params, cb) {
    var request, options, defaults = {
        method: 'post'
    };
    // parse provided url if it's string
    // or treat it as options object
    if (typeof params == 'string') {
        params = parseUrl(params);
        options = populate({
            port: params.port,
            path: params.pathname,
            host: params.hostname,
            protocol: params.protocol
        }, defaults);
    // use custom params
    } else {
        options = populate(params, defaults);
        // if no port provided use default one
        if (!options.port) {
            options.port = options.protocol == 'https:' ? 443 : 80;
        }
    }
    // put that good code in getHeaders to some use
    options.headers = this.getHeaders(params.headers);
    // https if specified, fallback to http in any other case
    if (options.protocol == 'https:') {
        request = https.request(options);
    } else {
        request = http.request(options);
    }
    // get content length and fire away
    this.getLength((function(err, length) {
        if (err && err !== 'Unknown stream') {
            this._error(err);
            return;
        }
        // add content length
        if (length) {
            request.setHeader('Content-Length', length);
        }
        this.pipe(request);
        if (cb) {
            var onResponse;
            var callback = function(error, responce) {
                request.removeListener('error', callback);
                request.removeListener('response', onResponse);
                return cb.call(this, error, responce);
            };
            onResponse = callback.bind(this, null);
            request.on('error', callback);
            request.on('response', onResponse);
        }
    }).bind(this));
    return request;
};
FormData.prototype._error = function(err) {
    if (!this.error) {
        this.error = err;
        this.pause();
        this.emit('error', err);
    }
};
FormData.prototype.toString = function() {
    return '[object FormData]';
};
setToStringTag(FormData, 'FormData');
}}),
"[project]/node_modules/proxy-from-env/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
var parseUrl = __turbopack_context__.r("[externals]/url [external] (url, cjs)").parse;
var DEFAULT_PORTS = {
    ftp: 21,
    gopher: 70,
    http: 80,
    https: 443,
    ws: 80,
    wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s) {
    return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
};
/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */ function getProxyForUrl(url) {
    var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
    var proto = parsedUrl.protocol;
    var hostname = parsedUrl.host;
    var port = parsedUrl.port;
    if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
        return ''; // Don't proxy URLs without a valid scheme or host.
    }
    proto = proto.split(':', 1)[0];
    // Stripping ports in this way instead of using parsedUrl.hostname to make
    // sure that the brackets around IPv6 addresses are kept.
    hostname = hostname.replace(/:\d*$/, '');
    port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
    if (!shouldProxy(hostname, port)) {
        return ''; // Don't proxy URLs that match NO_PROXY.
    }
    var proxy = getEnv('npm_config_' + proto + '_proxy') || getEnv(proto + '_proxy') || getEnv('npm_config_proxy') || getEnv('all_proxy');
    if (proxy && proxy.indexOf('://') === -1) {
        // Missing scheme in proxy, default to the requested URL's scheme.
        proxy = proto + '://' + proxy;
    }
    return proxy;
}
/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */ function shouldProxy(hostname, port) {
    var NO_PROXY = (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
    if (!NO_PROXY) {
        return true; // Always proxy if NO_PROXY is not set.
    }
    if (NO_PROXY === '*') {
        return false; // Never proxy if wildcard is set.
    }
    return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
            return true; // Skip zero-length hosts.
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
            return true; // Skip if ports don't match.
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
            // No wildcards, so stop proxying if there is an exact match.
            return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === '*') {
            // Remove leading wildcard.
            parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        // Stop proxying if the hostname ends with the no_proxy host.
        return !stringEndsWith.call(hostname, parsedProxyHostname);
    });
}
/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */ function getEnv(key) {
    return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}
exports.getProxyForUrl = getProxyForUrl;
}}),
"[project]/node_modules/ms/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Helpers.
 */ var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */ module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
        return parse(val);
    } else if (type === 'number' && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */ function parse(str) {
    str = String(str);
    if (str.length > 100) {
        return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
        return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch(type){
        case 'years':
        case 'year':
        case 'yrs':
        case 'yr':
        case 'y':
            return n * y;
        case 'weeks':
        case 'week':
        case 'w':
            return n * w;
        case 'days':
        case 'day':
        case 'd':
            return n * d;
        case 'hours':
        case 'hour':
        case 'hrs':
        case 'hr':
        case 'h':
            return n * h;
        case 'minutes':
        case 'minute':
        case 'mins':
        case 'min':
        case 'm':
            return n * m;
        case 'seconds':
        case 'second':
        case 'secs':
        case 'sec':
        case 's':
            return n * s;
        case 'milliseconds':
        case 'millisecond':
        case 'msecs':
        case 'msec':
        case 'ms':
            return n;
        default:
            return undefined;
    }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
        return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
        return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
        return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */ function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
        return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
        return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
        return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
        return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
}
/**
 * Pluralization helper.
 */ function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}
}}),
"[project]/node_modules/debug/src/common.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */ function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = __turbopack_context__.r("[project]/node_modules/ms/index.js [app-route] (ecmascript)");
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key)=>{
        createDebug[key] = env[key];
    });
    /**
	* The currently active debug mode names, and names to skip.
	*/ createDebug.names = [];
    createDebug.skips = [];
    /**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/ createDebug.formatters = {};
    /**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/ function selectColor(namespace) {
        let hash = 0;
        for(let i = 0; i < namespace.length; i++){
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0; // Convert to 32bit integer
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    /**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/ function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
            // Disabled?
            if (!debug.enabled) {
                return;
            }
            const self = debug;
            // Set `diff` timestamp
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== 'string') {
                // Anything else let's inspect with %O
                args.unshift('%O');
            }
            // Apply any `formatters` transformations
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format)=>{
                // If we encounter an escaped % then don't increase the array index
                if (match === '%%') {
                    return '%';
                }
                index++;
                const formatter = createDebug.formatters[format];
                if (typeof formatter === 'function') {
                    const val = args[index];
                    match = formatter.call(self, val);
                    // Now we need to remove `args[index]` since it's inlined in the `format`
                    args.splice(index, 1);
                    index--;
                }
                return match;
            });
            // Apply env-specific formatting (colors, etc.)
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
        Object.defineProperty(debug, 'enabled', {
            enumerable: true,
            configurable: false,
            get: ()=>{
                if (enableOverride !== null) {
                    return enableOverride;
                }
                if (namespacesCache !== createDebug.namespaces) {
                    namespacesCache = createDebug.namespaces;
                    enabledCache = createDebug.enabled(namespace);
                }
                return enabledCache;
            },
            set: (v)=>{
                enableOverride = v;
            }
        });
        // Env-specific initialization logic for debug instances
        if (typeof createDebug.init === 'function') {
            createDebug.init(debug);
        }
        return debug;
    }
    function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
    }
    /**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/ function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === 'string' ? namespaces : '').trim().replace(' ', ',').split(',').filter(Boolean);
        for (const ns of split){
            if (ns[0] === '-') {
                createDebug.skips.push(ns.slice(1));
            } else {
                createDebug.names.push(ns);
            }
        }
    }
    /**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */ function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while(searchIndex < search.length){
            if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
                // Match character or proceed with wildcard
                if (template[templateIndex] === '*') {
                    starIndex = templateIndex;
                    matchIndex = searchIndex;
                    templateIndex++; // Skip the '*'
                } else {
                    searchIndex++;
                    templateIndex++;
                }
            } else if (starIndex !== -1) {
                // Backtrack to the last '*' and try to match more characters
                templateIndex = starIndex + 1;
                matchIndex++;
                searchIndex = matchIndex;
            } else {
                return false; // No match
            }
        }
        // Handle trailing '*' in template
        while(templateIndex < template.length && template[templateIndex] === '*'){
            templateIndex++;
        }
        return templateIndex === template.length;
    }
    /**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/ function disable() {
        const namespaces = [
            ...createDebug.names,
            ...createDebug.skips.map((namespace)=>'-' + namespace)
        ].join(',');
        createDebug.enable('');
        return namespaces;
    }
    /**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/ function enabled(name) {
        for (const skip of createDebug.skips){
            if (matchesTemplate(name, skip)) {
                return false;
            }
        }
        for (const ns of createDebug.names){
            if (matchesTemplate(name, ns)) {
                return true;
            }
        }
        return false;
    }
    /**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/ function coerce(val) {
        if (val instanceof Error) {
            return val.stack || val.message;
        }
        return val;
    }
    /**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/ function destroy() {
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
    createDebug.enable(createDebug.load());
    return createDebug;
}
module.exports = setup;
}}),
"[project]/node_modules/debug/src/node.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Module dependencies.
 */ const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const util = __turbopack_context__.r("[externals]/util [external] (util, cjs)");
/**
 * This is the Node.js implementation of `debug()`.
 */ exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(()=>{}, 'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
/**
 * Colors.
 */ exports.colors = [
    6,
    2,
    3,
    4,
    5,
    1
];
try {
    // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
    // eslint-disable-next-line import/no-extraneous-dependencies
    const supportsColor = __turbopack_context__.r("[project]/node_modules/supports-color/index.js [app-route] (ecmascript)");
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
            20,
            21,
            26,
            27,
            32,
            33,
            38,
            39,
            40,
            41,
            42,
            43,
            44,
            45,
            56,
            57,
            62,
            63,
            68,
            69,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            92,
            93,
            98,
            99,
            112,
            113,
            128,
            129,
            134,
            135,
            148,
            149,
            160,
            161,
            162,
            163,
            164,
            165,
            166,
            167,
            168,
            169,
            170,
            171,
            172,
            173,
            178,
            179,
            184,
            185,
            196,
            197,
            198,
            199,
            200,
            201,
            202,
            203,
            204,
            205,
            206,
            207,
            208,
            209,
            214,
            215,
            220,
            221
        ];
    }
} catch (error) {
// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}
/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */ exports.inspectOpts = Object.keys(process.env).filter((key)=>{
    return /^debug_/i.test(key);
}).reduce((obj, key)=>{
    // Camel-case
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k)=>{
        return k.toUpperCase();
    });
    // Coerce string value into JS value
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
    } else if (val === 'null') {
        val = null;
    } else {
        val = Number(val);
    }
    obj[prop] = val;
    return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */ function useColors() {
    return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    const { namespace: name, useColors } = this;
    if (useColors) {
        const c = this.color;
        const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
        const prefix = `  ${colorCode};1m${name} \u001B[0m`;
        args[0] = prefix + args[0].split('\n').join('\n' + prefix);
        args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
    } else {
        args[0] = getDate() + name + ' ' + args[0];
    }
}
function getDate() {
    if (exports.inspectOpts.hideDate) {
        return '';
    }
    return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */ function log(...args) {
    return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    if (namespaces) {
        process.env.DEBUG = namespaces;
    } else {
        // If you set a process.env field to null or undefined, it gets cast to the
        // string 'null' or 'undefined'. Just delete instead.
        delete process.env.DEBUG;
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    return process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */ function init(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for(let i = 0; i < keys.length; i++){
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */ formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split('\n').map((str)=>str.trim()).join(' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */ formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
};
}}),
"[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/* eslint-env browser */ /**
 * This is the web browser implementation of `debug()`.
 */ exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (()=>{
    let warned = false;
    return ()=>{
        if (!warned) {
            warned = true;
            console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
        }
    };
})();
/**
 * Colors.
 */ exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */ // eslint-disable-next-line complexity
function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
    }
    let m;
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    // eslint-disable-next-line no-return-assign
    return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */ function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);
    if (!this.useColors) {
        return;
    }
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match)=>{
        if (match === '%%') {
            return;
        }
        index++;
        if (match === '%c') {
            // We only are interested in the *last* %c
            // (the user may have provided their own)
            lastC = index;
        }
    });
    args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */ exports.log = console.debug || console.log || (()=>{});
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */ function save(namespaces) {
    try {
        if (namespaces) {
            exports.storage.setItem('debug', namespaces);
        } else {
            exports.storage.removeItem('debug');
        }
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */ function load() {
    let r;
    try {
        r = exports.storage.getItem('debug');
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
        r = process.env.DEBUG;
    }
    return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */ function localstorage() {
    try {
        // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
        // The Browser also has localStorage in the global context.
        return localStorage;
    } catch (error) {
    // Swallow
    // XXX (@Qix-) should we be logging these?
    }
}
module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/common.js [app-route] (ecmascript)")(exports);
const { formatters } = module.exports;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */ formatters.j = function(v) {
    try {
        return JSON.stringify(v);
    } catch (error) {
        return '[UnexpectedJSONParseError]: ' + error.message;
    }
};
}}),
"[project]/node_modules/debug/src/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */ if (typeof process === 'undefined' || process.type === 'renderer' || ("TURBOPACK compile-time value", false) === true || process.__nwjs) {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/browser.js [app-route] (ecmascript)");
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/debug/src/node.js [app-route] (ecmascript)");
}
}}),
"[project]/node_modules/has-flag/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
module.exports = (flag, argv = process.argv)=>{
    const prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf('--');
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};
}}),
"[project]/node_modules/supports-color/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
'use strict';
const os = __turbopack_context__.r("[externals]/os [external] (os, cjs)");
const tty = __turbopack_context__.r("[externals]/tty [external] (tty, cjs)");
const hasFlag = __turbopack_context__.r("[project]/node_modules/has-flag/index.js [app-route] (ecmascript)");
const { env } = process;
let forceColor;
if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false') || hasFlag('color=never')) {
    forceColor = 0;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = 1;
}
if ('FORCE_COLOR' in env) {
    if (env.FORCE_COLOR === 'true') {
        forceColor = 1;
    } else if (env.FORCE_COLOR === 'false') {
        forceColor = 0;
    } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
}
function translateLevel(level) {
    if (level === 0) {
        return false;
    }
    return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
    };
}
function supportsColor(haveStream, streamIsTTY) {
    if (forceColor === 0) {
        return 0;
    }
    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
        return 3;
    }
    if (hasFlag('color=256')) {
        return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
        return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === 'dumb') {
        return min;
    }
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    if ('CI' in env) {
        if ([
            'TRAVIS',
            'CIRCLECI',
            'APPVEYOR',
            'GITLAB_CI',
            'GITHUB_ACTIONS',
            'BUILDKITE'
        ].some((sign)=>sign in env) || env.CI_NAME === 'codeship') {
            return 1;
        }
        return min;
    }
    if ('TEAMCITY_VERSION' in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === 'truecolor') {
        return 3;
    }
    if ('TERM_PROGRAM' in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);
        switch(env.TERM_PROGRAM){
            case 'iTerm.app':
                return version >= 3 ? 3 : 2;
            case 'Apple_Terminal':
                return 2;
        }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
    }
    if ('COLORTERM' in env) {
        return 1;
    }
    return min;
}
function getSupportLevel(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
}
module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};
}}),
"[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var debug;
module.exports = function() {
    if (!debug) {
        try {
            /* eslint global-require: off */ debug = __turbopack_context__.r("[project]/node_modules/debug/src/index.js [app-route] (ecmascript)")("follow-redirects");
        } catch (error) {}
        if (typeof debug !== "function") {
            debug = function() {};
        }
    }
    debug.apply(null, arguments);
};
}}),
"[project]/node_modules/follow-redirects/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var url = __turbopack_context__.r("[externals]/url [external] (url, cjs)");
var URL = url.URL;
var http = __turbopack_context__.r("[externals]/http [external] (http, cjs)");
var https = __turbopack_context__.r("[externals]/https [external] (https, cjs)");
var Writable = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Writable;
var assert = __turbopack_context__.r("[externals]/assert [external] (assert, cjs)");
var debug = __turbopack_context__.r("[project]/node_modules/follow-redirects/debug.js [app-route] (ecmascript)");
// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
    var looksLikeNode = typeof process !== "undefined";
    var looksLikeBrowser = "undefined" !== "undefined" && typeof document !== "undefined";
    var looksLikeV8 = isFunction(Error.captureStackTrace);
    if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
        console.warn("The follow-redirects package should be excluded from browser builds.");
    }
})();
// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
    assert(new URL(""));
} catch (error) {
    useNativeURL = error.code === "ERR_INVALID_URL";
}
// URL fields to preserve in copy operations
var preservedUrlFields = [
    "auth",
    "host",
    "hostname",
    "href",
    "path",
    "pathname",
    "port",
    "protocol",
    "query",
    "search",
    "hash"
];
// Create handlers that pass events from native requests
var events = [
    "abort",
    "aborted",
    "connect",
    "error",
    "socket",
    "timeout"
];
var eventHandlers = Object.create(null);
events.forEach(function(event) {
    eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
    };
});
// Error types with codes
var InvalidUrlError = createErrorType("ERR_INVALID_URL", "Invalid URL", TypeError);
var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded", RedirectionError);
var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;
// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
    // Initialize the request
    Writable.call(this);
    this._sanitizeOptions(options);
    this._options = options;
    this._ended = false;
    this._ending = false;
    this._redirectCount = 0;
    this._redirects = [];
    this._requestBodyLength = 0;
    this._requestBodyBuffers = [];
    // Attach a callback if passed
    if (responseCallback) {
        this.on("response", responseCallback);
    }
    // React to responses of native requests
    var self = this;
    this._onNativeResponse = function(response) {
        try {
            self._processResponse(response);
        } catch (cause) {
            self.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({
                cause: cause
            }));
        }
    };
    // Perform the first request
    this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);
RedirectableRequest.prototype.abort = function() {
    destroyRequest(this._currentRequest);
    this._currentRequest.abort();
    this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error) {
    destroyRequest(this._currentRequest, error);
    destroy.call(this, error);
    return this;
};
// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function(data, encoding, callback) {
    // Writing is not allowed if end has been called
    if (this._ending) {
        throw new WriteAfterEndError();
    }
    // Validate input and shift parameters if necessary
    if (!isString(data) && !isBuffer(data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
    }
    if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Ignore empty buffers, since writing them doesn't invoke the callback
    // https://github.com/nodejs/node/issues/22066
    if (data.length === 0) {
        if (callback) {
            callback();
        }
        return;
    }
    // Only write when we don't exceed the maximum body length
    if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({
            data: data,
            encoding: encoding
        });
        this._currentRequest.write(data, encoding, callback);
    } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
    }
};
// Ends the current native request
RedirectableRequest.prototype.end = function(data, encoding, callback) {
    // Shift parameters if necessary
    if (isFunction(data)) {
        callback = data;
        data = encoding = null;
    } else if (isFunction(encoding)) {
        callback = encoding;
        encoding = null;
    }
    // Write data if needed and end
    if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
    } else {
        var self = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
            self._ended = true;
            currentRequest.end(null, null, callback);
        });
        this._ending = true;
    }
};
// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function(name, value) {
    this._options.headers[name] = value;
    this._currentRequest.setHeader(name, value);
};
// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function(name) {
    delete this._options.headers[name];
    this._currentRequest.removeHeader(name);
};
// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
    var self = this;
    // Destroys the socket on timeout
    function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
    }
    // Sets up a timer to trigger a timeout event
    function startTimer(socket) {
        if (self._timeout) {
            clearTimeout(self._timeout);
        }
        self._timeout = setTimeout(function() {
            self.emit("timeout");
            clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
    }
    // Stops a timeout from triggering
    function clearTimer() {
        // Clear the timeout
        if (self._timeout) {
            clearTimeout(self._timeout);
            self._timeout = null;
        }
        // Clean up all attached listeners
        self.removeListener("abort", clearTimer);
        self.removeListener("error", clearTimer);
        self.removeListener("response", clearTimer);
        self.removeListener("close", clearTimer);
        if (callback) {
            self.removeListener("timeout", callback);
        }
        if (!self.socket) {
            self._currentRequest.removeListener("socket", startTimer);
        }
    }
    // Attach callback if passed
    if (callback) {
        this.on("timeout", callback);
    }
    // Start the timer if or when the socket is opened
    if (this.socket) {
        startTimer(this.socket);
    } else {
        this._currentRequest.once("socket", startTimer);
    }
    // Clean up on events
    this.on("socket", destroyOnTimeout);
    this.on("abort", clearTimer);
    this.on("error", clearTimer);
    this.on("response", clearTimer);
    this.on("close", clearTimer);
    return this;
};
// Proxy all other public ClientRequest methods
[
    "flushHeaders",
    "getHeader",
    "setNoDelay",
    "setSocketKeepAlive"
].forEach(function(method) {
    RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
    };
});
// Proxy all public ClientRequest properties
[
    "aborted",
    "connection",
    "socket"
].forEach(function(property) {
    Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
            return this._currentRequest[property];
        }
    });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
    // Ensure headers are always present
    if (!options.headers) {
        options.headers = {};
    }
    // Since http.request treats host as an alias of hostname,
    // but the url module interprets host as hostname plus port,
    // eliminate the host property to avoid confusion.
    if (options.host) {
        // Use hostname if set, because it has precedence
        if (!options.hostname) {
            options.hostname = options.host;
        }
        delete options.host;
    }
    // Complete the URL object when necessary
    if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
            options.pathname = options.path;
        } else {
            options.pathname = options.path.substring(0, searchPos);
            options.search = options.path.substring(searchPos);
        }
    }
};
// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function() {
    // Load the native protocol
    var protocol = this._options.protocol;
    var nativeProtocol = this._options.nativeProtocols[protocol];
    if (!nativeProtocol) {
        throw new TypeError("Unsupported protocol " + protocol);
    }
    // If specified, use the agent corresponding to the protocol
    // (HTTP and HTTPS use different types of agents)
    if (this._options.agents) {
        var scheme = protocol.slice(0, -1);
        this._options.agent = this._options.agents[scheme];
    }
    // Create the native request and set up its event handlers
    var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
    request._redirectable = this;
    for (var event of events){
        request.on(event, eventHandlers[event]);
    }
    // RFC7230§5.3.1: When making a request directly to an origin server, […]
    // a client MUST send only the absolute path […] as the request-target.
    this._currentUrl = /^\//.test(this._options.path) ? url.format(this._options) : // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;
    // End a redirected request
    // (The first request must be ended explicitly with RedirectableRequest#end)
    if (this._isRedirect) {
        // Write the request entity and end
        var i = 0;
        var self = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
            // Only write if this request has not been redirected yet
            // istanbul ignore else
            if (request === self._currentRequest) {
                // Report any write errors
                // istanbul ignore if
                if (error) {
                    self.emit("error", error);
                } else if (i < buffers.length) {
                    var buffer = buffers[i++];
                    // istanbul ignore else
                    if (!request.finished) {
                        request.write(buffer.data, buffer.encoding, writeNext);
                    }
                } else if (self._ended) {
                    request.end();
                }
            }
        })();
    }
};
// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function(response) {
    // Store the redirected response
    var statusCode = response.statusCode;
    if (this._options.trackRedirects) {
        this._redirects.push({
            url: this._currentUrl,
            headers: response.headers,
            statusCode: statusCode
        });
    }
    // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
    // that further action needs to be taken by the user agent in order to
    // fulfill the request. If a Location header field is provided,
    // the user agent MAY automatically redirect its request to the URI
    // referenced by the Location field value,
    // even if the specific status code is not understood.
    // If the response is not a redirect; return it as-is
    var location = response.headers.location;
    if (!location || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        // Clean up
        this._requestBodyBuffers = [];
        return;
    }
    // The response is a redirect, so abort the current request
    destroyRequest(this._currentRequest);
    // Discard the remainder of the response to avoid waiting for data
    response.destroy();
    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
        throw new TooManyRedirectsError();
    }
    // Store the request headers if applicable
    var requestHeaders;
    var beforeRedirect = this._options.beforeRedirect;
    if (beforeRedirect) {
        requestHeaders = Object.assign({
            // The Host header was set by nativeProtocol.request
            Host: response.req.getHeader("host")
        }, this._options.headers);
    }
    // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe, […]
    // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
    // the request method from POST to GET for the subsequent request.
    var method = this._options.method;
    if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231§6.4.4: The 303 (See Other) status code indicates that
    // the server is redirecting the user agent to a different resource […]
    // A user agent can perform a retrieval request targeting that URI
    // (a GET or HEAD request if using HTTP) […]
    statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
        this._options.method = "GET";
        // Drop a possible entity and headers related to it
        this._requestBodyBuffers = [];
        removeMatchingHeaders(/^content-/i, this._options.headers);
    }
    // Drop the Host header, as the redirect might lead to a different host
    var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
    // If the redirect is relative, carry over the host of the last request
    var currentUrlParts = parseUrl(this._currentUrl);
    var currentHost = currentHostHeader || currentUrlParts.host;
    var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, {
        host: currentHost
    }));
    // Create the redirected request
    var redirectUrl = resolveUrl(location, currentUrl);
    debug("redirecting to", redirectUrl.href);
    this._isRedirect = true;
    spreadUrlObject(redirectUrl, this._options);
    // Drop confidential headers when redirecting to a less secure protocol
    // or to a different domain that is not a superdomain
    if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
        removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
    }
    // Evaluate the beforeRedirect callback
    if (isFunction(beforeRedirect)) {
        var responseDetails = {
            headers: response.headers,
            statusCode: statusCode
        };
        var requestDetails = {
            url: currentUrl,
            method: method,
            headers: requestHeaders
        };
        beforeRedirect(this._options, responseDetails, requestDetails);
        this._sanitizeOptions(this._options);
    }
    // Perform the redirected request
    this._performRequest();
};
// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
    // Default settings
    var exports = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
    };
    // Wrap each protocol
    var nativeProtocols = {};
    Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
        // Executes a request, following redirects
        function request(input, options, callback) {
            // Parse parameters, ensuring that input is an object
            if (isURL(input)) {
                input = spreadUrlObject(input);
            } else if (isString(input)) {
                input = spreadUrlObject(parseUrl(input));
            } else {
                callback = options;
                options = validateUrl(input);
                input = {
                    protocol: protocol
                };
            }
            if (isFunction(options)) {
                callback = options;
                options = null;
            }
            // Set defaults
            options = Object.assign({
                maxRedirects: exports.maxRedirects,
                maxBodyLength: exports.maxBodyLength
            }, input, options);
            options.nativeProtocols = nativeProtocols;
            if (!isString(options.host) && !isString(options.hostname)) {
                options.hostname = "::1";
            }
            assert.equal(options.protocol, protocol, "protocol mismatch");
            debug("options", options);
            return new RedirectableRequest(options, callback);
        }
        // Executes a GET request, following redirects
        function get(input, options, callback) {
            var wrappedRequest = wrappedProtocol.request(input, options, callback);
            wrappedRequest.end();
            return wrappedRequest;
        }
        // Expose the properties on the wrapped protocol
        Object.defineProperties(wrappedProtocol, {
            request: {
                value: request,
                configurable: true,
                enumerable: true,
                writable: true
            },
            get: {
                value: get,
                configurable: true,
                enumerable: true,
                writable: true
            }
        });
    });
    return exports;
}
function noop() {}
function parseUrl(input) {
    var parsed;
    // istanbul ignore else
    if (useNativeURL) {
        parsed = new URL(input);
    } else {
        // Ensure the URL is valid and absolute
        parsed = validateUrl(url.parse(input));
        if (!isString(parsed.protocol)) {
            throw new InvalidUrlError({
                input
            });
        }
    }
    return parsed;
}
function resolveUrl(relative, base) {
    // istanbul ignore next
    return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}
function validateUrl(input) {
    if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
        throw new InvalidUrlError({
            input: input.href || input
        });
    }
    return input;
}
function spreadUrlObject(urlObject, target) {
    var spread = target || {};
    for (var key of preservedUrlFields){
        spread[key] = urlObject[key];
    }
    // Fix IPv6 hostname
    if (spread.hostname.startsWith("[")) {
        spread.hostname = spread.hostname.slice(1, -1);
    }
    // Ensure port is a number
    if (spread.port !== "") {
        spread.port = Number(spread.port);
    }
    // Concatenate path
    spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;
    return spread;
}
function removeMatchingHeaders(regex, headers) {
    var lastValue;
    for(var header in headers){
        if (regex.test(header)) {
            lastValue = headers[header];
            delete headers[header];
        }
    }
    return lastValue === null || typeof lastValue === "undefined" ? undefined : String(lastValue).trim();
}
function createErrorType(code, message, baseClass) {
    // Create constructor
    function CustomError(properties) {
        // istanbul ignore else
        if (isFunction(Error.captureStackTrace)) {
            Error.captureStackTrace(this, this.constructor);
        }
        Object.assign(this, properties || {});
        this.code = code;
        this.message = this.cause ? message + ": " + this.cause.message : message;
    }
    // Attach constructor and set default properties
    CustomError.prototype = new (baseClass || Error)();
    Object.defineProperties(CustomError.prototype, {
        constructor: {
            value: CustomError,
            enumerable: false
        },
        name: {
            value: "Error [" + code + "]",
            enumerable: false
        }
    });
    return CustomError;
}
function destroyRequest(request, error) {
    for (var event of events){
        request.removeListener(event, eventHandlers[event]);
    }
    request.on("error", noop);
    request.destroy(error);
}
function isSubdomain(subdomain, domain) {
    assert(isString(subdomain) && isString(domain));
    var dot = subdomain.length - domain.length - 1;
    return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString(value) {
    return typeof value === "string" || value instanceof String;
}
function isFunction(value) {
    return typeof value === "function";
}
function isBuffer(value) {
    return typeof value === "object" && "length" in value;
}
function isURL(value) {
    return URL && value instanceof URL;
}
// Exports
module.exports = wrap({
    http: http,
    https: https
});
module.exports.wrap = wrap;
}}),
"[project]/node_modules/yocto-queue/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/*
How it works:
`this.#head` is an instance of `Node` which keeps track of its current value and nests another instance of `Node` that keeps the value that comes after it. When a value is provided to `.enqueue()`, the code needs to iterate through `this.#head`, going deeper and deeper to find the last value. However, iterating through every single item is slow. This problem is solved by saving a reference to the last value as `this.#tail` so that it can reference it to add a new value.
*/ __turbopack_context__.s({
    "default": (()=>Queue)
});
class Node {
    value;
    next;
    constructor(value){
        this.value = value;
    }
}
class Queue {
    #head;
    #tail;
    #size;
    constructor(){
        this.clear();
    }
    enqueue(value) {
        const node = new Node(value);
        if (this.#head) {
            this.#tail.next = node;
            this.#tail = node;
        } else {
            this.#head = node;
            this.#tail = node;
        }
        this.#size++;
    }
    dequeue() {
        const current = this.#head;
        if (!current) {
            return;
        }
        this.#head = this.#head.next;
        this.#size--;
        return current.value;
    }
    peek() {
        if (!this.#head) {
            return;
        }
        return this.#head.value;
    // TODO: Node.js 18.
    // return this.#head?.value;
    }
    clear() {
        this.#head = undefined;
        this.#tail = undefined;
        this.#size = 0;
    }
    get size() {
        return this.#size;
    }
    *[Symbol.iterator]() {
        let current = this.#head;
        while(current){
            yield current.value;
            current = current.next;
        }
    }
    *drain() {
        while(this.#head){
            yield this.dequeue();
        }
    }
}
}}),
"[project]/node_modules/p-limit/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>pLimit),
    "limitFunction": (()=>limitFunction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yocto$2d$queue$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/yocto-queue/index.js [app-route] (ecmascript)");
;
function pLimit(concurrency) {
    validateConcurrency(concurrency);
    const queue = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$yocto$2d$queue$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["default"]();
    let activeCount = 0;
    const resumeNext = ()=>{
        if (activeCount < concurrency && queue.size > 0) {
            queue.dequeue()();
            // Since `pendingCount` has been decreased by one, increase `activeCount` by one.
            activeCount++;
        }
    };
    const next = ()=>{
        activeCount--;
        resumeNext();
    };
    const run = async (function_, resolve, arguments_)=>{
        const result = (async ()=>function_(...arguments_))();
        resolve(result);
        try {
            await result;
        } catch  {}
        next();
    };
    const enqueue = (function_, resolve, arguments_)=>{
        // Queue `internalResolve` instead of the `run` function
        // to preserve asynchronous context.
        new Promise((internalResolve)=>{
            queue.enqueue(internalResolve);
        }).then(run.bind(undefined, function_, resolve, arguments_));
        (async ()=>{
            // This function needs to wait until the next microtask before comparing
            // `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
            // after the `internalResolve` function is dequeued and called. The comparison in the if-statement
            // needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
            await Promise.resolve();
            if (activeCount < concurrency) {
                resumeNext();
            }
        })();
    };
    const generator = (function_, ...arguments_)=>new Promise((resolve)=>{
            enqueue(function_, resolve, arguments_);
        });
    Object.defineProperties(generator, {
        activeCount: {
            get: ()=>activeCount
        },
        pendingCount: {
            get: ()=>queue.size
        },
        clearQueue: {
            value () {
                queue.clear();
            }
        },
        concurrency: {
            get: ()=>concurrency,
            set (newConcurrency) {
                validateConcurrency(newConcurrency);
                concurrency = newConcurrency;
                queueMicrotask(()=>{
                    // eslint-disable-next-line no-unmodified-loop-condition
                    while(activeCount < concurrency && queue.size > 0){
                        resumeNext();
                    }
                });
            }
        }
    });
    return generator;
}
function limitFunction(function_, option) {
    const { concurrency } = option;
    const limit = pLimit(concurrency);
    return (...arguments_)=>limit(()=>function_(...arguments_));
}
function validateConcurrency(concurrency) {
    if (!((Number.isInteger(concurrency) || concurrency === Number.POSITIVE_INFINITY) && concurrency > 0)) {
        throw new TypeError('Expected `concurrency` to be a number from 1 and up');
    }
}
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "prettyByte": (()=>prettyByte)
});
function prettyByte(byte) {
    return "".concat(byte < 0 ? "-" : "", "0x").concat(Math.abs(byte).toString(16).padStart(2, "0"));
} //# sourceMappingURL=prettyByte.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/**
 * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.
 */ __turbopack_context__.s({
    "ExtData": (()=>ExtData)
});
var ExtData = function() {
    function ExtData(type, data) {
        this.type = type;
        this.data = data;
    }
    return ExtData;
}();
;
 //# sourceMappingURL=ExtData.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DecodeError": (()=>DecodeError)
});
var __extends = this && this.__extends || function() {
    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || ({
            __proto__: []
        }) instanceof Array && function(d, b) {
            d.__proto__ = b;
        } || function(d, b) {
            for(var p in b)if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
        };
        return extendStatics(d, b);
    };
    return function(d, b) {
        if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
            this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
}();
var DecodeError = function(_super) {
    __extends(DecodeError, _super);
    function DecodeError(message) {
        var _this = _super.call(this, message) || this;
        // fix the prototype chain in a cross-platform way
        var proto = Object.create(DecodeError.prototype);
        Object.setPrototypeOf(_this, proto);
        Object.defineProperty(_this, "name", {
            configurable: true,
            enumerable: false,
            value: DecodeError.name
        });
        return _this;
    }
    return DecodeError;
}(Error);
;
 //# sourceMappingURL=DecodeError.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// Integer Utility
__turbopack_context__.s({
    "UINT32_MAX": (()=>UINT32_MAX),
    "getInt64": (()=>getInt64),
    "getUint64": (()=>getUint64),
    "setInt64": (()=>setInt64),
    "setUint64": (()=>setUint64)
});
var UINT32_MAX = 4294967295;
function setUint64(view, offset, value) {
    var high = value / 4294967296;
    var low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function setInt64(view, offset, value) {
    var high = Math.floor(value / 4294967296);
    var low = value; // high bits are truncated by DataView
    view.setUint32(offset, high);
    view.setUint32(offset + 4, low);
}
function getInt64(view, offset) {
    var high = view.getInt32(offset);
    var low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
}
function getUint64(view, offset) {
    var high = view.getUint32(offset);
    var low = view.getUint32(offset + 4);
    return high * 4294967296 + low;
} //# sourceMappingURL=int.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type
__turbopack_context__.s({
    "EXT_TIMESTAMP": (()=>EXT_TIMESTAMP),
    "decodeTimestampExtension": (()=>decodeTimestampExtension),
    "decodeTimestampToTimeSpec": (()=>decodeTimestampToTimeSpec),
    "encodeDateToTimeSpec": (()=>encodeDateToTimeSpec),
    "encodeTimeSpecToTimestamp": (()=>encodeTimeSpecToTimestamp),
    "encodeTimestampExtension": (()=>encodeTimestampExtension),
    "timestampExtension": (()=>timestampExtension)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs [app-route] (ecmascript)");
;
;
var EXT_TIMESTAMP = -1;
var TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int
var TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int
function encodeTimeSpecToTimestamp(_a) {
    var sec = _a.sec, nsec = _a.nsec;
    if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {
        // Here sec >= 0 && nsec >= 0
        if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {
            // timestamp 32 = { sec32 (unsigned) }
            var rv = new Uint8Array(4);
            var view = new DataView(rv.buffer);
            view.setUint32(0, sec);
            return rv;
        } else {
            // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }
            var secHigh = sec / 0x100000000;
            var secLow = sec & 0xffffffff;
            var rv = new Uint8Array(8);
            var view = new DataView(rv.buffer);
            // nsec30 | secHigh2
            view.setUint32(0, nsec << 2 | secHigh & 0x3);
            // secLow32
            view.setUint32(4, secLow);
            return rv;
        }
    } else {
        // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
        var rv = new Uint8Array(12);
        var view = new DataView(rv.buffer);
        view.setUint32(0, nsec);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setInt64"])(view, 4, sec);
        return rv;
    }
}
function encodeDateToTimeSpec(date) {
    var msec = date.getTime();
    var sec = Math.floor(msec / 1e3);
    var nsec = (msec - sec * 1e3) * 1e6;
    // Normalizes { sec, nsec } to ensure nsec is unsigned.
    var nsecInSec = Math.floor(nsec / 1e9);
    return {
        sec: sec + nsecInSec,
        nsec: nsec - nsecInSec * 1e9
    };
}
function encodeTimestampExtension(object) {
    if (object instanceof Date) {
        var timeSpec = encodeDateToTimeSpec(object);
        return encodeTimeSpecToTimestamp(timeSpec);
    } else {
        return null;
    }
}
function decodeTimestampToTimeSpec(data) {
    var view = new DataView(data.buffer, data.byteOffset, data.byteLength);
    // data may be 32, 64, or 96 bits
    switch(data.byteLength){
        case 4:
            {
                // timestamp 32 = { sec32 }
                var sec = view.getUint32(0);
                var nsec = 0;
                return {
                    sec: sec,
                    nsec: nsec
                };
            }
        case 8:
            {
                // timestamp 64 = { nsec30, sec34 }
                var nsec30AndSecHigh2 = view.getUint32(0);
                var secLow32 = view.getUint32(4);
                var sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;
                var nsec = nsec30AndSecHigh2 >>> 2;
                return {
                    sec: sec,
                    nsec: nsec
                };
            }
        case 12:
            {
                // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }
                var sec = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getInt64"])(view, 4);
                var nsec = view.getUint32(0);
                return {
                    sec: sec,
                    nsec: nsec
                };
            }
        default:
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(data.length));
    }
}
function decodeTimestampExtension(data) {
    var timeSpec = decodeTimestampToTimeSpec(data);
    return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);
}
var timestampExtension = {
    type: EXT_TIMESTAMP,
    encode: encodeTimestampExtension,
    decode: decodeTimestampExtension
}; //# sourceMappingURL=timestamp.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// ExtensionCodec to handle MessagePack extensions
__turbopack_context__.s({
    "ExtensionCodec": (()=>ExtensionCodec)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtData$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/ExtData.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$timestamp$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/timestamp.mjs [app-route] (ecmascript)");
;
;
var ExtensionCodec = function() {
    function ExtensionCodec() {
        // built-in extensions
        this.builtInEncoders = [];
        this.builtInDecoders = [];
        // custom extensions
        this.encoders = [];
        this.decoders = [];
        this.register(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$timestamp$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["timestampExtension"]);
    }
    ExtensionCodec.prototype.register = function(_a) {
        var type = _a.type, encode = _a.encode, decode = _a.decode;
        if (type >= 0) {
            // custom extensions
            this.encoders[type] = encode;
            this.decoders[type] = decode;
        } else {
            // built-in extensions
            var index = 1 + type;
            this.builtInEncoders[index] = encode;
            this.builtInDecoders[index] = decode;
        }
    };
    ExtensionCodec.prototype.tryToEncode = function(object, context) {
        // built-in extensions
        for(var i = 0; i < this.builtInEncoders.length; i++){
            var encodeExt = this.builtInEncoders[i];
            if (encodeExt != null) {
                var data = encodeExt(object, context);
                if (data != null) {
                    var type = -1 - i;
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtData$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtData"](type, data);
                }
            }
        }
        // custom extensions
        for(var i = 0; i < this.encoders.length; i++){
            var encodeExt = this.encoders[i];
            if (encodeExt != null) {
                var data = encodeExt(object, context);
                if (data != null) {
                    var type = i;
                    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtData$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtData"](type, data);
                }
            }
        }
        if (object instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtData$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtData"]) {
            // to keep ExtData as is
            return object;
        }
        return null;
    };
    ExtensionCodec.prototype.decode = function(data, type, context) {
        var decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];
        if (decodeExt) {
            return decodeExt(data, type, context);
        } else {
            // decode() does not fail, returns ExtData instead.
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtData$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtData"](type, data);
        }
    };
    ExtensionCodec.defaultCodec = new ExtensionCodec();
    return ExtensionCodec;
}();
;
 //# sourceMappingURL=ExtensionCodec.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "TEXT_DECODER_THRESHOLD": (()=>TEXT_DECODER_THRESHOLD),
    "TEXT_ENCODER_THRESHOLD": (()=>TEXT_ENCODER_THRESHOLD),
    "utf8Count": (()=>utf8Count),
    "utf8DecodeJs": (()=>utf8DecodeJs),
    "utf8DecodeTD": (()=>utf8DecodeTD),
    "utf8EncodeJs": (()=>utf8EncodeJs),
    "utf8EncodeTE": (()=>utf8EncodeTE)
});
/* eslint-disable @typescript-eslint/no-unnecessary-condition */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs [app-route] (ecmascript)");
var _a, _b, _c;
;
var TEXT_ENCODING_AVAILABLE = (typeof process === "undefined" || ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a["TEXT_ENCODING"]) !== "never") && typeof TextEncoder !== "undefined" && typeof TextDecoder !== "undefined";
function utf8Count(str) {
    var strLength = str.length;
    var byteLength = 0;
    var pos = 0;
    while(pos < strLength){
        var value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            byteLength++;
            continue;
        } else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            byteLength += 2;
        } else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    var extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                byteLength += 3;
            } else {
                // 4-byte
                byteLength += 4;
            }
        }
    }
    return byteLength;
}
function utf8EncodeJs(str, output, outputOffset) {
    var strLength = str.length;
    var offset = outputOffset;
    var pos = 0;
    while(pos < strLength){
        var value = str.charCodeAt(pos++);
        if ((value & 0xffffff80) === 0) {
            // 1-byte
            output[offset++] = value;
            continue;
        } else if ((value & 0xfffff800) === 0) {
            // 2-bytes
            output[offset++] = value >> 6 & 0x1f | 0xc0;
        } else {
            // handle surrogate pair
            if (value >= 0xd800 && value <= 0xdbff) {
                // high surrogate
                if (pos < strLength) {
                    var extra = str.charCodeAt(pos);
                    if ((extra & 0xfc00) === 0xdc00) {
                        ++pos;
                        value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;
                    }
                }
            }
            if ((value & 0xffff0000) === 0) {
                // 3-byte
                output[offset++] = value >> 12 & 0x0f | 0xe0;
                output[offset++] = value >> 6 & 0x3f | 0x80;
            } else {
                // 4-byte
                output[offset++] = value >> 18 & 0x07 | 0xf0;
                output[offset++] = value >> 12 & 0x3f | 0x80;
                output[offset++] = value >> 6 & 0x3f | 0x80;
            }
        }
        output[offset++] = value & 0x3f | 0x80;
    }
}
var sharedTextEncoder = TEXT_ENCODING_AVAILABLE ? new TextEncoder() : undefined;
var TEXT_ENCODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_MAX"] : typeof process !== "undefined" && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b["TEXT_ENCODING"]) !== "force" ? 200 : 0;
function utf8EncodeTEencode(str, output, outputOffset) {
    output.set(sharedTextEncoder.encode(str), outputOffset);
}
function utf8EncodeTEencodeInto(str, output, outputOffset) {
    sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));
}
var utf8EncodeTE = (sharedTextEncoder === null || sharedTextEncoder === void 0 ? void 0 : sharedTextEncoder.encodeInto) ? utf8EncodeTEencodeInto : utf8EncodeTEencode;
var CHUNK_SIZE = 4096;
function utf8DecodeJs(bytes, inputOffset, byteLength) {
    var offset = inputOffset;
    var end = offset + byteLength;
    var units = [];
    var result = "";
    while(offset < end){
        var byte1 = bytes[offset++];
        if ((byte1 & 0x80) === 0) {
            // 1 byte
            units.push(byte1);
        } else if ((byte1 & 0xe0) === 0xc0) {
            // 2 bytes
            var byte2 = bytes[offset++] & 0x3f;
            units.push((byte1 & 0x1f) << 6 | byte2);
        } else if ((byte1 & 0xf0) === 0xe0) {
            // 3 bytes
            var byte2 = bytes[offset++] & 0x3f;
            var byte3 = bytes[offset++] & 0x3f;
            units.push((byte1 & 0x1f) << 12 | byte2 << 6 | byte3);
        } else if ((byte1 & 0xf8) === 0xf0) {
            // 4 bytes
            var byte2 = bytes[offset++] & 0x3f;
            var byte3 = bytes[offset++] & 0x3f;
            var byte4 = bytes[offset++] & 0x3f;
            var unit = (byte1 & 0x07) << 0x12 | byte2 << 0x0c | byte3 << 0x06 | byte4;
            if (unit > 0xffff) {
                unit -= 0x10000;
                units.push(unit >>> 10 & 0x3ff | 0xd800);
                unit = 0xdc00 | unit & 0x3ff;
            }
            units.push(unit);
        } else {
            units.push(byte1);
        }
        if (units.length >= CHUNK_SIZE) {
            result += String.fromCharCode.apply(String, units);
            units.length = 0;
        }
    }
    if (units.length > 0) {
        result += String.fromCharCode.apply(String, units);
    }
    return result;
}
var sharedTextDecoder = TEXT_ENCODING_AVAILABLE ? new TextDecoder() : null;
var TEXT_DECODER_THRESHOLD = !TEXT_ENCODING_AVAILABLE ? __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_MAX"] : typeof process !== "undefined" && ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c["TEXT_DECODER"]) !== "force" ? 200 : 0;
function utf8DecodeTD(bytes, inputOffset, byteLength) {
    var stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);
    return sharedTextDecoder.decode(stringBytes);
} //# sourceMappingURL=utf8.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "createDataView": (()=>createDataView),
    "ensureUint8Array": (()=>ensureUint8Array)
});
function ensureUint8Array(buffer) {
    if (buffer instanceof Uint8Array) {
        return buffer;
    } else if (ArrayBuffer.isView(buffer)) {
        return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    } else if (buffer instanceof ArrayBuffer) {
        return new Uint8Array(buffer);
    } else {
        // ArrayLike<number>
        return Uint8Array.from(buffer);
    }
}
function createDataView(buffer) {
    if (buffer instanceof ArrayBuffer) {
        return new DataView(buffer);
    }
    var bufferView = ensureUint8Array(buffer);
    return new DataView(bufferView.buffer, bufferView.byteOffset, bufferView.byteLength);
} //# sourceMappingURL=typedArrays.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "CachedKeyDecoder": (()=>CachedKeyDecoder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs [app-route] (ecmascript)");
;
var DEFAULT_MAX_KEY_LENGTH = 16;
var DEFAULT_MAX_LENGTH_PER_KEY = 16;
var CachedKeyDecoder = function() {
    function CachedKeyDecoder(maxKeyLength, maxLengthPerKey) {
        if (maxKeyLength === void 0) {
            maxKeyLength = DEFAULT_MAX_KEY_LENGTH;
        }
        if (maxLengthPerKey === void 0) {
            maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY;
        }
        this.maxKeyLength = maxKeyLength;
        this.maxLengthPerKey = maxLengthPerKey;
        this.hit = 0;
        this.miss = 0;
        // avoid `new Array(N)`, which makes a sparse array,
        // because a sparse array is typically slower than a non-sparse array.
        this.caches = [];
        for(var i = 0; i < this.maxKeyLength; i++){
            this.caches.push([]);
        }
    }
    CachedKeyDecoder.prototype.canBeCached = function(byteLength) {
        return byteLength > 0 && byteLength <= this.maxKeyLength;
    };
    CachedKeyDecoder.prototype.find = function(bytes, inputOffset, byteLength) {
        var records = this.caches[byteLength - 1];
        FIND_CHUNK: for(var _i = 0, records_1 = records; _i < records_1.length; _i++){
            var record = records_1[_i];
            var recordBytes = record.bytes;
            for(var j = 0; j < byteLength; j++){
                if (recordBytes[j] !== bytes[inputOffset + j]) {
                    continue FIND_CHUNK;
                }
            }
            return record.str;
        }
        return null;
    };
    CachedKeyDecoder.prototype.store = function(bytes, value) {
        var records = this.caches[bytes.length - 1];
        var record = {
            bytes: bytes,
            str: value
        };
        if (records.length >= this.maxLengthPerKey) {
            // `records` are full!
            // Set `record` to an arbitrary position.
            records[Math.random() * records.length | 0] = record;
        } else {
            records.push(record);
        }
    };
    CachedKeyDecoder.prototype.decode = function(bytes, inputOffset, byteLength) {
        var cachedValue = this.find(bytes, inputOffset, byteLength);
        if (cachedValue != null) {
            this.hit++;
            return cachedValue;
        }
        this.miss++;
        var str = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8DecodeJs"])(bytes, inputOffset, byteLength);
        // Ensure to copy a slice of bytes because the byte may be NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.
        var slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);
        this.store(slicedCopyOfBytes, str);
        return str;
    };
    return CachedKeyDecoder;
}();
;
 //# sourceMappingURL=CachedKeyDecoder.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DataViewIndexOutOfBoundsError": (()=>DataViewIndexOutOfBoundsError),
    "Decoder": (()=>Decoder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$prettyByte$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/prettyByte.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtensionCodec$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$typedArrays$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$CachedKeyDecoder$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/CachedKeyDecoder.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/DecodeError.mjs [app-route] (ecmascript)");
var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = this && this.__generator || function(thisArg, body) {
    var _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, f, y, t, g;
    return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    "TURBOPACK unreachable";
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(_)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
};
var __asyncValues = this && this.__asyncValues || function(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i);
    "TURBOPACK unreachable";
    function verb(n) {
        i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
                v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
        };
    }
    function settle(resolve, reject, d, v) {
        Promise.resolve(v).then(function(v) {
            resolve({
                value: v,
                done: d
            });
        }, reject);
    }
};
var __await = this && this.__await || function(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
};
var __asyncGenerator = this && this.__asyncGenerator || function(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
        return this;
    }, i;
    "TURBOPACK unreachable";
    function verb(n) {
        if (g[n]) i[n] = function(v) {
            return new Promise(function(a, b) {
                q.push([
                    n,
                    v,
                    a,
                    b
                ]) > 1 || resume(n, v);
            });
        };
    }
    function resume(n, v) {
        try {
            step(g[n](v));
        } catch (e) {
            settle(q[0][3], e);
        }
    }
    function step(r) {
        r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }
    function fulfill(value) {
        resume("next", value);
    }
    function reject(value) {
        resume("throw", value);
    }
    function settle(f, v) {
        if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
};
;
;
;
;
;
;
;
var isValidMapKeyType = function(key) {
    var keyType = typeof key;
    return keyType === "string" || keyType === "number";
};
var HEAD_BYTE_REQUIRED = -1;
var EMPTY_VIEW = new DataView(new ArrayBuffer(0));
var EMPTY_BYTES = new Uint8Array(EMPTY_VIEW.buffer);
var DataViewIndexOutOfBoundsError = function() {
    try {
        // IE11: The spec says it should throw RangeError,
        // IE11: but in IE11 it throws TypeError.
        EMPTY_VIEW.getInt8(0);
    } catch (e) {
        return e.constructor;
    }
    throw new Error("never reached");
}();
var MORE_DATA = new DataViewIndexOutOfBoundsError("Insufficient data");
var sharedCachedKeyDecoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$CachedKeyDecoder$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["CachedKeyDecoder"]();
var Decoder = function() {
    function Decoder(extensionCodec, context, maxStrLength, maxBinLength, maxArrayLength, maxMapLength, maxExtLength, keyDecoder) {
        if (extensionCodec === void 0) {
            extensionCodec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtensionCodec$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtensionCodec"].defaultCodec;
        }
        if (context === void 0) {
            context = undefined;
        }
        if (maxStrLength === void 0) {
            maxStrLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_MAX"];
        }
        if (maxBinLength === void 0) {
            maxBinLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_MAX"];
        }
        if (maxArrayLength === void 0) {
            maxArrayLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_MAX"];
        }
        if (maxMapLength === void 0) {
            maxMapLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_MAX"];
        }
        if (maxExtLength === void 0) {
            maxExtLength = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UINT32_MAX"];
        }
        if (keyDecoder === void 0) {
            keyDecoder = sharedCachedKeyDecoder;
        }
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxStrLength = maxStrLength;
        this.maxBinLength = maxBinLength;
        this.maxArrayLength = maxArrayLength;
        this.maxMapLength = maxMapLength;
        this.maxExtLength = maxExtLength;
        this.keyDecoder = keyDecoder;
        this.totalPos = 0;
        this.pos = 0;
        this.view = EMPTY_VIEW;
        this.bytes = EMPTY_BYTES;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack = [];
    }
    Decoder.prototype.reinitializeState = function() {
        this.totalPos = 0;
        this.headByte = HEAD_BYTE_REQUIRED;
        this.stack.length = 0;
    // view, bytes, and pos will be re-initialized in setBuffer()
    };
    Decoder.prototype.setBuffer = function(buffer) {
        this.bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$typedArrays$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ensureUint8Array"])(buffer);
        this.view = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$typedArrays$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["createDataView"])(this.bytes);
        this.pos = 0;
    };
    Decoder.prototype.appendBuffer = function(buffer) {
        if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {
            this.setBuffer(buffer);
        } else {
            var remainingData = this.bytes.subarray(this.pos);
            var newData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$typedArrays$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ensureUint8Array"])(buffer);
            // concat remainingData + newData
            var newBuffer = new Uint8Array(remainingData.length + newData.length);
            newBuffer.set(remainingData);
            newBuffer.set(newData, remainingData.length);
            this.setBuffer(newBuffer);
        }
    };
    Decoder.prototype.hasRemaining = function(size) {
        return this.view.byteLength - this.pos >= size;
    };
    Decoder.prototype.createExtraByteError = function(posToShow) {
        var _a = this, view = _a.view, pos = _a.pos;
        return new RangeError("Extra ".concat(view.byteLength - pos, " of ").concat(view.byteLength, " byte(s) found at buffer[").concat(posToShow, "]"));
    };
    /**
     * @throws {@link DecodeError}
     * @throws {@link RangeError}
     */ Decoder.prototype.decode = function(buffer) {
        this.reinitializeState();
        this.setBuffer(buffer);
        var object = this.doDecodeSync();
        if (this.hasRemaining(1)) {
            throw this.createExtraByteError(this.pos);
        }
        return object;
    };
    Decoder.prototype.decodeMulti = function(buffer) {
        return __generator(this, function(_a) {
            switch(_a.label){
                case 0:
                    this.reinitializeState();
                    this.setBuffer(buffer);
                    _a.label = 1;
                case 1:
                    if (!this.hasRemaining(1)) return [
                        3 /*break*/ ,
                        3
                    ];
                    return [
                        4 /*yield*/ ,
                        this.doDecodeSync()
                    ];
                case 2:
                    _a.sent();
                    return [
                        3 /*break*/ ,
                        1
                    ];
                case 3:
                    return [
                        2 /*return*/ 
                    ];
            }
        });
    };
    Decoder.prototype.decodeAsync = function(stream) {
        var stream_1, stream_1_1;
        var e_1, _a;
        return __awaiter(this, void 0, void 0, function() {
            var decoded, object, buffer, e_1_1, _b, headByte, pos, totalPos;
            return __generator(this, function(_c) {
                switch(_c.label){
                    case 0:
                        decoded = false;
                        _c.label = 1;
                    case 1:
                        _c.trys.push([
                            1,
                            6,
                            7,
                            12
                        ]);
                        stream_1 = __asyncValues(stream);
                        _c.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            stream_1.next()
                        ];
                    case 3:
                        if (!(stream_1_1 = _c.sent(), !stream_1_1.done)) return [
                            3 /*break*/ ,
                            5
                        ];
                        buffer = stream_1_1.value;
                        if (decoded) {
                            throw this.createExtraByteError(this.totalPos);
                        }
                        this.appendBuffer(buffer);
                        try {
                            object = this.doDecodeSync();
                            decoded = true;
                        } catch (e) {
                            if (!(e instanceof DataViewIndexOutOfBoundsError)) {
                                throw e; // rethrow
                            }
                        // fallthrough
                        }
                        this.totalPos += this.pos;
                        _c.label = 4;
                    case 4:
                        return [
                            3 /*break*/ ,
                            2
                        ];
                    case 5:
                        return [
                            3 /*break*/ ,
                            12
                        ];
                    case 6:
                        e_1_1 = _c.sent();
                        e_1 = {
                            error: e_1_1
                        };
                        return [
                            3 /*break*/ ,
                            12
                        ];
                    case 7:
                        _c.trys.push([
                            7,
                            ,
                            10,
                            11
                        ]);
                        if (!(stream_1_1 && !stream_1_1.done && (_a = stream_1.return))) return [
                            3 /*break*/ ,
                            9
                        ];
                        return [
                            4 /*yield*/ ,
                            _a.call(stream_1)
                        ];
                    case 8:
                        _c.sent();
                        _c.label = 9;
                    case 9:
                        return [
                            3 /*break*/ ,
                            11
                        ];
                    case 10:
                        if (e_1) throw e_1.error;
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 11:
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 12:
                        if (decoded) {
                            if (this.hasRemaining(1)) {
                                throw this.createExtraByteError(this.totalPos);
                            }
                            return [
                                2 /*return*/ ,
                                object
                            ];
                        }
                        _b = this, headByte = _b.headByte, pos = _b.pos, totalPos = _b.totalPos;
                        throw new RangeError("Insufficient data in parsing ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$prettyByte$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyByte"])(headByte), " at ").concat(totalPos, " (").concat(pos, " in the current buffer)"));
                }
            });
        });
    };
    Decoder.prototype.decodeArrayStream = function(stream) {
        return this.decodeMultiAsync(stream, true);
    };
    Decoder.prototype.decodeStream = function(stream) {
        return this.decodeMultiAsync(stream, false);
    };
    Decoder.prototype.decodeMultiAsync = function(stream, isArray) {
        return __asyncGenerator(this, arguments, function decodeMultiAsync_1() {
            var isArrayHeaderRequired, arrayItemsLeft, stream_2, stream_2_1, buffer, e_2, e_3_1;
            var e_3, _a;
            return __generator(this, function(_b) {
                switch(_b.label){
                    case 0:
                        isArrayHeaderRequired = isArray;
                        arrayItemsLeft = -1;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([
                            1,
                            13,
                            14,
                            19
                        ]);
                        stream_2 = __asyncValues(stream);
                        _b.label = 2;
                    case 2:
                        return [
                            4 /*yield*/ ,
                            __await(stream_2.next())
                        ];
                    case 3:
                        if (!(stream_2_1 = _b.sent(), !stream_2_1.done)) return [
                            3 /*break*/ ,
                            12
                        ];
                        buffer = stream_2_1.value;
                        if (isArray && arrayItemsLeft === 0) {
                            throw this.createExtraByteError(this.totalPos);
                        }
                        this.appendBuffer(buffer);
                        if (isArrayHeaderRequired) {
                            arrayItemsLeft = this.readArraySize();
                            isArrayHeaderRequired = false;
                            this.complete();
                        }
                        _b.label = 4;
                    case 4:
                        _b.trys.push([
                            4,
                            9,
                            ,
                            10
                        ]);
                        _b.label = 5;
                    case 5:
                        if ("TURBOPACK compile-time falsy", 0) {
                            "TURBOPACK unreachable";
                        }
                        return [
                            4 /*yield*/ ,
                            __await(this.doDecodeSync())
                        ];
                    case 6:
                        return [
                            4 /*yield*/ ,
                            _b.sent()
                        ];
                    case 7:
                        _b.sent();
                        if (--arrayItemsLeft === 0) {
                            return [
                                3 /*break*/ ,
                                8
                            ];
                        }
                        return [
                            3 /*break*/ ,
                            5
                        ];
                    case 8:
                        return [
                            3 /*break*/ ,
                            10
                        ];
                    case 9:
                        e_2 = _b.sent();
                        if (!(e_2 instanceof DataViewIndexOutOfBoundsError)) {
                            throw e_2; // rethrow
                        }
                        return [
                            3 /*break*/ ,
                            10
                        ];
                    case 10:
                        this.totalPos += this.pos;
                        _b.label = 11;
                    case 11:
                        return [
                            3 /*break*/ ,
                            2
                        ];
                    case 12:
                        return [
                            3 /*break*/ ,
                            19
                        ];
                    case 13:
                        e_3_1 = _b.sent();
                        e_3 = {
                            error: e_3_1
                        };
                        return [
                            3 /*break*/ ,
                            19
                        ];
                    case 14:
                        _b.trys.push([
                            14,
                            ,
                            17,
                            18
                        ]);
                        if (!(stream_2_1 && !stream_2_1.done && (_a = stream_2.return))) return [
                            3 /*break*/ ,
                            16
                        ];
                        return [
                            4 /*yield*/ ,
                            __await(_a.call(stream_2))
                        ];
                    case 15:
                        _b.sent();
                        _b.label = 16;
                    case 16:
                        return [
                            3 /*break*/ ,
                            18
                        ];
                    case 17:
                        if (e_3) throw e_3.error;
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 18:
                        return [
                            7 /*endfinally*/ 
                        ];
                    case 19:
                        return [
                            2 /*return*/ 
                        ];
                }
            });
        });
    };
    Decoder.prototype.doDecodeSync = function() {
        DECODE: while(true){
            var headByte = this.readHeadByte();
            var object = void 0;
            if (headByte >= 0xe0) {
                // negative fixint (111x xxxx) 0xe0 - 0xff
                object = headByte - 0x100;
            } else if (headByte < 0xc0) {
                if (headByte < 0x80) {
                    // positive fixint (0xxx xxxx) 0x00 - 0x7f
                    object = headByte;
                } else if (headByte < 0x90) {
                    // fixmap (1000 xxxx) 0x80 - 0x8f
                    var size = headByte - 0x80;
                    if (size !== 0) {
                        this.pushMapState(size);
                        this.complete();
                        continue DECODE;
                    } else {
                        object = {};
                    }
                } else if (headByte < 0xa0) {
                    // fixarray (1001 xxxx) 0x90 - 0x9f
                    var size = headByte - 0x90;
                    if (size !== 0) {
                        this.pushArrayState(size);
                        this.complete();
                        continue DECODE;
                    } else {
                        object = [];
                    }
                } else {
                    // fixstr (101x xxxx) 0xa0 - 0xbf
                    var byteLength = headByte - 0xa0;
                    object = this.decodeUtf8String(byteLength, 0);
                }
            } else if (headByte === 0xc0) {
                // nil
                object = null;
            } else if (headByte === 0xc2) {
                // false
                object = false;
            } else if (headByte === 0xc3) {
                // true
                object = true;
            } else if (headByte === 0xca) {
                // float 32
                object = this.readF32();
            } else if (headByte === 0xcb) {
                // float 64
                object = this.readF64();
            } else if (headByte === 0xcc) {
                // uint 8
                object = this.readU8();
            } else if (headByte === 0xcd) {
                // uint 16
                object = this.readU16();
            } else if (headByte === 0xce) {
                // uint 32
                object = this.readU32();
            } else if (headByte === 0xcf) {
                // uint 64
                object = this.readU64();
            } else if (headByte === 0xd0) {
                // int 8
                object = this.readI8();
            } else if (headByte === 0xd1) {
                // int 16
                object = this.readI16();
            } else if (headByte === 0xd2) {
                // int 32
                object = this.readI32();
            } else if (headByte === 0xd3) {
                // int 64
                object = this.readI64();
            } else if (headByte === 0xd9) {
                // str 8
                var byteLength = this.lookU8();
                object = this.decodeUtf8String(byteLength, 1);
            } else if (headByte === 0xda) {
                // str 16
                var byteLength = this.lookU16();
                object = this.decodeUtf8String(byteLength, 2);
            } else if (headByte === 0xdb) {
                // str 32
                var byteLength = this.lookU32();
                object = this.decodeUtf8String(byteLength, 4);
            } else if (headByte === 0xdc) {
                // array 16
                var size = this.readU16();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                } else {
                    object = [];
                }
            } else if (headByte === 0xdd) {
                // array 32
                var size = this.readU32();
                if (size !== 0) {
                    this.pushArrayState(size);
                    this.complete();
                    continue DECODE;
                } else {
                    object = [];
                }
            } else if (headByte === 0xde) {
                // map 16
                var size = this.readU16();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                } else {
                    object = {};
                }
            } else if (headByte === 0xdf) {
                // map 32
                var size = this.readU32();
                if (size !== 0) {
                    this.pushMapState(size);
                    this.complete();
                    continue DECODE;
                } else {
                    object = {};
                }
            } else if (headByte === 0xc4) {
                // bin 8
                var size = this.lookU8();
                object = this.decodeBinary(size, 1);
            } else if (headByte === 0xc5) {
                // bin 16
                var size = this.lookU16();
                object = this.decodeBinary(size, 2);
            } else if (headByte === 0xc6) {
                // bin 32
                var size = this.lookU32();
                object = this.decodeBinary(size, 4);
            } else if (headByte === 0xd4) {
                // fixext 1
                object = this.decodeExtension(1, 0);
            } else if (headByte === 0xd5) {
                // fixext 2
                object = this.decodeExtension(2, 0);
            } else if (headByte === 0xd6) {
                // fixext 4
                object = this.decodeExtension(4, 0);
            } else if (headByte === 0xd7) {
                // fixext 8
                object = this.decodeExtension(8, 0);
            } else if (headByte === 0xd8) {
                // fixext 16
                object = this.decodeExtension(16, 0);
            } else if (headByte === 0xc7) {
                // ext 8
                var size = this.lookU8();
                object = this.decodeExtension(size, 1);
            } else if (headByte === 0xc8) {
                // ext 16
                var size = this.lookU16();
                object = this.decodeExtension(size, 2);
            } else if (headByte === 0xc9) {
                // ext 32
                var size = this.lookU32();
                object = this.decodeExtension(size, 4);
            } else {
                throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Unrecognized type byte: ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$prettyByte$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyByte"])(headByte)));
            }
            this.complete();
            var stack = this.stack;
            while(stack.length > 0){
                // arrays and maps
                var state = stack[stack.length - 1];
                if (state.type === 0 /* State.ARRAY */ ) {
                    state.array[state.position] = object;
                    state.position++;
                    if (state.position === state.size) {
                        stack.pop();
                        object = state.array;
                    } else {
                        continue DECODE;
                    }
                } else if (state.type === 1 /* State.MAP_KEY */ ) {
                    if (!isValidMapKeyType(object)) {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("The type of key must be string or number but " + typeof object);
                    }
                    if (object === "__proto__") {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("The key __proto__ is not allowed");
                    }
                    state.key = object;
                    state.type = 2 /* State.MAP_VALUE */ ;
                    continue DECODE;
                } else {
                    // it must be `state.type === State.MAP_VALUE` here
                    state.map[state.key] = object;
                    state.readCount++;
                    if (state.readCount === state.size) {
                        stack.pop();
                        object = state.map;
                    } else {
                        state.key = null;
                        state.type = 1 /* State.MAP_KEY */ ;
                        continue DECODE;
                    }
                }
            }
            return object;
        }
    };
    Decoder.prototype.readHeadByte = function() {
        if (this.headByte === HEAD_BYTE_REQUIRED) {
            this.headByte = this.readU8();
        // console.log("headByte", prettyByte(this.headByte));
        }
        return this.headByte;
    };
    Decoder.prototype.complete = function() {
        this.headByte = HEAD_BYTE_REQUIRED;
    };
    Decoder.prototype.readArraySize = function() {
        var headByte = this.readHeadByte();
        switch(headByte){
            case 0xdc:
                return this.readU16();
            case 0xdd:
                return this.readU32();
            default:
                {
                    if (headByte < 0xa0) {
                        return headByte - 0x90;
                    } else {
                        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Unrecognized array type byte: ".concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$prettyByte$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["prettyByte"])(headByte)));
                    }
                }
        }
    };
    Decoder.prototype.pushMapState = function(size) {
        if (size > this.maxMapLength) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Max length exceeded: map length (".concat(size, ") > maxMapLengthLength (").concat(this.maxMapLength, ")"));
        }
        this.stack.push({
            type: 1 /* State.MAP_KEY */ ,
            size: size,
            key: null,
            readCount: 0,
            map: {}
        });
    };
    Decoder.prototype.pushArrayState = function(size) {
        if (size > this.maxArrayLength) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Max length exceeded: array length (".concat(size, ") > maxArrayLength (").concat(this.maxArrayLength, ")"));
        }
        this.stack.push({
            type: 0 /* State.ARRAY */ ,
            size: size,
            array: new Array(size),
            position: 0
        });
    };
    Decoder.prototype.decodeUtf8String = function(byteLength, headerOffset) {
        var _a;
        if (byteLength > this.maxStrLength) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Max length exceeded: UTF-8 byte length (".concat(byteLength, ") > maxStrLength (").concat(this.maxStrLength, ")"));
        }
        if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {
            throw MORE_DATA;
        }
        var offset = this.pos + headerOffset;
        var object;
        if (this.stateIsMapKey() && ((_a = this.keyDecoder) === null || _a === void 0 ? void 0 : _a.canBeCached(byteLength))) {
            object = this.keyDecoder.decode(this.bytes, offset, byteLength);
        } else if (byteLength > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TEXT_DECODER_THRESHOLD"]) {
            object = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8DecodeTD"])(this.bytes, offset, byteLength);
        } else {
            object = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8DecodeJs"])(this.bytes, offset, byteLength);
        }
        this.pos += headerOffset + byteLength;
        return object;
    };
    Decoder.prototype.stateIsMapKey = function() {
        if (this.stack.length > 0) {
            var state = this.stack[this.stack.length - 1];
            return state.type === 1 /* State.MAP_KEY */ ;
        }
        return false;
    };
    Decoder.prototype.decodeBinary = function(byteLength, headOffset) {
        if (byteLength > this.maxBinLength) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Max length exceeded: bin length (".concat(byteLength, ") > maxBinLength (").concat(this.maxBinLength, ")"));
        }
        if (!this.hasRemaining(byteLength + headOffset)) {
            throw MORE_DATA;
        }
        var offset = this.pos + headOffset;
        var object = this.bytes.subarray(offset, offset + byteLength);
        this.pos += headOffset + byteLength;
        return object;
    };
    Decoder.prototype.decodeExtension = function(size, headOffset) {
        if (size > this.maxExtLength) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$DecodeError$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["DecodeError"]("Max length exceeded: ext length (".concat(size, ") > maxExtLength (").concat(this.maxExtLength, ")"));
        }
        var extType = this.view.getInt8(this.pos + headOffset);
        var data = this.decodeBinary(size, headOffset + 1 /* extType */ );
        return this.extensionCodec.decode(data, extType, this.context);
    };
    Decoder.prototype.lookU8 = function() {
        return this.view.getUint8(this.pos);
    };
    Decoder.prototype.lookU16 = function() {
        return this.view.getUint16(this.pos);
    };
    Decoder.prototype.lookU32 = function() {
        return this.view.getUint32(this.pos);
    };
    Decoder.prototype.readU8 = function() {
        var value = this.view.getUint8(this.pos);
        this.pos++;
        return value;
    };
    Decoder.prototype.readI8 = function() {
        var value = this.view.getInt8(this.pos);
        this.pos++;
        return value;
    };
    Decoder.prototype.readU16 = function() {
        var value = this.view.getUint16(this.pos);
        this.pos += 2;
        return value;
    };
    Decoder.prototype.readI16 = function() {
        var value = this.view.getInt16(this.pos);
        this.pos += 2;
        return value;
    };
    Decoder.prototype.readU32 = function() {
        var value = this.view.getUint32(this.pos);
        this.pos += 4;
        return value;
    };
    Decoder.prototype.readI32 = function() {
        var value = this.view.getInt32(this.pos);
        this.pos += 4;
        return value;
    };
    Decoder.prototype.readU64 = function() {
        var value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getUint64"])(this.view, this.pos);
        this.pos += 8;
        return value;
    };
    Decoder.prototype.readI64 = function() {
        var value = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["getInt64"])(this.view, this.pos);
        this.pos += 8;
        return value;
    };
    Decoder.prototype.readF32 = function() {
        var value = this.view.getFloat32(this.pos);
        this.pos += 4;
        return value;
    };
    Decoder.prototype.readF64 = function() {
        var value = this.view.getFloat64(this.pos);
        this.pos += 8;
        return value;
    };
    return Decoder;
}();
;
 //# sourceMappingURL=Decoder.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "decode": (()=>decode),
    "decodeMulti": (()=>decodeMulti),
    "defaultDecodeOptions": (()=>defaultDecodeOptions)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$Decoder$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/Decoder.mjs [app-route] (ecmascript)");
;
var defaultDecodeOptions = {};
function decode(buffer, options) {
    if (options === void 0) {
        options = defaultDecodeOptions;
    }
    var decoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$Decoder$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Decoder"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
    return decoder.decode(buffer);
}
function decodeMulti(buffer, options) {
    if (options === void 0) {
        options = defaultDecodeOptions;
    }
    var decoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$Decoder$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Decoder"](options.extensionCodec, options.context, options.maxStrLength, options.maxBinLength, options.maxArrayLength, options.maxMapLength, options.maxExtLength);
    return decoder.decodeMulti(buffer);
} //# sourceMappingURL=decode.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "DEFAULT_INITIAL_BUFFER_SIZE": (()=>DEFAULT_INITIAL_BUFFER_SIZE),
    "DEFAULT_MAX_DEPTH": (()=>DEFAULT_MAX_DEPTH),
    "Encoder": (()=>Encoder)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/utf8.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtensionCodec$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/ExtensionCodec.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/int.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$typedArrays$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/utils/typedArrays.mjs [app-route] (ecmascript)");
;
;
;
;
var DEFAULT_MAX_DEPTH = 100;
var DEFAULT_INITIAL_BUFFER_SIZE = 2048;
var Encoder = function() {
    function Encoder(extensionCodec, context, maxDepth, initialBufferSize, sortKeys, forceFloat32, ignoreUndefined, forceIntegerToFloat) {
        if (extensionCodec === void 0) {
            extensionCodec = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$ExtensionCodec$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ExtensionCodec"].defaultCodec;
        }
        if (context === void 0) {
            context = undefined;
        }
        if (maxDepth === void 0) {
            maxDepth = DEFAULT_MAX_DEPTH;
        }
        if (initialBufferSize === void 0) {
            initialBufferSize = DEFAULT_INITIAL_BUFFER_SIZE;
        }
        if (sortKeys === void 0) {
            sortKeys = false;
        }
        if (forceFloat32 === void 0) {
            forceFloat32 = false;
        }
        if (ignoreUndefined === void 0) {
            ignoreUndefined = false;
        }
        if (forceIntegerToFloat === void 0) {
            forceIntegerToFloat = false;
        }
        this.extensionCodec = extensionCodec;
        this.context = context;
        this.maxDepth = maxDepth;
        this.initialBufferSize = initialBufferSize;
        this.sortKeys = sortKeys;
        this.forceFloat32 = forceFloat32;
        this.ignoreUndefined = ignoreUndefined;
        this.forceIntegerToFloat = forceIntegerToFloat;
        this.pos = 0;
        this.view = new DataView(new ArrayBuffer(this.initialBufferSize));
        this.bytes = new Uint8Array(this.view.buffer);
    }
    Encoder.prototype.reinitializeState = function() {
        this.pos = 0;
    };
    /**
     * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.
     *
     * @returns Encodes the object and returns a shared reference the encoder's internal buffer.
     */ Encoder.prototype.encodeSharedRef = function(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.subarray(0, this.pos);
    };
    /**
     * @returns Encodes the object and returns a copy of the encoder's internal buffer.
     */ Encoder.prototype.encode = function(object) {
        this.reinitializeState();
        this.doEncode(object, 1);
        return this.bytes.slice(0, this.pos);
    };
    Encoder.prototype.doEncode = function(object, depth) {
        if (depth > this.maxDepth) {
            throw new Error("Too deep objects in depth ".concat(depth));
        }
        if (object == null) {
            this.encodeNil();
        } else if (typeof object === "boolean") {
            this.encodeBoolean(object);
        } else if (typeof object === "number") {
            this.encodeNumber(object);
        } else if (typeof object === "string") {
            this.encodeString(object);
        } else {
            this.encodeObject(object, depth);
        }
    };
    Encoder.prototype.ensureBufferSizeToWrite = function(sizeToWrite) {
        var requiredSize = this.pos + sizeToWrite;
        if (this.view.byteLength < requiredSize) {
            this.resizeBuffer(requiredSize * 2);
        }
    };
    Encoder.prototype.resizeBuffer = function(newSize) {
        var newBuffer = new ArrayBuffer(newSize);
        var newBytes = new Uint8Array(newBuffer);
        var newView = new DataView(newBuffer);
        newBytes.set(this.bytes);
        this.view = newView;
        this.bytes = newBytes;
    };
    Encoder.prototype.encodeNil = function() {
        this.writeU8(0xc0);
    };
    Encoder.prototype.encodeBoolean = function(object) {
        if (object === false) {
            this.writeU8(0xc2);
        } else {
            this.writeU8(0xc3);
        }
    };
    Encoder.prototype.encodeNumber = function(object) {
        if (Number.isSafeInteger(object) && !this.forceIntegerToFloat) {
            if (object >= 0) {
                if (object < 0x80) {
                    // positive fixint
                    this.writeU8(object);
                } else if (object < 0x100) {
                    // uint 8
                    this.writeU8(0xcc);
                    this.writeU8(object);
                } else if (object < 0x10000) {
                    // uint 16
                    this.writeU8(0xcd);
                    this.writeU16(object);
                } else if (object < 0x100000000) {
                    // uint 32
                    this.writeU8(0xce);
                    this.writeU32(object);
                } else {
                    // uint 64
                    this.writeU8(0xcf);
                    this.writeU64(object);
                }
            } else {
                if (object >= -0x20) {
                    // negative fixint
                    this.writeU8(0xe0 | object + 0x20);
                } else if (object >= -0x80) {
                    // int 8
                    this.writeU8(0xd0);
                    this.writeI8(object);
                } else if (object >= -0x8000) {
                    // int 16
                    this.writeU8(0xd1);
                    this.writeI16(object);
                } else if (object >= -0x80000000) {
                    // int 32
                    this.writeU8(0xd2);
                    this.writeI32(object);
                } else {
                    // int 64
                    this.writeU8(0xd3);
                    this.writeI64(object);
                }
            }
        } else {
            // non-integer numbers
            if (this.forceFloat32) {
                // float 32
                this.writeU8(0xca);
                this.writeF32(object);
            } else {
                // float 64
                this.writeU8(0xcb);
                this.writeF64(object);
            }
        }
    };
    Encoder.prototype.writeStringHeader = function(byteLength) {
        if (byteLength < 32) {
            // fixstr
            this.writeU8(0xa0 + byteLength);
        } else if (byteLength < 0x100) {
            // str 8
            this.writeU8(0xd9);
            this.writeU8(byteLength);
        } else if (byteLength < 0x10000) {
            // str 16
            this.writeU8(0xda);
            this.writeU16(byteLength);
        } else if (byteLength < 0x100000000) {
            // str 32
            this.writeU8(0xdb);
            this.writeU32(byteLength);
        } else {
            throw new Error("Too long string: ".concat(byteLength, " bytes in UTF-8"));
        }
    };
    Encoder.prototype.encodeString = function(object) {
        var maxHeaderSize = 1 + 4;
        var strLength = object.length;
        if (strLength > __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["TEXT_ENCODER_THRESHOLD"]) {
            var byteLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Count"])(object);
            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
            this.writeStringHeader(byteLength);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8EncodeTE"])(object, this.bytes, this.pos);
            this.pos += byteLength;
        } else {
            var byteLength = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8Count"])(object);
            this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);
            this.writeStringHeader(byteLength);
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$utf8$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["utf8EncodeJs"])(object, this.bytes, this.pos);
            this.pos += byteLength;
        }
    };
    Encoder.prototype.encodeObject = function(object, depth) {
        // try to encode objects with custom codec first of non-primitives
        var ext = this.extensionCodec.tryToEncode(object, this.context);
        if (ext != null) {
            this.encodeExtension(ext);
        } else if (Array.isArray(object)) {
            this.encodeArray(object, depth);
        } else if (ArrayBuffer.isView(object)) {
            this.encodeBinary(object);
        } else if (typeof object === "object") {
            this.encodeMap(object, depth);
        } else {
            // symbol, function and other special object come here unless extensionCodec handles them.
            throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(object)));
        }
    };
    Encoder.prototype.encodeBinary = function(object) {
        var size = object.byteLength;
        if (size < 0x100) {
            // bin 8
            this.writeU8(0xc4);
            this.writeU8(size);
        } else if (size < 0x10000) {
            // bin 16
            this.writeU8(0xc5);
            this.writeU16(size);
        } else if (size < 0x100000000) {
            // bin 32
            this.writeU8(0xc6);
            this.writeU32(size);
        } else {
            throw new Error("Too large binary: ".concat(size));
        }
        var bytes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$typedArrays$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["ensureUint8Array"])(object);
        this.writeU8a(bytes);
    };
    Encoder.prototype.encodeArray = function(object, depth) {
        var size = object.length;
        if (size < 16) {
            // fixarray
            this.writeU8(0x90 + size);
        } else if (size < 0x10000) {
            // array 16
            this.writeU8(0xdc);
            this.writeU16(size);
        } else if (size < 0x100000000) {
            // array 32
            this.writeU8(0xdd);
            this.writeU32(size);
        } else {
            throw new Error("Too large array: ".concat(size));
        }
        for(var _i = 0, object_1 = object; _i < object_1.length; _i++){
            var item = object_1[_i];
            this.doEncode(item, depth + 1);
        }
    };
    Encoder.prototype.countWithoutUndefined = function(object, keys) {
        var count = 0;
        for(var _i = 0, keys_1 = keys; _i < keys_1.length; _i++){
            var key = keys_1[_i];
            if (object[key] !== undefined) {
                count++;
            }
        }
        return count;
    };
    Encoder.prototype.encodeMap = function(object, depth) {
        var keys = Object.keys(object);
        if (this.sortKeys) {
            keys.sort();
        }
        var size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;
        if (size < 16) {
            // fixmap
            this.writeU8(0x80 + size);
        } else if (size < 0x10000) {
            // map 16
            this.writeU8(0xde);
            this.writeU16(size);
        } else if (size < 0x100000000) {
            // map 32
            this.writeU8(0xdf);
            this.writeU32(size);
        } else {
            throw new Error("Too large map object: ".concat(size));
        }
        for(var _i = 0, keys_2 = keys; _i < keys_2.length; _i++){
            var key = keys_2[_i];
            var value = object[key];
            if (!(this.ignoreUndefined && value === undefined)) {
                this.encodeString(key);
                this.doEncode(value, depth + 1);
            }
        }
    };
    Encoder.prototype.encodeExtension = function(ext) {
        var size = ext.data.length;
        if (size === 1) {
            // fixext 1
            this.writeU8(0xd4);
        } else if (size === 2) {
            // fixext 2
            this.writeU8(0xd5);
        } else if (size === 4) {
            // fixext 4
            this.writeU8(0xd6);
        } else if (size === 8) {
            // fixext 8
            this.writeU8(0xd7);
        } else if (size === 16) {
            // fixext 16
            this.writeU8(0xd8);
        } else if (size < 0x100) {
            // ext 8
            this.writeU8(0xc7);
            this.writeU8(size);
        } else if (size < 0x10000) {
            // ext 16
            this.writeU8(0xc8);
            this.writeU16(size);
        } else if (size < 0x100000000) {
            // ext 32
            this.writeU8(0xc9);
            this.writeU32(size);
        } else {
            throw new Error("Too large extension object: ".concat(size));
        }
        this.writeI8(ext.type);
        this.writeU8a(ext.data);
    };
    Encoder.prototype.writeU8 = function(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setUint8(this.pos, value);
        this.pos++;
    };
    Encoder.prototype.writeU8a = function(values) {
        var size = values.length;
        this.ensureBufferSizeToWrite(size);
        this.bytes.set(values, this.pos);
        this.pos += size;
    };
    Encoder.prototype.writeI8 = function(value) {
        this.ensureBufferSizeToWrite(1);
        this.view.setInt8(this.pos, value);
        this.pos++;
    };
    Encoder.prototype.writeU16 = function(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setUint16(this.pos, value);
        this.pos += 2;
    };
    Encoder.prototype.writeI16 = function(value) {
        this.ensureBufferSizeToWrite(2);
        this.view.setInt16(this.pos, value);
        this.pos += 2;
    };
    Encoder.prototype.writeU32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setUint32(this.pos, value);
        this.pos += 4;
    };
    Encoder.prototype.writeI32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setInt32(this.pos, value);
        this.pos += 4;
    };
    Encoder.prototype.writeF32 = function(value) {
        this.ensureBufferSizeToWrite(4);
        this.view.setFloat32(this.pos, value);
        this.pos += 4;
    };
    Encoder.prototype.writeF64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        this.view.setFloat64(this.pos, value);
        this.pos += 8;
    };
    Encoder.prototype.writeU64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setUint64"])(this.view, this.pos, value);
        this.pos += 8;
    };
    Encoder.prototype.writeI64 = function(value) {
        this.ensureBufferSizeToWrite(8);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$utils$2f$int$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["setInt64"])(this.view, this.pos, value);
        this.pos += 8;
    };
    return Encoder;
}();
;
 //# sourceMappingURL=Encoder.mjs.map
}}),
"[project]/node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "encode": (()=>encode)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$Encoder$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/Encoder.mjs [app-route] (ecmascript)");
;
var defaultEncodeOptions = {};
function encode(value, options) {
    if (options === void 0) {
        options = defaultEncodeOptions;
    }
    var encoder = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$Encoder$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["Encoder"](options.extensionCodec, options.context, options.maxDepth, options.initialBufferSize, options.sortKeys, options.forceFloat32, options.ignoreUndefined, options.forceIntegerToFloat);
    return encoder.encodeSharedRef(value);
} //# sourceMappingURL=encode.mjs.map
}}),
"[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// these are the codes that are used to determine the rudimentary type of numbers
var PROPERTY_CODE = 0;
var TYPE_CODE = 3;
var STRING_CODE = 2;
var NUMBER_CODE = 1;
var SEQUENCE_CODE = 7;
// constant codes
var NULL = 0 // p
;
var FALSE = 3 // s
;
var TRUE = 4 // t
;
var UNDEFINED = 5 // u
;
// these are the starting codes (structures also use this space) for complete types
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
var REFERENCING_TYPE = 8;
var NUMBER_TYPE = 9;
var EXTENSIONS = 10;
var METADATA_TYPE = 11;
var COPY_PROPERTY = 12 // for defining a typed object without returning the value
;
var REFERENCING_POSITION = 13;
var TYPE_DEFINITION = 14 // for defining a typed object without returning the value
;
var ERROR_METADATA = 500;
// sequence codes
var OPEN_SEQUENCE = 12 // <
;
var PARTIAL_DEFERRED_REFERENCE = 12 // <
;
var END_SEQUENCE = 14 // >
;
var DEFERRED_REFERENCE = 15 // ?
;
var nextId = 1;
var iteratorSymbol = typeof Symbol !== 'undefined' ? Symbol.iterator : '__iterator_symbol__';
function createSerializer(options) {
    if (!options) options = {};
    var extendedTypes = options.converterByConstructor;
    if (!extendedTypes) {
        extendedTypes = new Map();
    }
    extendedTypes.set(Map, {
        name: 'Map',
        toValue: writeMap
    });
    extendedTypes.set(Set, {
        name: 'Set',
        toValue: writeSet
    });
    extendedTypes.set(Date, {
        name: 'Date',
        toValue: writeDate
    });
    var avoidShareUpdate = options.outlet || options.avoidShareUpdate;
    var charEncoder = typeof global != 'undefined' && global.Buffer && !(options && options.encoding === 'utf16le') ? exports.nodeCharEncoder(options) : browserCharEncoder(options);
    var writeString = charEncoder.writeString;
    var writeToken = charEncoder.writeToken;
    var startSequence = charEncoder.startSequence;
    var endSequence = charEncoder.endSequence;
    var writeBuffer = charEncoder.writeBuffer;
    var forProperty = options.forProperty;
    var propertyUsed;
    var valueUsed;
    if (options.shared) {
        propertyUsed = options.shared.propertyUsed;
        valueUsed = options.shared.propertyUsed;
    }
    var pendingEncodings = [];
    var nextPropertyIndex = 8;
    var property;
    var bufferSymbol = exports.bufferSymbol || '_bufferSymbol_';
    var targetSymbol = exports.targetSymbol || '_targetSymbol_';
    var propertyComparisons = 0;
    var serializerId = nextId++;
    var writers = [
        0,
        1,
        2,
        3,
        4,
        5,
        writeAsDefault,
        writeAsArray,
        writeAsReferencing,
        writeAsNumber,
        writeOnlyNull
    ];
    // write a rudimentary number
    function writeNumber(number) {
        writeToken(NUMBER_CODE, number);
    }
    // write a rudimentary string
    function writeInlineString(string) {
        writeToken(STRING_CODE, string.length);
        writeString(string);
    }
    // writing any value in referencing serialization type mode
    function writeAsReferencing(value) {
        var type, values = property.values;
        if (values) {
            if (values.resetTo > -1 && values.serializer !== serializerId) {
                // if this is a shared values, need to reset on each serialization
                values.serializer = serializerId;
                if (values.resetTo < values.length) values.length = values.resetTo;
                writeToken(TYPE_CODE, REFERENCING_POSITION);
                writeToken(NUMBER_CODE, values.resetTo);
            }
            var reference = values.indexOf(value);
            if (reference > -1) {
                return writeNumber(reference);
            }
        }
        if ((type = typeof value) === 'string' || type === 'object' && value) {
            if (property.writeSharedValue) {
                if (property.writeSharedValue(value, writeToken, serializerId)) return;
            } else if (values) {
                var index = values.length;
                if (index < 12) values[index] = value;
            }
        }
        if (type === 'string') {
            writeInlineString(value);
        } else {
            writeAsDefault(value);
        }
    }
    // writing any value in number serialization type mode
    function writeAsNumber(number) {
        var type = typeof number;
        if (type === 'number') {
            if (number >>> 0 === number || number > 0 && number < 0x400000000000 && number % 1 === 0) {
                // 46 bit unsigned integer
                writeToken(NUMBER_CODE, number);
            } else {
                // decimal number serialized as a string
                var asString = number.toString();
                writeInlineString(asString);
            }
        } else if (type === 'object') {
            writeAsDefault(number);
        } else {
            writeTypedValue(number);
        }
    }
    function writeTypedValue(value) {
        if (value === null) writeToken(TYPE_CODE, NULL);
        else if (value === false) writeToken(TYPE_CODE, FALSE);
        else if (value === true) writeToken(TYPE_CODE, TRUE);
        else if (value === undefined) writeToken(TYPE_CODE, UNDEFINED);
        else {
            writeTypedNonConstant(value);
        }
    }
    function writeTypedNonConstant(value) {
        var type = typeof value;
        var extendedType;
        if (type === 'object') {
            if (value) {
                var constructor = value.constructor;
                if (constructor === Object) {
                // leave type as is
                } else if (constructor === Array) {
                    type = 'array';
                } else {
                    extendedType = extendedTypes.get(constructor);
                    if (extendedType && extendedType.toValue) {
                        value = extendedType.toValue(value);
                        type = typeof value // go through the same logic adjustment here
                        ;
                        if (value && type === 'object' && value.constructor === Array) {
                            type = 'array';
                        }
                        if (property.type === type) {
                            // if we are the right type after doing the conversion, go back to the original property to serialize
                            if (property.extendedType !== extendedType) {
                                property.extendedType = extendedType;
                                writeToken(TYPE_CODE, METADATA_TYPE);
                                writeInlineString(extendedType.name);
                            }
                            return writers[property.code](value);
                        }
                    } else {
                        extendedType = false;
                    }
                }
            } else {
                type = 'undefined' // treat null as same type as undefined, both constants
                ;
            }
        } else if (type === 'boolean') {
            type = 'undefined';
        } else if (type === 'function') {
            value = value.toString();
            type = 'string';
        }
        property = writeProperty(null, type, extendedType);
        writers[property.code](value);
    }
    function writeOnlyNull() {
        writeToken(TYPE_CODE, NULL);
    }
    // writing any value in default serialization type mode
    function writeAsDefault(value, isRoot) {
        var type = typeof value;
        if (type === 'object') {
            if (!value) {
                return writeToken(TYPE_CODE, NULL);
            }
        // else continue with the object code
        } else if (type === 'string') {
            return writeInlineString(value);
        } else if (type === 'number' && (value >>> 0 === value || value > 0 && value < 0x400000000000 && value % 1 === 0)) {
            // 46 bit unsigned integer
            return writeToken(NUMBER_CODE, value);
        } else {
            return writeTypedValue(value);
        }
        var object = value;
        var constructor = object.constructor;
        var notPlainObject;
        if (object[targetSymbol]) {
            return writeBlockReference(value);
        } else if (constructor === Object) {
            notPlainObject = false;
        } else if (constructor === Array) {
            property = writeProperty(property.key, 'array');
            return writers[property.code](value);
        } else {
            if (object.then) {
                return writeBlockReference(value);
            }
            extendedType = extendedTypes.get(constructor);
            if (extendedType) {
                if (extendedType.toValue) {
                    return writeTypedValue(object);
                }
            } else {
                if (object[iteratorSymbol]) {
                    property = writeProperty(property.key, 'array');
                    return writeAsIterable(object, isRoot);
                }
                extendedTypes.set(constructor, extendedType = {
                    name: constructor.name
                });
            }
            if (property.constructs !== constructor) {
                writeToken(TYPE_CODE, METADATA_TYPE);
                writeInlineString(extendedType.name);
                property.constructs = constructor;
            }
            notPlainObject = true;
        }
        var thisProperty = property;
        if (thisProperty.resetTo < thisProperty.length && thisProperty.serializer != serializerId) {
            thisProperty.length = thisProperty.resetTo;
            thisProperty.serializer = serializerId;
        }
        startSequence();
        var i = 0;
        //var sparse = false // densely packed property references can be searched more quickly
        var resumeIndex = -2 // -2 denotes densely packed property references 
        ;
        var propertyIndex = 0;
        for(var key in object){
            if (notPlainObject && !object.hasOwnProperty(key)) continue;
            var value = object[key];
            type = typeof value;
            property = thisProperty[propertyIndex];
            var constructor;
            var extendedType = false;
            if (type === 'object') {
                if (value) {
                    constructor = value.constructor;
                    if (constructor === Object) {
                    // leave type as is
                    } else if (constructor === Array) {
                        type = 'array';
                    } else {
                        extendedType = extendedTypes.get(constructor);
                        if (extendedType && extendedType.toValue) {
                            value = extendedType.toValue(value);
                            type = typeof value // go through the same logic adjustment here
                            ;
                            if (value && type === 'object' && value.constructor === Array) {
                                type = 'array';
                            }
                        } else if (value[iteratorSymbol] && !value.then) {
                            type = 'array';
                        } else {
                            extendedType = false;
                        }
                    }
                } else {
                    type = 'undefined' // treat null as same type as undefined (and boolean), both constants that can go in any type
                    ;
                }
            }
            if (!property || property.key !== key || property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor) {
                var lastPropertyIndex = propertyIndex;
                // property doesn't match, search for it through existing properties
                // note that we are starting at the current propertyIndex, so this makes the assumption that
                // properties are rarely ever swapped, so possible property slots are always forward
                if (resumeIndex > -2) propertyIndex = resumeIndex;
                do {
                    property = thisProperty[++propertyIndex];
                }while (property && (property.key !== key || property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor))
                if (property) {
                    // found a match, reference it
                    writeToken(PROPERTY_CODE, propertyIndex);
                    if (resumeIndex === -2) {
                        resumeIndex = lastPropertyIndex - 1;
                    }
                } else if (thisProperty.getProperty) {
                    // a shared property, let it allocate ids
                    property = thisProperty.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex);
                    propertyIndex = property.index;
                    if (lastPropertyIndex !== propertyIndex && resumeIndex === -2) {
                        resumeIndex = lastPropertyIndex - 1;
                    }
                } else {
                    if (lastPropertyIndex === thisProperty.length) {
                        propertyIndex = lastPropertyIndex;
                    } else {
                        writeToken(PROPERTY_CODE, propertyIndex = thisProperty.length);
                        if (resumeIndex === -2) {
                            resumeIndex = lastPropertyIndex - 1;
                        }
                    }
                    if (propertyIndex < thisProperty.resetTo) {
                        debugger;
                        throw new Error('overwriting frozen property');
                    }
                    property = thisProperty[propertyIndex] = writeProperty(key, type, extendedType);
                }
            }
            if (propertyUsed) propertyUsed(property, object, serializerId, i);
            //			if (property.resumeIndex) // TODO: add a flag to enable this when property ordering can be assumed
            //				resumeIndex = property.resumeIndex
            var code = property.code;
            if (code > 7) {
                if (code === 8) writeAsReferencing(value);
                else writeAsNumber(value);
            } else {
                if (code === 6) writeAsDefault(value);
                else writeAsArray(value);
            }
            propertyIndex++;
            i++;
        }
        property = thisProperty;
        endSequence(i);
    }
    function writeProperty(key, type, extendedType) {
        var property;
        property = [];
        property.key = key;
        property.type = type;
        if (type === 'string') {
            writeToken(TYPE_CODE, REFERENCING_TYPE);
            property.values = [];
            property.code = REFERENCING_TYPE;
        } else if (type === 'number') {
            writeToken(TYPE_CODE, NUMBER_TYPE);
            property.code = NUMBER_TYPE;
        } else if (type === 'object') {
            writeToken(TYPE_CODE, DEFAULT_TYPE);
            property.code = DEFAULT_TYPE;
        } else if (type === 'array') {
            writeToken(TYPE_CODE, ARRAY_TYPE);
            property.code = ARRAY_TYPE;
        } else if (type === 'boolean' || type === 'undefined') {
            property.type = 'object';
            writeToken(TYPE_CODE, DEFAULT_TYPE);
            property.code = DEFAULT_TYPE;
        } else {
            writeToken(TYPE_CODE, DEFAULT_TYPE);
            property.code = 10;
            console.error('Unable to write value of type ' + type);
        }
        if (typeof key === 'string') {
            writeInlineString(key);
        } else if (!(key === null && (type === 'object' || type === 'array'))) {
            writeAsDefault(key);
        }
        if (extendedType) {
            property.extendedType = extendedType;
            writeToken(TYPE_CODE, METADATA_TYPE);
            writeInlineString(extendedType.name);
        }
        return property;
    }
    function writeAsIterable(iterable, isRoot, iterator) {
        // TODO: With top level iterables we could pause for back-pressure
        try {
            if (!iterator) {
                writeToken(SEQUENCE_CODE, OPEN_SEQUENCE);
                iterator = iterable[iteratorSymbol]();
            }
            var arrayProperty = property;
            property = arrayProperty.child || (arrayProperty.child = arrayProperty) // set the current property to the child property
            ;
            // write out the elements
            var result;
            while(!(result = iterator.next()).done){
                writers[property.code](result.value, arrayProperty);
                if (isRoot && charEncoder.hasWritten) {
                    charEncoder.hasWritten = false // reset this property
                    ;
                    property = arrayProperty // restore current property
                    ;
                    pendingEncodings.unshift({
                        then: function(callback) {
                            writeAsIterable(null, true, iterator);
                            return callback();
                        }
                    });
                    return;
                }
            }
        } catch (error) {
            writeToken(TYPE_CODE, METADATA_TYPE);
            writeToken(NUMBER_CODE, ERROR_METADATA);
            writeAsDefault(Object.assign(new (typeof error == 'object' && error ? error.constructor : Error)(), {
                name: error && error.name,
                message: error && error.message || error
            }));
            throw error;
        }
        if (property !== arrayProperty.child) {
            // TODO: This really needs to happen immediately when a property changes, to match the parsing behavior
            arrayProperty.child = property;
        }
        property = arrayProperty // restore current property
        ;
        writeToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence
        ;
    }
    function writeAsArray(array) {
        if (!array) {
            writeTypedValue(array);
        } else if (array[targetSymbol]) {
            return writeBlockReference(array);
        } else if (array.constructor === Array) {
            var length = array.length;
            var needsClosing;
            if (length > 11) {
                writeToken(SEQUENCE_CODE, OPEN_SEQUENCE) // start sequence <
                ;
                needsClosing = true;
            } else {
                writeToken(SEQUENCE_CODE, length) // write out the header token
                ;
            }
            var arrayProperty = property;
            property = arrayProperty[0] // set the current property to the child property
            ;
            // check to see if needs to be reset before starting
            if (arrayProperty.resetTo < arrayProperty.length && arrayProperty.serializer != serializerId) {
                arrayProperty.length = arrayProperty.resetTo;
                arrayProperty.serializer = serializerId;
            }
            var propertyIndex = 0;
            // write out the elements
            for(var i = 0; i < length; i++){
                var value = array[i];
                var type = typeof value;
                if (type === 'object') {
                    if (value) {
                        var constructor = value.constructor;
                        if (constructor === Object) {
                        // leave type as is
                        } else if (constructor === Array) {
                            type = 'array';
                        } else {
                            var extendedType = extendedTypes.get(constructor);
                            if (extendedType && extendedType.toValue) {
                                value = extendedType.toValue(value);
                                type = typeof value // go through the same logic adjustment here
                                ;
                                if (value && type === 'object' && value.constructor === Array) {
                                    type = 'array';
                                }
                            } else {
                                extendedType = false;
                            }
                        }
                    } else {
                        type = 'undefined' // treat null as same type as undefined, both constants
                        ;
                    }
                }
                if (!property) {
                    if (arrayProperty.getProperty) {
                        // a shared property
                        property = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, 0);
                    } else {
                        if (type === 'string' || type === 'number' || type === 'array') property = writeProperty(null, type, extendedType);
                        else {
                            // default doesn't have to be written
                            property = [];
                            property.type = type;
                            property.key = null;
                            property.code = DEFAULT_TYPE;
                        }
                        arrayProperty[0] = property;
                    }
                } else if (property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor) {
                    propertyIndex = -1;
                    do {
                        property = arrayProperty[++propertyIndex];
                    }while (property && (property.type !== type && type !== 'boolean' && type !== 'undefined' && !(type === 'string' && property.type !== 'number') || extendedType && property.extendedType !== constructor))
                    if (property) {
                        writeToken(PROPERTY_CODE, propertyIndex);
                    } else if (arrayProperty.getProperty) {
                        // a shared property
                        property = arrayProperty.getProperty(value, null, type, extendedType, writeProperty, writeToken, -1);
                    } else {
                        writeToken(PROPERTY_CODE, propertyIndex);
                        property = writeProperty(null, type, extendedType);
                        arrayProperty[propertyIndex] = property;
                    }
                }
                if (propertyUsed) propertyUsed(property, array, serializerId, i);
                var code = property.code;
                if (code > 7) {
                    if (code === 8) writeAsReferencing(value);
                    else writeAsNumber(value);
                } else {
                    if (code === 6) writeAsDefault(value);
                    else writeAsArray(value);
                }
            }
            if (needsClosing) {
                writeToken(SEQUENCE_CODE, END_SEQUENCE) // end sequence
                ;
            }
            property = arrayProperty // restore current property
            ;
        } else if (typeof array == 'object' && array[iteratorSymbol]) {
            return writeAsIterable(array);
        } else if (type === 'string') {
            return writeInlineString(value);
        } else if (type === 'number' && (value >>> 0 === value || value > 0 && value < 0x400000000000 && value % 1 === 0)) {
            return writeToken(NUMBER_CODE, value);
        } else {
            writeTypedValue(array);
        }
    }
    var blockProperty;
    function writeBlockReference(block, writer) {
        writeToken(SEQUENCE_CODE, DEFERRED_REFERENCE);
        var blockProperty = property;
        var lazyPromise = block[targetSymbol] ? {
            then: then
        } : {
            then: function(callback) {
                return block.then(function(value) {
                    block = value;
                    then(callback);
                }, function(error) {
                    block = Object.assign(new (typeof error == 'object' && error ? error.constructor : Error)(), {
                        name: error && error.name,
                        message: error && error.message || error
                    });
                    if (!blockProperty.upgrade) {
                        writeToken(TYPE_CODE, METADATA_TYPE);
                        writeToken(NUMBER_CODE, ERROR_METADATA);
                    }
                    then(callback);
                });
            }
        };
        function then(callback) {
            if (options.forBlock && block) {
                // this is used by the sizeTable serializer to record the size of each block
                options.forBlock(block, blockProperty);
            } else {
                var buffer = block && block[bufferSymbol] && block[bufferSymbol](blockProperty);
                if (buffer) {
                    writeBuffer(buffer);
                } else {
                    property = blockProperty;
                    var lastPendingEncodings = pendingEncodings;
                    pendingEncodings = [] // record any nested pending encoding separately
                    ;
                    writeAsDefault(block, true) // write it out as the next block
                    ;
                    lastPendingEncodings.unshift.apply(lastPendingEncodings, pendingEncodings) // and splice them in front
                    ;
                    pendingEncodings = lastPendingEncodings;
                }
            }
            callback();
        }
        pendingEncodings.push(lazyPromise);
    }
    var serializer = {
        serialize: function(value, sharedProperty) {
            var buffer = value && value[bufferSymbol] && value[bufferSymbol](sharedProperty);
            if (buffer) {
                charEncoder.writeBuffer(buffer);
                return;
            }
            if (sharedProperty) {
                property = sharedProperty;
                writers[property.code](value);
            } else {
                property = [];
                property.key = null;
                writeAsDefault(value, true);
            }
        },
        getSerialized: function() {
            if (pendingEncodings.length > 0) {
                var promises = [];
                while(pendingEncodings.length > 0){
                    var finished = false;
                    var promise = pendingEncodings.shift().then(function() {
                        finished = true;
                    });
                    if (!finished) {
                        promises.push(promise);
                    }
                }
                if (promises.length > 0) {
                    return Promise.all(promises).then(function() {
                        return serializer.getSerialized();
                    });
                }
            }
            if (options && options.encoding === 'utf16le') {
                return Buffer.from(charEncoder.getSerialized(), 'utf16le');
            }
            return charEncoder.getSerialized();
        },
        flush: charEncoder.flush,
        setOffset: charEncoder.setOffset,
        finish: charEncoder.finish,
        pendingEncodings: pendingEncodings,
        getWriters: function() {
            return {
                writeProperty: writeProperty,
                writeToken: writeToken,
                writeAsDefault: writeAsDefault,
                writeBuffer: writeBuffer
            };
        }
    };
    return serializer;
}
function serialize(value, options) {
    var serializer = createSerializer(options);
    var sharedProperty = options && options.shared;
    var buffer;
    if (sharedProperty && sharedProperty.startWrite) {
        // record the start of each write
        sharedProperty.startWrite(options.avoidShareUpdate, value);
    }
    serializer.serialize(value, sharedProperty);
    buffer = serializer.getSerialized();
    if (sharedProperty && sharedProperty.endWrite) {
        // record the end of each write
        sharedProperty.endWrite(options.avoidShareUpdate, value);
    }
    if (serializer.finish) serializer.finish();
    var sizeTable = value && value[exports.sizeTableSymbol];
    if (sizeTable) {
        buffer.sizeTable = sizeTable;
    }
    if (options && options.lazy) {
        return Buffer.concat([
            value[exports.sizeTableSymbol],
            buffer
        ]);
    }
    return buffer;
}
exports.serialize = serialize;
exports.createSerializer = createSerializer;
function browserCharEncoder() {
    var serialized = '';
    function writeToken(type, number) {
        var serializedToken;
        if (number < 0x10) {
            serializedToken = String.fromCharCode((type << 4 | number) ^ 0x40);
        } else if (number < 0x400) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 6), (number & 0x3f) + 0x40);
        } else if (number < 0x10000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 12), number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x400000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 18), number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x10000000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 24), number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x100000000) {
            serializedToken = String.fromCharCode((type << 4) + (number >>> 30), number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x400000000) {
            serializedToken = String.fromCharCode((type << 4) + (number / 0x40000000 >>> 0), number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x10000000000) {
            serializedToken = String.fromCharCode((type << 4) + (number / 0x1000000000 >>> 0), number / 0x40000000 & 0x3f, number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else if (number < 0x400000000000) {
            serializedToken = String.fromCharCode((type << 4) + (number / 0x40000000000 >>> 0), number / 0x1000000000 & 0x3f, number / 0x40000000 & 0x3f, number >>> 24 & 0x3f, number >>> 18 & 0x3f, number >>> 12 & 0x3f, number >>> 6 & 0x3f, (number & 0x3f) + 0x40);
        } else {
            throw new Error('Too big of number');
        }
        serialized += serializedToken;
    }
    function writeString(string) {
        serialized += string;
    }
    function getSerialized() {
        return serialized;
    }
    return {
        writeToken: writeToken,
        writeString: writeString,
        //writeBuffer,
        getSerialized: getSerialized,
        //insertBuffer,
        //flush,
        startSequence: function() {
            writeToken(SEQUENCE_CODE, OPEN_SEQUENCE);
        },
        endSequence: function() {
            writeToken(SEQUENCE_CODE, END_SEQUENCE);
        },
        getOffset: function() {
            return -1;
        }
    };
}
var ArrayFrom = Array.from || function(iterable, keyValue) {
    var array = [];
    var keyValue = iterable.constructor === Map;
    iterable.forEach(function(key, value) {
        if (keyValue) {
            array.push([
                value,
                key
            ]);
        } else {
            array.push(key);
        }
    });
    return array;
};
function writeMap(map) {
    var keyValues = ArrayFrom(map);
    for(var i = 0, length = keyValues.length; i < length; i++){
        var keyValue = keyValues[i];
        keyValues[i] = {
            key: keyValue[0],
            value: keyValue[1]
        };
    }
    return keyValues;
}
function writeSet(set) {
    return ArrayFrom(set);
}
function writeDate(date) {
    return date.getTime();
}
}}),
"[project]/node_modules/dpack/lib/serialize-stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const { Transform } = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)");
const { createSerializer } = __turbopack_context__.r("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)");
// a readable stream for serializing a set of variables to a JSON stream
class DPackSerializeStream extends Transform {
    constructor(options){
        // Calls the stream.Readable(options) constructor
        options = options || {};
        super(options);
        this.options = options;
        this.continueWriting = true;
    }
    write(value) {
        const serializer = this.serializer || (this.serializer = createSerializer({
            asBlock: true
        }));
        serializer.serialize(value);
        const buffer = serializer.getSerialized();
        if (buffer.then) {
            // we need to wait for this to finish, spawn a new serializer to handle any other writes
            buffer.then((buffer)=>this.push(buffer));
            this.serializer = null;
        } else {
            serializer.flush(this);
        }
    }
    end(value) {
        if (value) {
            this.options.outlet = this;
            const serializer = this.serializer || (this.serializer = createSerializer(this.options));
            serializer.serialize(value) // we do not need to write the last value as a block, its state won't affect anything afterwards
            ;
        }
        if (this.serializer.pendingEncodings.length > 0) {
            this.endWhenDone = true;
            this.writeNext();
        } else {
            this.serializer.flush();
            this.push(null);
        }
    }
    writeBytes(buffer) {
        try {
            this.continueWriting = this.push(buffer);
        } catch (error) {
            throw error;
        }
    }
    _read() {
        this.continueWriting = true;
        if (!this.pausedForPromise && this.serializer && this.endWhenDone && this.serializer.pendingEncodings.length > 0) {
            this.writeNext();
        }
    }
    writeNext() {
        var isSync;
        do {
            var hasMoreToSend = this.serializer.pendingEncodings.length > 0;
            isSync = null;
            if (hasMoreToSend) {
                this.serializer.pendingEncodings.shift().then(()=>{
                    if (isSync === false) {
                        // if we are async, call writeNext which will look for more pending encodings
                        this.pausedForPromise = false;
                        if (this.continueWriting || this.serializer.pendingEncodings.length === 0) this.writeNext();
                        else {
                            this.serializer.flush() // flush what we have before waiting for _read call
                            ;
                        }
                    } else {
                        // mark it as sync so we can exit and loop instead of recursing
                        isSync = true;
                    }
                }, (error)=>{
                    // the serializer should handle promise errors, but if that fails, end the stream with the error
                    console.error(error);
                    this.push(error.toString());
                    this.push(null);
                });
                if (!isSync) {
                    isSync = false;
                    // flush what we have so far while waiting for the promise
                    this.pausedForPromise = true;
                    this.serializer.flush();
                } else if (!this.continueWriting && this.serializer.pendingEncodings.length > 0) {
                    this.serializer.flush() // flush what we have
                    ;
                    return;
                }
            } else if (this.endWhenDone) {
                this.serializer.flush();
                this.push(']');
                this.push(null);
            }
        }while (isSync)
    }
}
exports.createSerializeStream = ()=>{
    return new DPackSerializeStream();
};
}}),
"[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
// type codes:
// these are the codes that are used to determine the rudimentary type of numbers
var PROPERTY_CODE = 0;
var TYPE_CODE = 3;
var STRING_CODE = 2;
var NUMBER_CODE = 1;
var SEQUENCE_CODE = 7;
// constant codes
var NULL = 0 // p
;
var FALSE = 3 // s
;
var TRUE = 4 // t
;
var UNDEFINED = 5 // u
;
// these are the starting codes (structures also use this space) for complete types
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
var REFERENCING_TYPE = 8;
var NUMBER_TYPE = 9;
var EXTENSIONS = 10;
var METADATA_TYPE = 11;
var COPY_PROPERTY = 12 // for defining a typed object without returning the value
;
var REFERENCING_POSITION = 13;
var TYPE_DEFINITION = 14 // for defining a typed object without returning the value
;
var ERROR_METADATA = 500;
// sequence codes
var OPEN_SEQUENCE = 12 // <
;
var PARTIAL_DEFERRED_REFERENCE = 12 // <
;
var END_SEQUENCE = 14 // >
;
var DEFERRED_REFERENCE = 15 // ?
;
var MAX_LENGTH = 1024 * 1024 * 16;
var PAUSED = {};
function createParser(options) {
    if (!options) options = {};
    var offset;
    var source;
    var isPartial;
    var classByName = options.classByName || new Map();
    classByName.set('Map', readMap);
    classByName.set('Set', readSet);
    classByName.set('Date', readDate);
    var pausedState;
    var deferredReads;
    function pause(state, lastRead) {
        state.previous = pausedState;
        state.resume = true;
        pausedState = state;
        if (!isPartial) throw new Error('Unexpected end of dpack stream');
        if (!parser.onResume) parser.onResume = function(nextString, isPartialString, rebuildString) {
            // top of the resume stack
            var resumeState = pausedState;
            pausedState = null;
            parser.onResume = null;
            // we slice and add these together to generate an entirely new string
            // so we don't cause a memory leak with redundant strings that a retained a slice parents
            if (lastRead < source.length) source = source.slice(lastRead) + nextString;
            else {
                if (rebuildString) source = nextString.slice(0, 1) + nextString.slice(1);
                else source = nextString;
            }
            isPartial = isPartialString;
            disposedChars += lastRead;
            offset = 0;
            return resumeState.reader ? resumeState.reader(resumeState) : readSequence(resumeState.length, resumeState);
        };
        return state.object;
    }
    function readSequence(length, thisProperty) {
        /* propertyStates:
		0 - starting next property slot
		1 - property created, succeeding value should be value of property
		2 - property creation in progress, next value should define key
		11+ - modifying property, next value modifies property (adds metadata, position, type, etc.)
		*/ var propertyState = 0;
        thisProperty = thisProperty || [];
        var property, isArray, object, value, i = 0, propertyIndex = 0;
        if (thisProperty.resume) {
            property = thisProperty.previous;
            if (property) {
                // do the previous/upper stack frame first
                var value = property.reader ? property.reader(property) : readSequence(property.length, property);
                var values = property.values;
                if (values) {
                    // we have an assignment to referencing values that is waiting for pausing to complete
                    if (pausedState) {
                        // if still paused, pass on to next pausedState
                        pausedState.values = values;
                    } else {
                        if (value.nextPosition > -1) {
                            // we use this path for fulfilling forward references, and when the position is reset
                            values[values.nextPosition++] = value;
                        } else {
                            values.push(value);
                        }
                    }
                }
            }
            if (thisProperty.code && thisProperty.code !== thisProperty.thisProperty.code) {
                thisProperty.resume = false // if the resume property has been reassigned to an incompatible type, can't switch
                ;
            } else {
                i = thisProperty.i || 0;
                object = thisProperty.object;
                propertyState = thisProperty.propertyState || 0;
                propertyIndex = thisProperty.propertyIndex || 0;
                thisProperty = thisProperty.thisProperty;
            }
        }
        isArray = thisProperty.code === ARRAY_TYPE /*ARRAY_TYPE*/ ;
        object = object || (thisProperty.constructs ? new thisProperty.constructs() : isArray ? [] : {}) // TODO: we could probably construct a new reader that does this a little faster
        ;
        for(; i < length;){
            var type, number;
            var lastRead = offset;
            var token = source.charCodeAt(offset++);
            if (token >= 0x30) {
                if (token > 0x3000) {
                    type = token >>> 12 ^ 4;
                    number = token & 0xfff;
                } else {
                    type = token >>> 4 ^ 4;
                    number = token & 0xf;
                }
            } else {
                type = token >>> 4 & 11 // shift and omit the stop bit (bit 3)
                ;
                number = token & 0xf;
                token = source.charCodeAt(offset++);
                number = (number << 6) + (token & 0x3f) // 10 bit number
                ;
                if (!(token >= 0x40)) {
                    token = source.charCodeAt(offset++);
                    number = (number << 6) + (token & 0x3f) // 16 bit number
                    ;
                    if (!(token >= 0x40)) {
                        token = source.charCodeAt(offset++);
                        number = (number << 6) + (token & 0x3f) // 22 bit number
                        ;
                        if (!(token >= 0x40)) {
                            token = source.charCodeAt(offset++);
                            number = (number << 6) + (token & 0x3f) // 28 bit number
                            ;
                            if (!(token >= 0x40)) {
                                token = source.charCodeAt(offset++);
                                number = number * 0x40 + (token & 0x3f) // 34 bit number (we can't use 32-bit shifting operators anymore)
                                ;
                                if (!(token >= 0x40)) {
                                    token = source.charCodeAt(offset++);
                                    number = number * 0x40 + (token & 0x3f) // 40 bit number
                                    ;
                                    if (!(token >= 0x40)) {
                                        token = source.charCodeAt(offset++);
                                        number = number * 0x40 + (token & 0x3f) // 46 bit number, we don't go beyond this
                                        ;
                                        if (!(token >= 0)) {
                                            if (offset > source.length) {
                                                return pause({
                                                    length: length,
                                                    thisProperty: thisProperty,
                                                    i: i,
                                                    object: object,
                                                    propertyIndex: propertyIndex,
                                                    propertyState: propertyState
                                                }, lastRead);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            if (type === 0) {
                propertyIndex = number;
                propertyState = 0;
                continue;
            }
            property = thisProperty[propertyIndex];
            if (type === 3) {
                // we store the previous property state in token, so we can assign the next one
                if (number < 6) {
                    // special values (constants, deferreds)
                    if (number < 3) {
                        if (number === 0) {
                            value = null;
                        } else {
                            value = 'Unknown token, type: ' + type + ' number: ' + number;
                        }
                    } else {
                        if (number === TRUE) {
                            value = true;
                        } else if (number === FALSE) {
                            value = false;
                        } else {
                            value = undefined;
                        }
                    }
                } else {
                    if (number <= NUMBER_TYPE) {
                        // property definition
                        if (propertyState === 1) {
                            // we were in property value position, but no value, so we increment position here
                            propertyIndex++;
                            i++;
                            property = thisProperty[propertyIndex];
                        }
                        if (propertyIndex < thisProperty.resetTo) {
                            throw new Error('Overwriting frozen property');
                        }
                        if (property) {
                            if (!property.resume) {
                                value = property.key // inherit the existing key
                                ;
                                property = thisProperty[propertyIndex] = [];
                                property.key = value;
                            }
                        } else {
                            property = thisProperty[propertyIndex] = [];
                            property.key = null;
                        }
                        property.code = number;
                        property.parent = thisProperty;
                        //property.key = null
                        propertyState = 2 // read next value as the key
                        ;
                        if (number === REFERENCING_TYPE /*REFERENCING_TYPE*/ ) {
                            property.values = [];
                        } else if (number === ARRAY_TYPE) {
                            property[0] = [];
                            property[0].key = null;
                            property[0].code = DEFAULT_TYPE;
                            property[0].parent = property;
                        }
                    } else {
                        // property modification
                        propertyState = number;
                    }
                    continue;
                }
            } else {
                if (type === 2 /*STRING_CODE*/ ) {
                    value = source.slice(offset, offset += number);
                    if (offset > source.length) {
                        return pause({
                            length: length,
                            thisProperty: thisProperty,
                            i: i,
                            object: object,
                            propertyIndex: propertyIndex,
                            propertyState: propertyState
                        }, lastRead);
                    }
                    if (propertyState < 2) {
                        if (property.code === NUMBER_TYPE /*NUMBER_TYPE*/ ) {
                            value = +value;
                        }
                    }
                } else if (type === 1) {
                    value = number;
                } else {
                    if (number > 13) {
                        if (number === END_SEQUENCE) return object;
                        else if (number === DEFERRED_REFERENCE) {
                            value = readSequence(0, property);
                            propertyState = 0;
                            if (options.forDeferred) {
                                value = options.forDeferred(value, property);
                            } else {
                                (deferredReads || (deferredReads = [])).push({
                                    property: property,
                                    value: value
                                });
                            }
                        }
                    } else {
                        if (number >= OPEN_SEQUENCE) {
                            number = 2000000000;
                        }
                        if (propertyState > 1) {
                            if (propertyState === 2) {
                                propertyState = 0 // if the property key was skipped, go directly into value mode
                                ;
                                value = readSequence(number, property);
                            } else if (propertyState === METADATA_TYPE) value = readSequence(number, [
                                {
                                    key: null,
                                    code: 6
                                }
                            ]);
                            else if (property.resume && (property.code || DEFAULT_TYPE) === property.thisProperty.code) value = readSequence(number, property.thisProperty);
                            else value = readSequence(number, property);
                        } else value = readSequence(number, property);
                        if (pausedState) {
                            if (value === undefined) {
                                pausedState = null // erase anything further up in the stack, as this means the sequence couldn't start, so we need to re-parse from here
                                ;
                                parser.onResume = null;
                                return pause({
                                    length: length,
                                    thisProperty: thisProperty,
                                    i: i,
                                    object: object,
                                    property: property,
                                    propertyIndex: propertyIndex,
                                    previousProperty: previousProperty,
                                    propertyState: propertyState
                                }, lastRead);
                            } else {
                                // need to assign the values *after* the completion of the sequence if it is a forward reference
                                pausedState.values = property.values instanceof Array ? property.values : undefined;
                            }
                        } /*else if (values) {
							
						}*/ 
                    }
                }
            }
            if (!property) {
                throw new Error('No property defined for slot' + (thisProperty.key ? ' in ' + thisProperty.key : ''));
            }
            if (propertyState < 2 && property && property.code === REFERENCING_TYPE /*REFERENCING_TYPE*/ ) {
                var values = property.values;
                if (typeof value === 'number') {
                    value = values[number];
                    if (value === undefined && !(number in values)) {
                        throw new Error('Referencing value that has not been read yet');
                    }
                } else if ((type === 2 || type === 7) && values) {
                    if (values.nextPosition > -1) {
                        // we use this path for fulfilling forward references
                        if (property.recordValueReference) {
                            property.recordValueReference(values);
                        }
                        values[values.nextPosition++] = value;
                    } else {
                        values.push(value);
                    }
                }
            }
            if (propertyState > 1) {
                // 0, 1: values are the value of the property
                if (propertyState === 2) {
                    property.key = value;
                } else if (propertyState === METADATA_TYPE) {
                    if (typeof value === 'string') {
                        var extendedType = classByName.get(value);
                        if (extendedType) {
                            if (extendedType.fromValue) {
                                property.fromValue = extendedType.fromValue;
                            } else {
                                property.constructs = extendedType;
                            }
                        } else if (options.errorOnUnknownClass) {
                            throw new Error('Attempt to deserialize to unknown class ' + parameter);
                        } else {
                        // if no warning, just parse as a plain value/object
                        }
                        property.extendedType = extendedType // if this gets used for serialization, this is needed
                        ;
                    } else {
                        // extended metadata assignment (used by shared structures to mark objects as unstructured)
                        property.metadata = value;
                        if (value === ERROR_METADATA) property.fromValue = onError;
                    }
                } else if (propertyState === REFERENCING_POSITION) {
                    var values = property.values || (property.values = []);
                    //values.splice(value, values.length)
                    values.nextPosition = value;
                } else if (propertyState === TYPE_DEFINITION) {
                // throw away this value and read next value as the real value
                } else {
                    throw new Error('Unknown property type ' + propertyState);
                }
                propertyState = 1 // property value after definition position
                ;
                continue; // read next value as the property value
            } else {
                propertyState = 0;
            }
            if (property.fromValue) {
                value = property.fromValue(value);
            }
            if (isArray && property.key === null) {
                object.push(value);
            } else if (value !== undefined) {
                object[property.key] = value;
            }
            i++;
            if (!isArray) propertyIndex++;
        }
        return object;
    }
    function unknownType(number) {
        throw new Error('Unknown type ' + number);
    }
    var nonParsingError;
    function onError(error) {
        var g = typeof global != 'undefined' ? global : window;
        if (error && error.name && g[error.name]) error = new g[error.name](error.message);
        else if (typeof error == 'string') error = new Error(error);
        if (options.onError) options.onError(error);
        else {
            nonParsingError = true;
            throw error;
        }
    }
    var disposedChars = 0;
    function read(property) {
        try {
            if (property && property.resume) {
                var previous = property.previous;
                value = readSequence(previous.length, previous);
                // once we get the value, we don't know which point in the stack could still be resolving
                value = property.object || value;
                property = property.property;
            } else {
                property = property || [
                    options && options.shared || {
                        key: null,
                        code: 6
                    }
                ];
                var value = readSequence(1, property)[property[0].key];
            }
            while(true){
                if (pausedState) {
                    return pause({
                        reader: read,
                        object: value,
                        property: property
                    });
                }
                if (!deferredReads) {
                    return value;
                }
                var index = deferredReads.index || 0;
                var deferredRead = deferredReads[index];
                deferredReads.index = index + 1;
                if (!deferredRead) {
                    deferredReads = deferredReads.parent;
                    continue;
                }
                var target = deferredRead.value;
                var parentDeferredReads = deferredReads;
                deferredReads = [];
                deferredReads.parent = parentDeferredReads;
                var targetProperty = deferredRead.property;
                var result = readSequence(1, property = [
                    {
                        resume: true,
                        key: null,
                        thisProperty: targetProperty,
                        object: target
                    }
                ]);
                result = result.null || result[targetProperty.key] // Blocks should use null as the root key, but could have the target property key as well
                ;
                if (result != target) {
                    // object was replaced with something else (an array, presumably)
                    Object.assign(target, result);
                    if (pausedState && pausedState.object === result) {
                        pausedState.object = target;
                    }
                    if (result && result.constructor === Array) {
                        target.length = result.length;
                        Object.setPrototypeOf(target, Object.getPrototypeOf(result)) // do our best to make it array like
                        ;
                    }
                }
            }
        } catch (error) {
            if (!nonParsingError) error.message = 'DPack parsing error: ' + error.message + ' at position: ' + (offset + disposedChars) + ' near: ' + source.slice(offset - 10, offset + 10);
            throw error;
        }
    }
    var parser = {
        setSource: function(string, startOffset, isPartialString) {
            source = string;
            offset = startOffset || 0;
            disposedChars = 0;
            isPartial = isPartialString;
            return this;
        },
        hasMoreData: function() {
            return source.length > offset;
        },
        isPaused: function() {
            return pausedState;
        },
        hasUnfulfilledReferences: function() {
            return deferredReads && deferredReads.length > deferredReads.index;
        },
        getOffset: function() {
            return offset + disposedChars;
        },
        read: read
    };
    return parser;
}
exports.parse = function(stringOrBuffer, options) {
    var source;
    if (typeof stringOrBuffer === 'string') {
        source = stringOrBuffer;
    } else if (stringOrBuffer && stringOrBuffer.toString) {
        source = stringOrBuffer.toString(options && options.encoding || 'utf8');
    } else {
        return stringOrBuffer;
    }
    var parser = createParser(options).setSource(source);
    if (options && options.shared) return parser.read([
        options.shared
    ]);
    return parser.read();
};
exports.createParser = createParser;
var readMap = {
    fromValue: function(entries) {
        var map = new Map();
        for(var i = 0, l = entries.length; i < l; i++){
            var entry = entries[i];
            map.set(entry.key, entry.value);
        }
        return map;
    }
};
var readSet = {
    fromValue: function(values) {
        var set = new Set(values);
        if (set.size === 0 && values.length > 0) {
            for(var i = 0, l = values.length; i < l; i++){
                set.add(values[i]);
            }
        }
        return set;
    }
};
var readDate = {
    fromValue: function(time) {
        return new Date(time);
    }
};
}}),
"[project]/node_modules/dpack/lib/parse-stream.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var Transform = __turbopack_context__.r("[externals]/stream [external] (stream, cjs)").Transform;
var createParser = __turbopack_context__.r("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)").createParser;
var DEFAULT_OPTIONS = {
    objectMode: true
};
class DPackParseStream extends Transform {
    constructor(options){
        if (options) {
            options.objectMode = true;
        } else {
            options = DEFAULT_OPTIONS;
        }
        super(options);
        this.parser = createParser(options);
        this.waitingValues = [];
    }
    _transform(chunk, encoding, callback) {
        var value;
        try {
            var sourceString = chunk.toString();
            var parser = this.parser;
            if (parser.onResume) {
                value = parser.onResume(sourceString, true);
                if (!parser.isPaused()) this.sendValue(value);
            } else {
                parser.setSource(sourceString, 0, true);
            }
            while(parser.hasMoreData()){
                value = parser.read();
                if (parser.isPaused()) break;
                else this.sendValue(value);
            }
        } catch (error) {
            console.error(error);
        }
        if (callback) callback();
    }
    sendValue(value) {
        if (this.parser.hasUnfulfilledReferences()) {
            if (value !== undefined) {
                this.waitingValues.push(value);
            }
        } else {
            while(this.waitingValues.length > 0){
                this.push(this.waitingValues.shift());
            }
            if (value !== undefined) {
                this.push(value);
            }
        }
    }
}
exports.createParseStream = ()=>new DPackParseStream();
}}),
"[project]/node_modules/dpack/lib/node-encoder.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var PREFERRED_MAX_BUFFER_SIZE = 0x8000;
var availableBuffers = [];
function nodeCharEncoder(options) {
    var offset = options.startOffset || 0;
    var bufferSize;
    var outlet = options.outlet;
    var buffer = availableBuffers.pop();
    if (buffer && buffer.length > offset + 0x80) {
        // reuse existing buffer if we can
        bufferSize = buffer.length;
    } else {
        bufferSize = (offset >> 12 << 12) + 0x2000;
        buffer = Buffer.allocUnsafeSlow(bufferSize);
    }
    var encoding = options.encoding;
    var sequences = [];
    function makeRoom(bytesNeeded) {
        if (outlet) {
            outlet.writeBytes(buffer.slice(0, offset));
            if (bufferSize < PREFERRED_MAX_BUFFER_SIZE || bytesNeeded > PREFERRED_MAX_BUFFER_SIZE) {
                bufferSize = Math.max(bufferSize * 4, bytesNeeded);
            }
            buffer = Buffer.allocUnsafeSlow(bufferSize);
            offset = 0;
            sequences = [] // clear insertion points
            ;
            encoder.hasWritten = true;
        } else {
            bufferSize = Math.max(bufferSize * 4, bufferSize + bytesNeeded, 0x2000);
            var oldBuffer = buffer;
            buffer = Buffer.allocUnsafeSlow(bufferSize);
            oldBuffer.copy(buffer, 0, 0, offset);
        }
    }
    function flush(specifiedOutlet) {
        (specifiedOutlet || outlet).writeBytes(buffer.slice(0, offset));
        if (offset + 0x80 > buffer.length) buffer = Buffer.allocUnsafeSlow(bufferSize = Math.min(Math.max((offset >> 10 << 10) + 0x2000, bufferSize), 0x8000)) // allocate a new buffer, don't want to overwrite the bytes in the old one while they are in use!
        ;
        else {
            buffer = buffer.slice(offset);
            bufferSize = buffer.length;
        }
        offset = 0;
        sequences = [] // clear insertion points
        ;
    }
    function writeToken(type, number) {
        if (number < 0x10) {
            buffer[offset++] = (type << 4) + number ^ 0x40;
        } else if (number < 0x400) {
            buffer[offset++] = (type << 4) + (number >>> 6);
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x10000) {
            buffer[offset++] = (type << 4) + (number >>> 12);
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x400000) {
            buffer[offset++] = (type << 4) + (number >>> 18);
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x10000000) {
            buffer[offset++] = (type << 4) + (number >>> 24);
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x100000000) {
            buffer[offset++] = (type << 4) + (number >>> 30);
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x400000000) {
            buffer[offset++] = (type << 4) + (number / 0x40000000 >>> 0);
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x10000000000) {
            buffer[offset++] = (type << 4) + (number / 0x1000000000 >>> 0);
            buffer[offset++] = number / 0x40000000 & 0x3f;
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else if (number < 0x400000000000) {
            buffer[offset++] = (type << 4) + (number / 0x40000000000 >>> 0);
            buffer[offset++] = number / 0x1000000000 & 0x3f;
            buffer[offset++] = number / 0x40000000 & 0x3f;
            buffer[offset++] = number >>> 24 & 0x3f;
            buffer[offset++] = number >>> 18 & 0x3f;
            buffer[offset++] = number >>> 12 & 0x3f;
            buffer[offset++] = number >>> 6 & 0x3f;
            buffer[offset++] = (number & 0x3f) + 0x40;
        } else {
            throw new Error('Invalid number ' + number);
        }
        if (offset > bufferSize - 10) {
            makeRoom(0);
        }
    }
    function writeBuffer(source) {
        var sourceLength = source.length;
        if (sourceLength + offset + 10 > bufferSize) {
            makeRoom(sourceLength + 10);
        }
        source.copy(buffer, offset);
        offset += sourceLength;
    }
    function writeString(string) {
        var length = string.length;
        var maxStringLength = length * 3 + 10;
        if (offset + maxStringLength > bufferSize) {
            makeRoom(maxStringLength + 10);
        }
        var bytesWritten = encoding ? buffer.write(string, offset, buffer.length, encoding) : buffer.utf8Write(string, offset, buffer.length);
        offset += bytesWritten;
    }
    function getSerialized() {
        return buffer.slice(0, offset);
    }
    function insertBuffer(headerBuffer, position) {
        var headerLength = headerBuffer.length;
        if (offset + headerLength + 10 > bufferSize) {
            makeRoom(headerLength + 10);
        }
        buffer.copy(buffer, headerLength + position, position, offset);
        headerBuffer.copy(buffer, position);
        offset += headerLength;
    }
    var encoder = {
        writeToken,
        writeString,
        writeBuffer,
        getSerialized,
        insertBuffer,
        flush,
        startSequence () {
            var currentOffset = offset;
            buffer[offset++] = 60;
            sequences.push(currentOffset);
            if (offset > bufferSize - 10) {
                makeRoom(0);
            }
        },
        endSequence (length) {
            var startOffset = sequences.pop();
            if (length < 12 && startOffset > -1) {
                buffer[startOffset] = 48 + length;
                return;
            }
            buffer[offset++] = 62 // else we need to put an end sequence token in
            ;
        },
        finish () {
            if (buffer.length - offset > 0x90) availableBuffers.push(buffer.slice(offset));
        },
        getOffset () {
            return offset;
        },
        setOffset (newOffset) {
            offset = newOffset;
        }
    };
    if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    return encoder;
}
exports.nodeCharEncoder = nodeCharEncoder;
}}),
"[project]/node_modules/dpack/lib/Options.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
function Options() {
    var classByName = this.classByName = new Map();
    this.converterByConstructor = new Map();
//writerByConstructor.set(Map, writeMap)
//writerByConstructor.set(Set, writeSet)
}
Options.prototype.addExtension = function(Class, name, options) {
    if (name && Class.name !== name) {
        Class.name = name;
    }
    this.classByName.set(Class.name, options && options.fromArray ? options : Class);
    this.converterByConstructor.set(Class, options && options.toArray ? options : Class);
};
exports.Options = Options;
}}),
"[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
const createSerializer = __turbopack_context__.r("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)").createSerializer;
const serialize = __turbopack_context__.r("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)").serialize;
const createParser = __turbopack_context__.r("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)").createParser;
const Options = __turbopack_context__.r("[project]/node_modules/dpack/lib/Options.js [app-route] (ecmascript)").Options;
const STRING_CODE = 2;
var PROPERTY_CODE = 0;
var NUMBER_CODE = 1;
var TYPE_CODE = 3;
var SEQUENCE_CODE = 7;
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
var REFERENCING_TYPE = 8;
var NUMBER_TYPE = 9;
var NULL = 0 // p
;
var METADATA_TYPE = 11;
var REFERENCING_POSITION = 13;
var TYPE_DEFINITION = 14 // ~  // for defining a typed object without returning the value
;
var UNSTRUCTURED_MARKER = 11;
var OPEN_SEQUENCE = 12 // <
;
var END_SEQUENCE = 14 // >
;
var COUNT_THRESHOLD = 2;
exports.createSharedStructure = createSharedStructure;
exports.readSharedStructure = readSharedStructure;
function readSharedStructure(from) {
    var parser = createParser();
    var sharedProperty = [];
    sharedProperty.code = 6;
    sharedProperty.key = null;
    // end with with NULL (p) value to return something from type definition
    parser.setSource(from + 'p').read([
        sharedProperty
    ]);
    setupShared(sharedProperty);
    sharedProperty.serialized = from;
    return sharedProperty;
}
function setupShared(property) {
    property.resetTo = property.length;
    property.upgrade = upgrade;
    property.type = types[property.code];
    property.isFrozen = true;
    Object.defineProperty(property, 'serialized', {
        get () {
            return this._serialized || (this._serialized = serializeSharedStructure(this));
        }
    });
    if (typeof property.values === 'object' && property.values) {
        property.values.resetTo = property.values.length;
        property.lastIndex = property.values.length;
    }
    for(var i = 0, l = property.length; i < l; i++){
        property[i].index = i;
        property[i].resumeIndex = i;
        setupShared(property[i]);
    }
}
function startWrite() {
    for(var i = 0, l = this.length; i < l; i++){
        startWrite.call(this[i]);
    }
    this.length = this.resetTo || 0;
    if (typeof this.values === 'object' && this.values) {
        this.values.length = this.values.resetTo || 0;
    }
}
// upgrades the property to output this block
// return 0 if the property was upgraded, or is compatible,
// 1 if the shared information needs to be written out, but the property was upgraded
// 2 if the shared information needs to be reserialized
function upgrade(property) {
    if (!property) {
        return 1;
    }
    var compatibility;
    if (property) {
        // same block was serialized last time, fast path to compatility
        if (property.insertedFrom === this && property.insertedVersion === this.version && (property.recordUpdate || property.isFrozen || property.length == 0 && property.code == this.code && property.values == null)) {
            // but if the version incremented, we need to update
            return 0;
        }
        var changedCode;
        if (this.code !== property.code) changedCode = true;
        if (property.upgrade) {
            var compatibility = copyProperty(this, property);
            if (changedCode) compatibility = 2;
            if (property.isFrozen && compatibility > 0) {
                return 2;
            }
            property.insertedFrom = this;
            property.insertedVersion = this.version;
            if (compatibility === 2) {
                debugger;
                console.error('Inserting incompatible block into property');
                return 2;
            } else return 0;
        } else {
            property.insertedFrom = this;
            property.insertedVersion = this.version;
            // if this is not a shared property that tracks changes, we have reset and ensure that it doesn't change when we reuse it
            property.length = 0;
            property.values = null;
            if (property.fromValue) property.fromValue = null;
            return 1;
        }
    } else {
        if (this.length > 0) {
            // no property, (but block is shared) so just write the buffer with its shared part (if there is one)
            blockBuffer = Buffer.concat([
                this.serialized,
                blockBuffer
            ]);
        }
    }
    return 1;
}
var typeToCode = {
    string: REFERENCING_TYPE,
    number: NUMBER_TYPE,
    object: DEFAULT_TYPE,
    boolean: DEFAULT_TYPE,
    undefined: DEFAULT_TYPE,
    array: ARRAY_TYPE
};
var lastPropertyOnObject = new WeakMap();
function createSharedStructure(from, options) {
    var instanceProperty = [];
    instanceProperty.key = null;
    instanceProperty.code = 6;
    instanceProperty.type = 'object';
    let activeList = [];
    let needsCleanup = [];
    activeList.iteration = 0;
    var previousAvoidShareUpdate;
    // property id ranges:
    // shared: 0 - 511
    // instance: 512+
    // shared: 
    class Shared extends Array {
        constructor(instanceProperty){
            super();
            let hasUpdates;
            this.key = typeof instanceProperty.key == 'string' ? isolateString(instanceProperty.key) : instanceProperty.key;
            this.type = instanceProperty.type;
            this.code = instanceProperty.code;
            this.count = 0;
            this.comesAfter = [];
            if (this.code == REFERENCING_TYPE) {
                this.values = [];
                this.values.resetTo = 512;
                this.values.nextPosition = 512;
                this.previousValues = new Map();
                this.lastIndex = 0;
                this.repetitions = 0;
            }
        }
        newProperty(instance) {
            return new Shared(instance);
        }
        getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex) {
            let property;
            if (this.insertedFrom) {
                propertySearch(this.insertedFrom);
                if (property) {
                    if (lastPropertyIndex !== property.index) {
                        writeToken(PROPERTY_CODE, propertyIndex);
                    }
                    return property;
                }
                if (this.insertedFrom.getProperty) {
                    //this.recordUpdate()
                    return this.insertedFrom.getProperty(value, key, type, extendedType, writeProperty, writeToken, lastPropertyIndex);
                } else {
                    debugger;
                }
            }
            this.recordUpdate();
            let propertyIndex = this.length;
            if (lastPropertyIndex !== propertyIndex) {
                writeToken(PROPERTY_CODE, propertyIndex);
            }
            if (type === 'boolean' || type === 'undefined') {
                type = 'object';
            }
            property = this[propertyIndex] = new Shared({
                key,
                type,
                code: typeToCode[type]
            });
            property.parent = this;
            property.index = propertyIndex;
            return property;
            "TURBOPACK unreachable";
            function propertySearch(parentProperty) {
                let propertyIndex = -1;
                do {
                    property = parentProperty[++propertyIndex];
                }while (property && (property.key !== key || property.type !== type && type !== 'boolean' && type !== 'undefined' || extendedType && property.extendedType !== constructor))
            }
        }
        writeSharedValue(value, writeToken, serializerId) {
            // there are several possible states of a property:
            // 1) Non-referencing state (initial state) - We don't reset position indices, and we never reference previous values
            // 2) Shared/repetitive state - We can have shared values (<12 position) and we can reference properties in an instance (>=12 position)
            // 3) Non-repetitive - If repetition is rare, goes to default type
            let valueEntry = this.previousValues.get(value);
            if (valueEntry) {
                if (valueEntry.serializer == serializerId) {
                    this.repetitions++;
                } else {
                    valueEntry.serializations++;
                    valueEntry.serializer = serializerId;
                }
            } else {
                this.previousValues.set(value, valueEntry = {
                    serializations: 1,
                    serializer: serializerId
                });
            }
            if (!this.active) {
                this.active = 2;
                activeList.push(this);
            }
            return false;
        /*var index = this.values.length
			if (index < 12)
				this.values[index] = value*/ }
        propertyUsed(property, object, serializerId, i) {
            if (property.lastSerializer !== serializerId) {
                property.lastSerializer = serializerId;
                property.count++;
            }
            if (i !== 0) {
                let lastProperty = lastPropertyOnObject.get(object);
                // record what has come before so we can order them when creating a common structure
                if (lastProperty && property.comesAfter.indexOf(lastProperty) === -1) property.comesAfter.push(lastProperty);
            }
            lastPropertyOnObject.set(object, property);
        }
        recordUpdate() {
            var property = this;
            do {
                property.version = (property.version || 0) + 1;
                if (property.insertedFrom) {
                    // or we could try to upgrade the latest inserted property?
                    property.insertedFrom = null;
                }
                if (property._serialized) property._serialized = null;
            }while (property = property.parent)
        }
        readingBlock(parse) {
            //var blockStructure = this.asBlockStructure()
            try {
                return parse();
            } finally{
                this.readReset();
                if (this.length > 500) {
                    debugger;
                }
            }
        }
        //active:
        // 0 - not-actively being monitored
        // 1 - being monitored, but an iteration hasn't started for this
        // 2 - being monitored, and an iteration has started
        startWrite(avoidShareUpdate, value) {
            activeList.iteration++;
            if (value && value.constructor === Array) {
                if (this.code !== ARRAY_TYPE && this.version > 0) {
                    throw new Error('Can not change the root type of a shared object to an array');
                }
                if (this.code != ARRAY_TYPE) this.recordUpdate();
                this.code = ARRAY_TYPE;
                this.type = 'array';
            }
            if (this.writing) return;
            else this.writing = true;
            return;
            "TURBOPACK unreachable";
        }
        endWrite() {
            if (this.writing) this.writing = false;
            else return;
            let iterations = this.iterations = (this.iterations || 0) + 1;
            for(let i = 0; i < activeList.length; i++){
                let activeSharedProperty = activeList[i];
                let previousValues = activeSharedProperty.previousValues;
                if (previousValues && previousValues.size && !activeSharedProperty.isFrozen) {
                    if (!currentAvoidShareUpdate) {
                        if (activeSharedProperty.values.length == 0 && iterations > ((activeSharedProperty.repetitions || 0) + 10) * 5) {
                            // move to permanently non-repetitive
                            console.log('changing referenceable to default', activeSharedProperty.key);
                            activeSharedProperty.previousValues = null;
                            activeSharedProperty.code = DEFAULT_TYPE;
                            activeSharedProperty.type = 'object';
                            activeSharedProperty.recordUpdate();
                            activeList.splice(i--, 1);
                            previousValues = [];
                        }
                        for (let [value, entry] of previousValues){
                            let values = activeSharedProperty.values;
                            if ((entry.serializations + 3) * 8 < iterations - (entry.startingIteration || (entry.startingIteration = iterations)) || values.length > 500) {
                                previousValues.delete(value);
                            }
                            if (entry.serializations > 50 && entry.serializations * 3 > iterations) {
                                values[activeSharedProperty.lastIndex++] = value;
                                activeSharedProperty.recordUpdate();
                                console.log('adding value', value, 'to', activeSharedProperty.key);
                                previousValues.delete(value) // done with tracking, it has been accepted as a common value
                                ;
                            }
                        }
                    }
                } else {
                    activeSharedProperty.active = 0;
                    activeList.splice(i--, 1);
                }
            }
            if (activeList.hasUpdates) {
                activeList.hasUpdates = false;
                this.version++;
                if (!this._serialized) this._serialized = null;
                if (options && options.onUpdate) options.onUpdate();
            }
            currentAvoidShareUpdate = previousAvoidShareUpdate;
        }
        upgrade(property) {
            return upgrade.call(this, property);
        }
        get serialized() {
            return this._serialized || (this._serialized = serializeSharedStructure(this));
        }
        serializeCommonStructure(embedded) {
            var usageThreshold = Math.sqrt(activeList.iteration);
            return serializeSharedStructure(this, (childProperty)=>childProperty.count >= usageThreshold, embedded);
        }
    }
    var sharedStructure = new Shared(instanceProperty);
    sharedStructure.version = 0;
    sharedStructure.freeze = function() {
        this.isFrozen = true;
        this.reset();
    };
    if (from) {
        var parser = createParser({
            forDeferred (block, property) {
                property.isBlock = true;
                return block;
            },
            parseDeferreds: true
        });
        // concatenate shared structure with null so there is a value to parse
        var readProperty = [];
        readProperty.code = 6;
        readProperty.key = null;
        // end with with NULL (p) value to return something from type definition
        parser.setSource(from + 'p').read([
            readProperty
        ]);
        copyProperty(readProperty, sharedStructure);
        activeList.hasUpdates = false;
        sharedStructure.version = 1;
    }
    sharedStructure.key = null // root must be null (for the parser to work properly)
    ;
    return sharedStructure;
}
function isDescendant(property, possibleParent) {
    do {
        if (property === possibleParent) return true;
    }while (property = property.parent)
}
// default type for each code
var types = {
    6: 'object',
    7: 'array',
    8: 'string',
    9: 'number'
};
var currentAvoidShareUpdate;
function serializeSharedStructure(property, condition, embedded) {
    var serializer = createSerializer();
    var writers = serializer.getWriters();
    serializeSharedProperty(property, !embedded, !embedded);
    function serializeSharedProperty(property, expectsObjectWithNullKey, isRoot) {
        if (property.insertedFrom && property.insertedFrom.serializeCommonStructure) {
            property = property.insertedFrom;
            return writers.writeBuffer(property.serializeCommonStructure(!isRoot));
        }
        var isArray = property.code === ARRAY_TYPE;
        var commonProperties = condition ? orderProperties(property.filter(condition)) : property;
        var length = commonProperties.length;
        if (!(expectsObjectWithNullKey && property.code === DEFAULT_TYPE)) {
            let key = isRoot ? null : property.key;
            writers.writeProperty(key, types[property.code]);
            if (length === 0 && key === null && (property.code === DEFAULT_TYPE || property.code === ARRAY_TYPE)) {
                // the key was elided, but won't be followed by sequence, so write one now
                writers.writeToken(SEQUENCE_CODE, 0);
            }
        }
        if (isRoot && length > 0) {
            writers.writeToken(TYPE_CODE, TYPE_DEFINITION);
        }
        if (length > 0) {
            // we always use open sequence, because writing multiple values of a property use extra property counts,
            // plus it is easier to deal with properties without values
            writers.writeToken(SEQUENCE_CODE, OPEN_SEQUENCE);
            for(var i = 0; i < length; i++){
                var childProperty = commonProperties[i];
                childProperty.index = i;
                if (isArray && i > 0) {
                    writers.writeToken(PROPERTY_CODE, i);
                }
                serializeSharedProperty(childProperty, commonProperties.code === ARRAY_TYPE && i === 0, false, condition);
            }
            writers.writeToken(SEQUENCE_CODE, END_SEQUENCE);
        }
        var first = true;
        /*		if (property.previousValues) {
			for (let [value, count] of property.previousValues) {
				if (count >= usageThreshold * 2) {
					if (first)
						first = false
					else // reset property code for each subsequent value so we don't move on to the next property in parsing
						writers.writeToken(PROPERTY_CODE, property.index)
					writers.writeAsDefault(value)
				}
			}
		} else */ if (property.lastIndex > 0) {
            for(var i = 0, l = property.lastIndex; i < l; i++){
                var value = property.values[i];
                if (first) first = false;
                else writers.writeToken(PROPERTY_CODE, property.index);
                writers.writeAsDefault(value);
            }
        }
    }
    let serialized = serializer.getSerialized();
    return serialized;
}
function copyProperty(source, target, freezeTarget, startingIndex) {
    var compatibility = 0;
    target.code = source.code;
    target.type = source.type || types[source.code];
    if (freezeTarget) {
        target.isFrozen = true;
        if (target.previousValues) target.previousValues = null;
    }
    let sourceLength = source.resetTo > -1 ? source.resetTo : source.length;
    if (target.resetTo > -1 && target.resetTo < target.length) target.length = target.resetTo;
    for(var i = startingIndex || 0; i < sourceLength; i++){
        var targetChild = target[i];
        var childProperty = source[i];
        if (targetChild && (targetChild.key != childProperty.key || targetChild.extendedType != childProperty.extendedType || targetChild.code != childProperty.code && !(targetChild.code == 8 && childProperty.code === 6 && (!targetChild.values || !targetChild.values.length)))) {
            if (target.isFrozen) return 2;
            compatibility = 2;
        }
        if (!targetChild) {
            if (target.isFrozen) return 2;
            var targetChild = [];
            targetChild.code = childProperty.code;
            if (target.newProperty) {
                targetChild = target.newProperty(targetChild);
            }
            target[i] = targetChild;
            if (childProperty.metadata) targetChild.metadata = childProperty.metadata;
            if (childProperty.insertedFrom) {
                targetChild.insertedFrom = childProperty.insertedFrom;
                targetChild.insertedVersion = childProperty.insertedVersion;
            }
            targetChild.parent = target;
        }
        targetChild.key = childProperty.key;
        // TODO: Check to make sure the values are compatible
        if (childProperty.values && childProperty.values.length > 0) {
            if (childProperty.values.resetTo > -1) {
                childProperty.values.length = childProperty.values.resetTo;
            }
            if (!targetChild.values || childProperty.values.length > (targetChild.values.resetTo > -1 ? targetChild.values.resetTo : targetChild.values.length)) {
                targetChild.values = childProperty.values.slice(0);
                targetChild.values.nextPosition = childProperty.values.length;
                if (targetChild.values.length >= 12) {
                    targetChild.previousValues = null;
                }
                if (compatibility == 0) {
                    compatibility = 1;
                }
            }
        }
        var childCompatibility = copyProperty(childProperty, targetChild, freezeTarget);
        if (childCompatibility > compatibility) compatibility = childCompatibility;
    }
    let targetLength = target.resetTo > -1 ? target.resetTo : target.length;
    if (targetLength > sourceLength) {
        if (target.recordUpdate) {
            // reverse freeze if the target has more values, we don't want the source becoming incompatible
            source.metadata = UNSTRUCTURED_MARKER;
            source.recordUpdate();
        } else if (target.isFrozen) {
            return 2;
        }
    // merge back to the source if there are extra properties on the target
    //copyProperty(target, source, i)
    //source.recordUpdate()
    }
    /*if (target.previousValues) {
		target.values = target.previousValues
		target.previousValues = []
	}*/ //target.length = source.length
    return compatibility;
}
// return values:
// 0: identical property structures
// -1: a has less properties, but can be safely upgraded to b and still be compatible with a
// 1: a has more properties, but is compatible and can be used to decode b
// -2: incompatible property structures, can not be used
function isCompatibleProperty(a, b) {
    if (a.blockStructure === b) {
        return a.version > b.version ? 1 : 0;
    }
    if (a.code === b.code && a.extendedType === b.extendedType) {
        var sharedLength = Math.min(a.length, b.length);
        var compatibility = 0;
        for(var i = 0; i < sharedLength; i++){
            if (a[i].key !== b[i].key) return -2;
            var childCompatibility = isCompatibleProperty(a[i], b[i]);
            if (childCompatibility === -2) return -2;
            if (childCompatibility === -1) {
                if (compatibility === 1) return -2;
                compatibility = -1;
            }
            if (childCompatibility === 1) {
                if (compatibility === -1) return -2;
                compatibility = 1;
            }
        }
        var sharedValuesLength = Math.min(a.values ? a.values.length : 0, b.values ? b.values.length : 0);
        for(var i = 0; i < sharedValuesLength; i++){
            if (a.values[i] !== b.values[i]) {
                return -2;
            }
        }
        if (a.length < b.length) {
            if (compatibility === 1) {
                return -2;
            }
            compatibility = -1;
        } else if (a.length < b.length) {
            if (compatibility === -1) {
                return -2;
            }
            compatibility = 1;
        }
        /*if (a.values.length < b.values.length) {
			if (compatibility === 1) {
				return -2
			}
			compatibility = -1
		} else if (a.values.length < b.values.length) {
			if (compatibility === -1) {
				return -2
			}
			compatibility = 1
		}*/ return compatibility;
    } else {
        return -2;
    }
}
function isolateString(string) {
    // this is a technique to forcefully recreate a string so it isn't a slice of a larger string. Because shared
    // structures are long-lived and created from instance structures that are short-lived, the long-lived small
    // sliced strings can end up pinning (otherwise short-lived) large strings in memory.
    return string.slice(0, 1) + string.slice(1);
}
// order properties by their comesAfter list, to ensure each properties comes after everything in their comesAfter list
function orderProperties(properties) {
    var ordered = [];
    var traversed = new Set();
    function addProperty(property) {
        if (traversed.has(property)) return;
        traversed.add(property);
        for (var propertyBefore of property.comesAfter){
            addProperty(propertyBefore);
        }
        ordered.push(property);
    }
    for (let property of properties){
        addProperty(property);
    }
    return ordered;
}
}}),
"[project]/node_modules/dpack/lib/Block.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
const BLOCK_TYPE = 5;
var makeSymbol = typeof Symbol !== 'undefined' ? Symbol : function(name) {
    return 'symbol-' + name;
};
/*
Two types of blocks, frozen and copy-on-write
Frozen - originating from JS objects
	Object.freeze() js objects and use symbol for serialized representation
Frozen - originating from dpack, lazy evaluation
	Proxy - get,has,etc. triggers parse, set throws
Copy-on-write from JS objects
	Proxy - get,has,etc. retrieves from source JS object, set copies
Copy-on-write originating from dpack
	Same
*/ var nextVersion = 1;
var bufferSymbol = makeSymbol('buffer');
var sizeTableSymbol = makeSymbol('sizeTable');
var headerSymbol = makeSymbol('header');
var parsedSymbol = makeSymbol('parsed');
var sharedSymbol = makeSymbol('shared');
var targetSymbol = makeSymbol('target');
const freezeObjects = ("TURBOPACK compile-time value", "development") != 'production';
var DEFAULT_TYPE = 6;
var ARRAY_TYPE = 7;
/*
size table size types in first 2 bits:

first byte
0 - leaf mode, 6 bit length
1 - leaf mode, 14 bit length
2 - branch/leaf mode, 14, 16, 16 bit our-size length
3 - branch/leaf mode, 30, 48, 48 bit our-size length
*/ function Block() {}
var serializeModule = __turbopack_context__.r("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)");
exports.Block = Block;
exports.bufferSymbol = serializeModule.bufferSymbol = bufferSymbol;
exports.parsedSymbol = parsedSymbol;
exports.sharedSymbol = sharedSymbol;
exports.targetSymbol = serializeModule.targetSymbol = targetSymbol;
exports.sizeTableSymbol = serializeModule.sizeTableSymbol = sizeTableSymbol;
var serialize = serializeModule.serialize;
var createSerializer = serializeModule.createSerializer;
exports.asBlock = asBlock;
function asBlock(object, shared) {
    if (object && object[targetSymbol]) {
        return object // already a block
        ;
    }
    if (Array.isArray(object)) {
        // if the object is an array, make the taget an array so it passes Array.isArray checks
        let target = [];
        target.parsed = object;
        target.shared = shared;
        return new Proxy(target, onDemandHandler);
    }
    return new Proxy({
        parsed: object,
        shared: shared
    }, onDemandHandler);
}
exports.isBlock = isBlock;
function isBlock(object) {
    return object && object[targetSymbol];
}
exports.makeBlockFromBuffer = makeBlockFromBuffer;
function makeBlockFromBuffer(buffer, shared) {
    var dpackBuffer, sizeTableBuffer;
    if (buffer[0] < 0x80) {
        dpackBuffer = buffer;
    } else {
        var type = buffer[0] >> 6;
        var dpackOffset;
        if (type === 2) {
            dpackOffset = buffer.readUInt16BE(0) & 0x3fff;
        } else {
            dpackOffset = buffer.readUInt32BE(0) & 0x3fffffff;
        }
        dpackBuffer = buffer.slice(dpackOffset);
        sizeTableBuffer = buffer.slice(0, dpackOffset);
    }
    var target = {
        dpackBuffer: dpackBuffer,
        sizeTableBuffer: sizeTableBuffer,
        shared: shared,
        reassign: function(buffer) {
            this.buffer = buffer;
        }
    };
    buffer.owner = target;
    return new Proxy(target, onDemandHandler);
}
exports.getLazyHeader = function(block) {
    return block[sizeTableSymbol];
};
var onDemandHandler = {
    get: function(target, key) {
        if (specialGetters.hasOwnProperty(key)) {
            return specialGetters[key].call(target);
        }
        var parsed = target.parsed;
        if (!parsed) {
            parsed = getParsed(target);
        }
        return parsed[key];
    },
    set: function(target, key, value) {
        // we allow symbols to set as a form of metadata objects even though the main string keyed properties are frozen
        if (typeof key === 'symbol') {
            target[key] = value;
            makeSymbolGetter(key);
            return true;
        }
        throw new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify');
    },
    deleteProperty: function() {
        throw new Error('No changes are allowed on frozen parsed object, Use dpack copy() function to modify');
    },
    getOwnPropertyDescriptor: function(target, key) {
        var parsed = getParsed(target);
        return Object.getOwnPropertyDescriptor(parsed, key);
    },
    has: function(target, key) {
        var parsed = getParsed(target);
        return key in parsed;
    },
    ownKeys: function(target) {
        var parsed = getParsed(target);
        var keys = Object.keys(parsed);
        if (Array.isArray(parsed)) {
            keys.push('length');
        }
        return keys;
    },
    getPrototypeOf: function(target) {
        var parsed = getParsed(target);
        return Object.getPrototypeOf(parsed);
    }
};
exports.reassignBuffers = reassignBuffers;
function reassignBuffers(block, newParentNodeBuffer, parentArrayBuffer) {
    // if a buffer needs to be moved to a new buffer due to it soon being no longer referenceable, we can reference the new copy
    var target = block[targetSymbol];
    var buffer = target.dpackBuffer;
    if (!parentArrayBuffer) parentArrayBuffer = buffer.buffer;
    if (buffer && buffer.buffer === parentArrayBuffer) {
        var byteOffset = buffer.byteOffset;
        target.dpackBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length);
    }
    var buffer = target.sizeTableBuffer;
    if (buffer && buffer.buffer === parentArrayBuffer) {
        var byteOffset = buffer.byteOffset;
        target.sizeTableBuffer = newParentNodeBuffer.slice(byteOffset, byteOffset + buffer.length);
    }
    if (target.parsed) {
        var parsed = target.parsed;
        for(var key in parsed){
            var value = parsed[key];
            if (isBlock(value)) {
                reassignBuffers(value, newParentNodeBuffer, parentArrayBuffer);
            }
        }
    }
}
var copyOnWriteHandler = {
    get: function(target, key) {
        if (specialGetters.hasOwnProperty(key)) {
            return specialGetters[key].call(target);
        }
        var cachedParsed = target.cachedParsed;
        if (cachedParsed && cachedParsed.hasOwnProperty(key) && !(key == 'length' && Array.isArray(cachedParsed))) {
            return cachedParsed[key];
        }
        var parsed = target.parsed;
        if (!parsed) {
            parsed = getParsed(target);
        }
        var value = parsed[key];
        /*if (value && typeof value == 'object') {
			if (!cachedParsed) {
				target.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {}
			}
			if (value instanceof Map)
				cachedParsed[key] = value
			else
				cachedParsed[key] = value = copyWithParent(value, target)
		}*/ if (value && value[targetSymbol]) {
            if (!cachedParsed) {
                target.cachedParsed = cachedParsed = parsed instanceof Array ? [] : {};
            }
            cachedParsed[key] = value = copyWithParent(value, target);
        }
        return value;
    },
    changed: function(target) {
        target.dpackBuffer = null;
        target.sizeTableBuffer = null;
        target.shared = null;
        var parsed = target.parsed;
        if (!parsed) {
            parsed = getParsed(target);
        }
        if (!target.copied) {
            var cachedParsed = target.cachedParsed;
            var copied = target.parsed = target.cachedParsed = parsed instanceof Array ? [] : {};
            for(var key in parsed){
                var value = cachedParsed && cachedParsed[key];
                if (!value) {
                    value = parsed[key];
                    if (value && value[targetSymbol]) {
                        value = copyWithParent(value, target);
                    }
                }
                copied[key] = value;
            }
            parsed = copied;
            target.copied = true;
        }
        target.version = nextVersion++;
        return parsed;
    },
    checkVersion: function(target) {
        var cachedParsed = target.cachedParsed;
        let version = target.version || 0;
        if (cachedParsed) {
            for(let key in cachedParsed){
                var value = cachedParsed[key];
                if (value && value[targetSymbol]) {
                    version = Math.max(version, this.checkVersion(value[targetSymbol]));
                }
            }
        }
        if (version != (target.version || 0)) {
            this.changed(target);
            target.version = version;
        }
        return version;
    },
    set: function(target, key, value, proxy) {
        if (specialSetters.hasOwnProperty(key)) {
            specialSetters[key].call(target, value);
            return true;
        }
        var parsed = copyOnWriteHandler.changed(target);
        parsed[key] = value;
        return true;
    },
    deleteProperty: function(target, key) {
        var parsed = copyOnWriteHandler.changed(target);
        return delete parsed[key];
    },
    getOwnPropertyDescriptor: function(target, key) {
        var parsed = getParsed(target);
        return Object.getOwnPropertyDescriptor(parsed, key);
    },
    has: function(target, key) {
        var parsed = getParsed(target);
        return key in parsed;
    },
    ownKeys: function(target) {
        var parsed = getParsed(target);
        var keys = Object.keys(parsed);
        if (Array.isArray(parsed)) {
            keys.push('length');
        }
        if (target.copied) {
            for(var key in target.copied){
                if (keys.indexOf(key) === -1) {
                    keys.push(key);
                }
            }
        }
        return keys;
    },
    getPrototypeOf: function(target) {
        var parsed = getParsed(target);
        return Object.getPrototypeOf(parsed);
    }
};
var specialGetters = {};
specialGetters[bufferSymbol] = function() {
    return (function(property, randomAccess) {
        var propertyIsShared = property && property.upgrade;
        var buffer;
        if (this.cachedParsed && this.dpackBuffer) {
            copyOnWriteHandler.checkVersion(this);
        }
        if (!(this.shared && this.shared.upgrade) && propertyIsShared) {
            if (this.dpackBuffer) {
                // if the block has been serialized without a shared structure, and it will be used in a shared structure,
                // we put it in a separate property
                this.sizeTableBuffer = null;
                return inSeparateProperty(this.dpackBuffer, true);
            } else {
                return getSerialized(this, this.shared = property);
            }
        }
        if (!this.dpackBuffer) {
            getSerialized(this, this.shared);
        }
        if (this.shared && this.shared.upgrade && this.shared !== property) {
            var compatibility = this.shared.upgrade(property, randomAccess);
            if (compatibility > 0) {
                // if the property upgrade was incompatible, we have to included the shared structure, and force sequential reading
                this.sizeTableBuffer = null;
                var sharedBuffer = this.shared.serialized;
                if (sharedBuffer.length > 0) {
                    if (compatibility == 2 && !(property.isFrozen && property.resetTo === 0)) sharedBuffer = inSeparateProperty(sharedBuffer);
                    buffer = Buffer.concat([
                        sharedBuffer,
                        this.dpackBuffer
                    ]);
                    buffer.mustSequence = true;
                    return buffer;
                }
            }
        } else if (property) {
            if (!propertyIsShared) {
                // need to reset this property, if it is a plain sequential property
                property.length = 0;
            }
            if (property.insertedFrom) property.insertedFrom = null;
        }
        return this.dpackBuffer;
        "TURBOPACK unreachable";
        function inSeparateProperty(dpackBuffer) {
            var serializer = createSerializer();
            var isArray = dpackBuffer[0] === 119;
            var writeToken = serializer.getWriters().writeToken;
            if (isArray) {
                dpackBuffer = dpackBuffer.slice(1) // replacing the property declaration
                ;
            }
            writeToken(0, 1000) // use a hopefully unused slot (should be unused, block always has a single initial starting slot)
            ;
            writeToken(3, isArray ? ARRAY_TYPE : DEFAULT_TYPE) // property type
            ;
            if (property && property.key !== null) serializer.serialize(property.key);
            dpackBuffer = Buffer.concat([
                serializer.getSerialized(),
                dpackBuffer
            ]);
            dpackBuffer.mustSequence = true;
            return dpackBuffer;
        }
    }).bind(this);
};
specialGetters[targetSymbol] = function() {
    return this;
};
specialGetters[sharedSymbol] = function() {
    return this.shared;
};
specialGetters[parsedSymbol] = function() {
    return this.parsed || getParsed(this);
};
specialGetters[sizeTableSymbol] = function() {
    if (!this.dpackBuffer) {
        getSerialized(this);
    }
    return this.sizeTableBuffer;
};
specialGetters.then = function() {
// return undefined, this is not a promise
};
specialGetters.toJSON = function() {
    return valueOf;
};
specialGetters.valueOf = function() {
    return valueOf;
};
specialGetters.entries = function() {
    return entries;
};
function entries() {
    return this[parsedSymbol].entries();
}
specialGetters[Symbol.iterator] = function() {
    var parsed = this.parsed || getParsed(this);
    return parsed && parsed[Symbol.iterator] && iterator;
};
function iterator() {
    var parsed = this[parsedSymbol];
    return parsed && parsed[Symbol.iterator] ? parsed[Symbol.iterator]() : [][Symbol.iterator]();
}
specialGetters.constructor = function() {
    if (this.parsed) {
        return this.parsed.constructor;
    }
    // this is a fast path for getting the constructor without having to parse. this is important
    // as it enables blocks to be go through the serializer, have it check the constructor, without
    // requiring parsing, and then they can be directly written from their binary buffer
    if (this.dpackBuffer) {
        let firstByte = this.dpackBuffer[0];
        if (firstByte >= 48 && firstByte <= 60) {
            // sequence
            if (this.shared) {
                if (this.shared.code == DEFAULT_TYPE) {
                    return Object;
                } else if (this.shared.code == ARRAY_TYPE) {
                    return Array;
                }
            } else {
                return Object;
            }
        } else if (firstByte === 119) {
            return Array;
        }
    }
    return getParsed(this).constructor;
};
function makeSymbolGetter(symbol) {
    if (!specialGetters[symbol]) specialGetters[symbol] = function() {
        return this[symbol];
    };
}
function valueOf() {
    return this[parsedSymbol];
}
function copy(source) {
    return copyWithParent(source);
}
function copyWithParent(source, parent) {
    if (!isBlock(source)) {
        /*if (source && typeof source == 'object')
			source = asBlock(source)
		else*/ return source;
    }
    let isArray = Array.isArray(source);
    let target = isArray ? [] : {};
    Object.defineProperties(target, {
        parsed: {
            get () {
                return source[parsedSymbol];
            },
            set (value) {
                Object.defineProperty(this, 'parsed', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
            },
            configurable: true
        },
        shared: {
            get () {
                return source[sharedSymbol];
            },
            set (value) {
                Object.defineProperty(this, 'shared', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
                this.dpackBuffer = null;
                this.sizeTableBuffer = null;
            },
            configurable: true
        },
        dpackBuffer: {
            get () {
                return source[targetSymbol].dpackBuffer;
            },
            set (value) {
                Object.defineProperty(this, 'dpackBuffer', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
            },
            configurable: true
        },
        sizeTableBuffer: {
            get () {
                return source[sizeTableSymbol];
            },
            set (value) {
                Object.defineProperty(this, 'sizeTableBuffer', {
                    value: value,
                    writable: true,
                    enumerable: true
                });
            },
            configurable: true
        }
    });
    if (isArray) {
        Object.define;
    }
    return new Proxy(target, copyOnWriteHandler);
}
exports.copy = copy;
var specialSetters = {};
/*specialSetters[sharedSymbol] = function(shared) {
	return this.shared = shared
}*/ function getParsed(target) {
    var parsed = target.parsed;
    if (parsed) return parsed;
    // we check to see if there are multiple blocks that should be deferred into separate blocks
    var sizeTableBuffer = target.sizeTableBuffer;
    var dpackBuffer = target.dpackBuffer;
    if (!sizeTableBuffer) {
        // no child blocks, just dpack, so directly parse
        return target.parsed = parse(dpackBuffer, {
            freezeObjects: freezeObjects,
            shared: target.shared
        });
    }
    var totalSizeTableLength = sizeTableBuffer.length;
    var totalDPackLength;
    var rootBlockLength;
    var type = sizeTableBuffer[0] >> 6;
    var offset;
    if (type === 2) {
        rootBlockLength = sizeTableBuffer.readUInt16BE(4);
        offset = 6;
    } else {
        rootBlockLength = sizeTableBuffer.readUIntBE(10, 6);
        offset = 16;
    }
    // read child block lengths: (could defer this until child access)
    var childSizeTables = [];
    var childDpackBlocks = [];
    var dpackChildOffset = rootBlockLength;
    while(offset < totalSizeTableLength){
        var type = sizeTableBuffer[offset] >> 6;
        var sizeTableLength;
        var dpackLength;
        if (type < 2) {
            if (type == 0) {
                // 6 bit
                sizeTableLength = 1;
                dpackLength = sizeTableBuffer[offset];
            } else {
                // 14 bit
                sizeTableLength = 2;
                dpackLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff;
            }
        } else if (type === 2) {
            sizeTableLength = sizeTableBuffer.readUInt16BE(offset) & 0x3fff;
            dpackLength = sizeTableBuffer.readUInt16BE(offset + 2);
        } else {
            sizeTableLength = sizeTableBuffer.readUInt32BE(offset) & 0x3fffffff;
            dpackLength = sizeTableBuffer.readUIntBE(offset + 4, 6);
        }
        childSizeTables.push(type < 2 || type == 3 && sizeTableLength == 16 ? undefined : sizeTableBuffer.slice(offset, offset + sizeTableLength));
        offset += sizeTableLength;
        childDpackBlocks.push(dpackBuffer.slice(dpackChildOffset, dpackChildOffset += dpackLength));
    }
    var blockIndex = 0;
    var rootBlock = target.dpackBuffer.slice(0, rootBlockLength);
    return target.parsed = parse(rootBlock, childDpackBlocks.length > 0 ? {
        shared: target.shared,
        forDeferred: function(value, property) {
            let target = new value.constructor;
            target.dpackBuffer = childDpackBlocks[blockIndex];
            target.sizeTableBuffer = childSizeTables[blockIndex++];
            target.shared = property ? property.upgrade ? property : {
                code: property.code,
                key: null,
                type: property.type
            } : null;
            return new Proxy(target, onDemandHandler);
        },
        freezeObjects: freezeObjects
    } : {
        shared: target.shared
    });
}
function getSerialized(target, shareProperty) {
    var childBlocks = [];
    var childSizeTables = [];
    var childDpackSizes = 0;
    var mustSequence // mustSequence is an indication that the blocks must be read in sequence and can't be randomly accessed
    ;
    var serializerOptions = {
        forBlock: function(block, property) {
            var dpackBuffer = block[bufferSymbol](property, true);
            if (dpackBuffer.mustSequence) {
                mustSequence = true;
                childBlocks.push(dpackBuffer);
                return dpackBuffer;
            }
            var sizeTableBuffer = block[sizeTableSymbol];
            if (!sizeTableBuffer) {
                // if this child has no children, it won't have have size table, just create a leaf branch buffer
                var bufferLength = dpackBuffer.length;
                if (bufferLength < 64) {
                    // one byte leaf node
                    sizeTableBuffer = Buffer.from([
                        bufferLength
                    ]);
                } else if (bufferLength < 0x4000) {
                    // binary-10 and then 14 bits
                    sizeTableBuffer = Buffer.from([
                        bufferLength >> 8 | 0x40,
                        bufferLength & 0xff
                    ]);
                } else {
                    sizeTableBuffer = Buffer.allocUnsafe(16);
                    sizeTableBuffer.writeUInt32BE(0xc0000010) // binary-11 and then indicate a size of 16
                    ;
                    sizeTableBuffer.writeUIntBE(bufferLength, 4, 6);
                    sizeTableBuffer.writeUIntBE(bufferLength, 10, 6);
                }
            }
            childSizeTables.push(sizeTableBuffer);
            childDpackSizes += dpackBuffer.length;
            childBlocks.push(dpackBuffer);
            return dpackBuffer;
        },
        shared: shareProperty,
        freezeObjects: freezeObjects
    };
    var rootBlock = serialize(target.parsed, serializerOptions);
    if (childBlocks.length == 0) {
        // no child blocks, just use the root block
        return target.dpackBuffer = rootBlock;
    }
    childBlocks.unshift(rootBlock);
    // TODO: Do word aligment with any buffer copying, to make sure CPU can copy words instead of bytes
    var dpackBuffer = target.dpackBuffer = Buffer.concat(childBlocks);
    if (mustSequence) {
        return dpackBuffer;
    }
    var ourSizeBlock = Buffer.allocUnsafe(dpackBuffer.length >= 0x10000 ? 16 : 6);
    childSizeTables.unshift(ourSizeBlock);
    // TODO: Add length parameter to concat so it is length % 8 = 0
    ourSizeBlock = target.sizeTableBuffer = Buffer.concat(childSizeTables);
    if (dpackBuffer.length >= 0x10000) {
        ourSizeBlock.writeUInt32BE(ourSizeBlock.length + 0xc0000000, 0) // binary-11 and then 30 bits
        ;
        ourSizeBlock.writeUIntBE(dpackBuffer.length, 4, 6) // 48 bits
        ;
        ourSizeBlock.writeUIntBE(rootBlock.length, 10, 6) // 48 bits
        ;
    } else {
        ourSizeBlock.writeUInt16BE(ourSizeBlock.length | 0x8000, 0) // binary-10 and then 14 bits
        ;
        ourSizeBlock.writeUInt16BE(dpackBuffer.length, 2) // 16 bits
        ;
        ourSizeBlock.writeUInt16BE(rootBlock.length, 4) // 16 bits
        ;
    }
    return dpackBuffer;
}
function deepCopy(source) {
    let target = new source.constructor();
    for(let key in source){
        let value = source[key];
        if (value && typeof value == 'object') value = deepCopy(value);
        target[key] = value;
    }
    return target;
}
var parse = __turbopack_context__.r("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)").parse;
var serializeSharedBlock = __turbopack_context__.r("[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)").serializeSharedBlock;
exports.parseLazy = function(buffer, options) {
    if (buffer[0] & 0x80 || buffer[0] >> 4 === 3 || buffer[0] === 0x77) {
        return makeBlockFromBuffer(buffer, options && options.shared);
    } else {
        return parse(buffer, options);
    }
};
}}),
"[project]/node_modules/dpack/index.js [app-route] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*
DPack - Fast, compact object structure encoding.
*/ exports.createSerializeStream = __turbopack_context__.r("[project]/node_modules/dpack/lib/serialize-stream.js [app-route] (ecmascript)").createSerializeStream;
exports.createParseStream = __turbopack_context__.r("[project]/node_modules/dpack/lib/parse-stream.js [app-route] (ecmascript)").createParseStream;
const serialize = __turbopack_context__.r("[project]/node_modules/dpack/lib/serialize.js [app-route] (ecmascript)");
serialize.nodeCharEncoder = __turbopack_context__.r("[project]/node_modules/dpack/lib/node-encoder.js [app-route] (ecmascript)").nodeCharEncoder;
const parse = __turbopack_context__.r("[project]/node_modules/dpack/lib/parse.js [app-route] (ecmascript)");
const Options = __turbopack_context__.r("[project]/node_modules/dpack/lib/Options.js [app-route] (ecmascript)").Options;
exports.serialize = serialize.serialize;
exports.parse = parse.parse;
exports.createSerializer = serialize.createSerializer;
exports.createParser = parse.createParser;
const Block = __turbopack_context__.r("[project]/node_modules/dpack/lib/Block.js [app-route] (ecmascript)");
exports.parseLazy = Block.parseLazy;
exports.asBlock = Block.asBlock;
exports.isBlock = Block.isBlock;
exports.copy = Block.copy;
exports.reassignBuffers = Block.reassignBuffers;
exports.Options = Options;
exports.createSharedStructure = __turbopack_context__.r("[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)").createSharedStructure;
exports.readSharedStructure = __turbopack_context__.r("[project]/node_modules/dpack/lib/shared.js [app-route] (ecmascript)").readSharedStructure;
}}),
"[project]/node_modules/@orama/plugin-data-persistence/dist/errors.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "FILESYSTEM_NOT_SUPPORTED_ON_RUNTIME": (()=>FILESYSTEM_NOT_SUPPORTED_ON_RUNTIME),
    "METHOD_MOVED": (()=>METHOD_MOVED),
    "UNSUPPORTED_FORMAT": (()=>UNSUPPORTED_FORMAT)
});
function capitalize(word) {
    return `${word.slice(0, 1).toUpperCase()}${word.slice(1).toLowerCase()}`;
}
function UNSUPPORTED_FORMAT(format) {
    return `Unsupported serialization format: ${format}`;
}
function FILESYSTEM_NOT_SUPPORTED_ON_RUNTIME(runtime) {
    return `Filesystem access is not supported on ${capitalize(runtime)}`;
}
function METHOD_MOVED(method) {
    return `Function ${method} has been moved to the "/server" module. \n\nImport it via "import { ${method} } from 'orama/plugin-data-persistence/server'". \n\nRead more at https://docs.oramasearch.com/open-source/plugins/plugin-data-persistence.`;
} //# sourceMappingURL=errors.js.map
}}),
"[project]/node_modules/@orama/plugin-data-persistence/dist/utils.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "detectRuntime": (()=>detectRuntime)
});
function detectRuntime() {
    /* c8 ignore next 11 */ if (typeof process !== 'undefined' && process.versions !== undefined) {
        return 'node';
    // @ts-expect-error "Deno" global variable is defined in Deno only
    } else if (typeof Deno !== 'undefined') {
        return 'deno';
    // @ts-expect-error "Bun" global variable is defined in Bun only
    } else if (typeof Bun !== 'undefined') {
        return 'bun';
    } else if ("TURBOPACK compile-time falsy", 0) {
        "TURBOPACK unreachable";
    }
    return 'unknown';
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@orama/plugin-data-persistence/dist/index.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "persist": (()=>persist),
    "persistToFile": (()=>persistToFile),
    "restore": (()=>restore),
    "restoreFromFile": (()=>restoreFromFile)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$decode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/decode.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$encode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@msgpack/msgpack/dist.es5+esm/encode.mjs [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$orama$2f$dist$2f$methods$2f$create$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@orama/orama/dist/methods/create.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$orama$2f$dist$2f$methods$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@orama/orama/dist/methods/serialization.js [app-route] (ecmascript)");
// @ts-expect-error dpack does not expose types
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dpack$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/dpack/index.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@orama/plugin-data-persistence/dist/errors.js [app-route] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@orama/plugin-data-persistence/dist/utils.js [app-route] (ecmascript)");
;
;
;
;
;
const hexFromMap = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15
};
const hexToMap = Object.keys(hexFromMap);
/* c8 ignore next 13 */ function slowHexToBuffer(hex) {
    const bytes = new Uint8Array(Math.floor(hex.length / 2));
    hex = hex.toLowerCase();
    for(let i = 0; i < hex.length; i++){
        const a = hexFromMap[hex[i * 2]];
        const b = hexFromMap[hex[i * 2 + 1]];
        if (a === undefined || b === undefined) {
            break;
        }
        bytes[i] = a << 4 | b;
    }
    return bytes;
}
/* c8 ignore next 5 */ function slowHexToString(bytes) {
    return Array.from(bytes || []).map((b)=>hexToMap[b >> 4] + hexToMap[b & 15]).join('');
}
async function persist(db, format = 'binary', runtime) {
    if (!runtime) {
        runtime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["detectRuntime"])();
    }
    const dbExport = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$orama$2f$dist$2f$methods$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["save"])(db);
    let serialized;
    switch(format){
        case 'json':
            serialized = JSON.stringify(dbExport);
            break;
        case 'dpack':
            serialized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dpack$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["serialize"])(dbExport);
            break;
        case 'binary':
            {
                const msgpack = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$encode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["encode"])(dbExport);
                if (runtime === 'node') {
                    serialized = Buffer.from(msgpack.buffer, msgpack.byteOffset, msgpack.byteLength);
                    serialized = serialized.toString('hex');
                /* c8 ignore next 3 */ } else {
                    serialized = slowHexToString(msgpack);
                }
            }
            break;
        default:
            throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNSUPPORTED_FORMAT"])(format));
    }
    return serialized;
}
async function restore(format, data, runtime) {
    if (!runtime) {
        runtime = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$utils$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["detectRuntime"])();
    }
    const db = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$orama$2f$dist$2f$methods$2f$create$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["create"])({
        schema: {
            __placeholder: 'string'
        }
    });
    let deserialized;
    switch(format){
        case 'json':
            deserialized = JSON.parse(data.toString());
            break;
        case 'dpack':
            deserialized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$dpack$2f$index$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["parse"])(data);
            break;
        case 'binary':
            if (runtime === 'node') {
                data = Buffer.from(data.toString(), 'hex');
            /* c8 ignore next 3 */ } else {
                data = slowHexToBuffer(data);
            }
            deserialized = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$msgpack$2f$msgpack$2f$dist$2e$es5$2b$esm$2f$decode$2e$mjs__$5b$app$2d$route$5d$__$28$ecmascript$29$__["decode"])(data);
            break;
        default:
            throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["UNSUPPORTED_FORMAT"])(format));
    }
    await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$orama$2f$dist$2f$methods$2f$serialization$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["load"])(db, deserialized);
    return db;
}
async function persistToFile(db, format = 'binary', path, runtime) {
    throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_MOVED"])('persistToFile'));
}
async function restoreFromFile(format = 'binary', path, runtime) {
    throw new Error((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$orama$2f$plugin$2d$data$2d$persistence$2f$dist$2f$errors$2e$js__$5b$app$2d$route$5d$__$28$ecmascript$29$__["METHOD_MOVED"])('restoreFromFile'));
} //# sourceMappingURL=index.js.map
}}),
"[project]/node_modules/openai-edge/dist/index.mjs [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* tslint:disable */ /* eslint-disable */ /**
 * OpenAI API
 * APIs for sampling from and fine-tuning language models
 *
 * The version of the OpenAPI document: 1.3.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */ __turbopack_context__.s({
    "ChatCompletionRequestMessageRoleEnum": (()=>ChatCompletionRequestMessageRoleEnum),
    "ChatCompletionResponseMessageRoleEnum": (()=>ChatCompletionResponseMessageRoleEnum),
    "Configuration": (()=>Configuration),
    "CreateImageRequestResponseFormatEnum": (()=>CreateImageRequestResponseFormatEnum),
    "CreateImageRequestSizeEnum": (()=>CreateImageRequestSizeEnum),
    "OpenAIApi": (()=>OpenAIApi),
    "OpenAIApiFactory": (()=>OpenAIApiFactory),
    "OpenAIApiFp": (()=>OpenAIApiFp),
    "OpenAIApiParamCreator": (()=>OpenAIApiParamCreator)
});
const BASE_PATH = "https://api.openai.com/v1".replace(/\/+$/, "");
const globalFetch$1 = typeof fetch === "undefined" ? undefined : fetch;
/**
 *
 * @export
 * @class BaseAPI
 */ class BaseAPI {
    basePath;
    fetch;
    configuration;
    constructor(configuration, basePath = BASE_PATH, fetch1 = globalFetch$1){
        this.basePath = basePath;
        this.fetch = fetch1;
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */ class RequiredError extends Error {
    field;
    constructor(field, msg){
        super(msg);
        this.field = field;
        this.name = "RequiredError";
    }
}
/* tslint:disable */ /**
 *
 * @export
 */ const DUMMY_BASE_URL = "https://example.com";
/**
 *
 * @throws {RequiredError}
 * @export
 */ const assertParamExists = function(functionName, paramName, paramValue) {
    if (paramValue === null || paramValue === undefined) {
        throw new RequiredError(paramName, `Required parameter ${paramName} was null or undefined when calling ${functionName}.`);
    }
};
function setFlattenedQueryParams(urlSearchParams, parameter, key = "") {
    if (parameter == null) return;
    if (typeof parameter === "object") {
        if (Array.isArray(parameter)) {
            parameter.forEach((item)=>setFlattenedQueryParams(urlSearchParams, item, key));
        } else {
            Object.keys(parameter).forEach((currentKey)=>setFlattenedQueryParams(urlSearchParams, parameter[currentKey], `${key}${key !== "" ? "." : ""}${currentKey}`));
        }
    } else {
        if (urlSearchParams.has(key)) {
            urlSearchParams.append(key, parameter);
        } else {
            urlSearchParams.set(key, parameter);
        }
    }
}
/**
 *
 * @export
 */ const setSearchParams = function(url, ...objects) {
    const searchParams = new URLSearchParams(url.search);
    setFlattenedQueryParams(searchParams, objects);
    url.search = searchParams.toString();
};
/**
 *
 * @export
 */ const serializeDataIfNeeded = function(value, requestOptions, configuration) {
    const nonString = typeof value !== "string";
    const needsSerialization = nonString && configuration && configuration.isJsonMime ? configuration.isJsonMime(requestOptions.headers["Content-Type"]) : nonString;
    return needsSerialization ? JSON.stringify(value !== undefined ? value : {}) : value || "";
};
/**
 *
 * @export
 */ const toPathString = function(url) {
    return url.pathname + url.search + url.hash;
};
/**
 *
 * @export
 */ const createRequestFunction = function(fetchArgs, globalFetch, BASE_PATH, configuration) {
    return (fetch1 = globalFetch, basePath = BASE_PATH)=>{
        if (typeof fetch1 === "undefined") {
            throw new Error("You must pass a fetch polyfill if you're running in an environment without a global fetch");
        }
        let url = fetchArgs.url;
        if (configuration?.defaultQueryParams) {
            const queryPrefix = url.indexOf("?") === -1 ? "?" : "&";
            url += queryPrefix + configuration.defaultQueryParams;
        }
        return fetch1((configuration?.basePath || basePath) + url, fetchArgs.options);
    };
};
/* tslint:disable */ const globalFetch = typeof fetch === "undefined" ? undefined : fetch;
const ChatCompletionRequestMessageRoleEnum = {
    System: "system",
    User: "user",
    Assistant: "assistant",
    Function: "function"
};
const ChatCompletionResponseMessageRoleEnum = {
    System: "system",
    User: "user",
    Assistant: "assistant",
    Function: "function"
};
const CreateImageRequestSizeEnum = {
    _256x256: "256x256",
    _512x512: "512x512",
    _1024x1024: "1024x1024"
};
const CreateImageRequestResponseFormatEnum = {
    Url: "url",
    B64Json: "b64_json"
};
/**
 * OpenAIApi - parameter creator
 * @export
 */ const OpenAIApiParamCreator = function(configuration) {
    return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ cancelFineTune: async (fineTuneId, options = {})=>{
            // verify required parameter 'fineTuneId' is not null or undefined
            assertParamExists("cancelFineTune", "fineTuneId", fineTuneId);
            const localVarPath = `/fine-tunes/{fine_tune_id}/cancel`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ createAnswer: async (createAnswerRequest, options = {})=>{
            // verify required parameter 'createAnswerRequest' is not null or undefined
            assertParamExists("createAnswer", "createAnswerRequest", createAnswerRequest);
            const localVarPath = `/answers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createAnswerRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates a model response for the given chat conversation.
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createChatCompletion: async (createChatCompletionRequest, options = {})=>{
            // verify required parameter 'createChatCompletionRequest' is not null or undefined
            assertParamExists("createChatCompletion", "createChatCompletionRequest", createChatCompletionRequest);
            const localVarPath = `/chat/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createChatCompletionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ createClassification: async (createClassificationRequest, options = {})=>{
            // verify required parameter 'createClassificationRequest' is not null or undefined
            assertParamExists("createClassification", "createClassificationRequest", createClassificationRequest);
            const localVarPath = `/classifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createClassificationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createCompletion: async (createCompletionRequest, options = {})=>{
            // verify required parameter 'createCompletionRequest' is not null or undefined
            assertParamExists("createCompletion", "createCompletionRequest", createCompletionRequest);
            const localVarPath = `/completions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createCompletionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createEdit: async (createEditRequest, options = {})=>{
            // verify required parameter 'createEditRequest' is not null or undefined
            assertParamExists("createEdit", "createEditRequest", createEditRequest);
            const localVarPath = `/edits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createEditRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createEmbedding: async (createEmbeddingRequest, options = {})=>{
            // verify required parameter 'createEmbeddingRequest' is not null or undefined
            assertParamExists("createEmbedding", "createEmbeddingRequest", createEmbeddingRequest);
            const localVarPath = `/embeddings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createEmbeddingRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createFile: async (file, purpose, options = {})=>{
            // verify required parameter 'file' is not null or undefined
            assertParamExists("createFile", "file", file);
            // verify required parameter 'purpose' is not null or undefined
            assertParamExists("createFile", "purpose", purpose);
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (file !== undefined) {
                localVarFormParams.append("file", file);
            }
            if (purpose !== undefined) {
                localVarFormParams.append("purpose", purpose);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...localVarFormParams.getHeaders(),
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createFineTune: async (createFineTuneRequest, options = {})=>{
            // verify required parameter 'createFineTuneRequest' is not null or undefined
            assertParamExists("createFineTune", "createFineTuneRequest", createFineTuneRequest);
            const localVarPath = `/fine-tunes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createFineTuneRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createImage: async (createImageRequest, options = {})=>{
            // verify required parameter 'createImageRequest' is not null or undefined
            assertParamExists("createImage", "createImageRequest", createImageRequest);
            const localVarPath = `/images/generations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createImageRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createImageEdit: async (image, prompt, mask, n, size, responseFormat, user, options = {})=>{
            // verify required parameter 'image' is not null or undefined
            assertParamExists("createImageEdit", "image", image);
            // verify required parameter 'prompt' is not null or undefined
            assertParamExists("createImageEdit", "prompt", prompt);
            const localVarPath = `/images/edits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (image !== undefined) {
                localVarFormParams.append("image", image);
            }
            if (mask !== undefined) {
                localVarFormParams.append("mask", mask);
            }
            if (prompt !== undefined) {
                localVarFormParams.append("prompt", prompt);
            }
            if (n !== undefined) {
                localVarFormParams.append("n", n);
            }
            if (size !== undefined) {
                localVarFormParams.append("size", size);
            }
            if (responseFormat !== undefined) {
                localVarFormParams.append("response_format", responseFormat);
            }
            if (user !== undefined) {
                localVarFormParams.append("user", user);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...localVarFormParams.getHeaders(),
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createImageVariation: async (image, n, size, responseFormat, user, options = {})=>{
            // verify required parameter 'image' is not null or undefined
            assertParamExists("createImageVariation", "image", image);
            const localVarPath = `/images/variations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (image !== undefined) {
                localVarFormParams.append("image", image);
            }
            if (n !== undefined) {
                localVarFormParams.append("n", n);
            }
            if (size !== undefined) {
                localVarFormParams.append("size", size);
            }
            if (responseFormat !== undefined) {
                localVarFormParams.append("response_format", responseFormat);
            }
            if (user !== undefined) {
                localVarFormParams.append("user", user);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...localVarFormParams.getHeaders(),
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createModeration: async (createModerationRequest, options = {})=>{
            // verify required parameter 'createModerationRequest' is not null or undefined
            assertParamExists("createModeration", "createModerationRequest", createModerationRequest);
            const localVarPath = `/moderations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createModerationRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ createSearch: async (engineId, createSearchRequest, options = {})=>{
            // verify required parameter 'engineId' is not null or undefined
            assertParamExists("createSearch", "engineId", engineId);
            // verify required parameter 'createSearchRequest' is not null or undefined
            assertParamExists("createSearch", "createSearchRequest", createSearchRequest);
            const localVarPath = `/engines/{engine_id}/search`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = serializeDataIfNeeded(createSearchRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createTranscription: async (file, model, prompt, responseFormat, temperature, language, options = {})=>{
            // verify required parameter 'file' is not null or undefined
            assertParamExists("createTranscription", "file", file);
            // verify required parameter 'model' is not null or undefined
            assertParamExists("createTranscription", "model", model);
            const localVarPath = `/audio/transcriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (file !== undefined) {
                localVarFormParams.append("file", file);
            }
            if (model !== undefined) {
                localVarFormParams.append("model", model);
            }
            if (prompt !== undefined) {
                localVarFormParams.append("prompt", prompt);
            }
            if (responseFormat !== undefined) {
                localVarFormParams.append("response_format", responseFormat);
            }
            if (temperature !== undefined) {
                localVarFormParams.append("temperature", temperature);
            }
            if (language !== undefined) {
                localVarFormParams.append("language", language);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...localVarFormParams.getHeaders(),
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createTranslation: async (file, model, prompt, responseFormat, temperature, options = {})=>{
            // verify required parameter 'file' is not null or undefined
            assertParamExists("createTranslation", "file", file);
            // verify required parameter 'model' is not null or undefined
            assertParamExists("createTranslation", "model", model);
            const localVarPath = `/audio/translations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "POST",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new (configuration && configuration.formDataCtor || FormData)();
            if (file !== undefined) {
                localVarFormParams.append("file", file);
            }
            if (model !== undefined) {
                localVarFormParams.append("model", model);
            }
            if (prompt !== undefined) {
                localVarFormParams.append("prompt", prompt);
            }
            if (responseFormat !== undefined) {
                localVarFormParams.append("response_format", responseFormat);
            }
            if (temperature !== undefined) {
                localVarFormParams.append("temperature", temperature);
            }
            localVarHeaderParameter["Content-Type"] = "multipart/form-data";
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...localVarFormParams.getHeaders(),
                ...headersFromBaseOptions,
                ...options.headers
            };
            localVarRequestOptions.body = localVarFormParams;
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ deleteFile: async (fileId, options = {})=>{
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists("deleteFile", "fileId", fileId);
            const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "DELETE",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ deleteModel: async (model, options = {})=>{
            // verify required parameter 'model' is not null or undefined
            assertParamExists("deleteModel", "model", model);
            const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "DELETE",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ downloadFile: async (fileId, options = {})=>{
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists("downloadFile", "fileId", fileId);
            const localVarPath = `/files/{file_id}/content`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ listEngines: async (options = {})=>{
            const localVarPath = `/engines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listFiles: async (options = {})=>{
            const localVarPath = `/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listFineTuneEvents: async (fineTuneId, stream, options = {})=>{
            // verify required parameter 'fineTuneId' is not null or undefined
            assertParamExists("listFineTuneEvents", "fineTuneId", fineTuneId);
            const localVarPath = `/fine-tunes/{fine_tune_id}/events`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (stream !== undefined) {
                localVarQueryParameter["stream"] = stream;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listFineTunes: async (options = {})=>{
            const localVarPath = `/fine-tunes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listModels: async (options = {})=>{
            const localVarPath = `/models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ retrieveEngine: async (engineId, options = {})=>{
            // verify required parameter 'engineId' is not null or undefined
            assertParamExists("retrieveEngine", "engineId", engineId);
            const localVarPath = `/engines/{engine_id}`.replace(`{${"engine_id"}}`, encodeURIComponent(String(engineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ retrieveFile: async (fileId, options = {})=>{
            // verify required parameter 'fileId' is not null or undefined
            assertParamExists("retrieveFile", "fileId", fileId);
            const localVarPath = `/files/{file_id}`.replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ retrieveFineTune: async (fineTuneId, options = {})=>{
            // verify required parameter 'fineTuneId' is not null or undefined
            assertParamExists("retrieveFineTune", "fineTuneId", fineTuneId);
            const localVarPath = `/fine-tunes/{fine_tune_id}`.replace(`{${"fine_tune_id"}}`, encodeURIComponent(String(fineTuneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ retrieveModel: async (model, options = {})=>{
            // verify required parameter 'model' is not null or undefined
            assertParamExists("retrieveModel", "model", model);
            const localVarPath = `/models/{model}`.replace(`{${"model"}}`, encodeURIComponent(String(model)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = {
                method: "GET",
                ...baseOptions,
                ...options
            };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers
            };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions
            };
        }
    };
};
/**
 * OpenAIApi - functional programming interface
 * @export
 */ const OpenAIApiFp = function(configuration) {
    const localVarParamCreator = OpenAIApiParamCreator(configuration);
    return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async cancelFineTune (fineTuneId, options) {
            const localVarArgs = await localVarParamCreator.cancelFineTune(fineTuneId, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ async createAnswer (createAnswerRequest, options) {
            const localVarArgs = await localVarParamCreator.createAnswer(createAnswerRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a model response for the given chat conversation.
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createChatCompletion (createChatCompletionRequest, options) {
            const localVarArgs = await localVarParamCreator.createChatCompletion(createChatCompletionRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ async createClassification (createClassificationRequest, options) {
            const localVarArgs = await localVarParamCreator.createClassification(createClassificationRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createCompletion (createCompletionRequest, options) {
            const localVarArgs = await localVarParamCreator.createCompletion(createCompletionRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createEdit (createEditRequest, options) {
            const localVarArgs = await localVarParamCreator.createEdit(createEditRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createEmbedding (createEmbeddingRequest, options) {
            const localVarArgs = await localVarParamCreator.createEmbedding(createEmbeddingRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createFile (file, purpose, options) {
            const localVarArgs = await localVarParamCreator.createFile(file, purpose, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createFineTune (createFineTuneRequest, options) {
            const localVarArgs = await localVarParamCreator.createFineTune(createFineTuneRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createImage (createImageRequest, options) {
            const localVarArgs = await localVarParamCreator.createImage(createImageRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createImageEdit (image, prompt, mask, n, size, responseFormat, user, options) {
            const localVarArgs = await localVarParamCreator.createImageEdit(image, prompt, mask, n, size, responseFormat, user, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createImageVariation (image, n, size, responseFormat, user, options) {
            const localVarArgs = await localVarParamCreator.createImageVariation(image, n, size, responseFormat, user, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createModeration (createModerationRequest, options) {
            const localVarArgs = await localVarParamCreator.createModeration(createModerationRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ async createSearch (engineId, createSearchRequest, options) {
            const localVarArgs = await localVarParamCreator.createSearch(engineId, createSearchRequest, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createTranscription (file, model, prompt, responseFormat, temperature, language, options) {
            const localVarArgs = await localVarParamCreator.createTranscription(file, model, prompt, responseFormat, temperature, language, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async createTranslation (file, model, prompt, responseFormat, temperature, options) {
            const localVarArgs = await localVarParamCreator.createTranslation(file, model, prompt, responseFormat, temperature, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async deleteFile (fileId, options) {
            const localVarArgs = await localVarParamCreator.deleteFile(fileId, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async deleteModel (model, options) {
            const localVarArgs = await localVarParamCreator.deleteModel(model, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async downloadFile (fileId, options) {
            const localVarArgs = await localVarParamCreator.downloadFile(fileId, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ async listEngines (options) {
            const localVarArgs = await localVarParamCreator.listEngines(options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async listFiles (options) {
            const localVarArgs = await localVarParamCreator.listFiles(options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async listFineTuneEvents (fineTuneId, stream, options) {
            const localVarArgs = await localVarParamCreator.listFineTuneEvents(fineTuneId, stream, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async listFineTunes (options) {
            const localVarArgs = await localVarParamCreator.listFineTunes(options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async listModels (options) {
            const localVarArgs = await localVarParamCreator.listModels(options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ async retrieveEngine (engineId, options) {
            const localVarArgs = await localVarParamCreator.retrieveEngine(engineId, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async retrieveFile (fileId, options) {
            const localVarArgs = await localVarParamCreator.retrieveFile(fileId, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async retrieveFineTune (fineTuneId, options) {
            const localVarArgs = await localVarParamCreator.retrieveFineTune(fineTuneId, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ async retrieveModel (model, options) {
            const localVarArgs = await localVarParamCreator.retrieveModel(model, options);
            return createRequestFunction(localVarArgs, globalFetch, BASE_PATH, configuration);
        }
    };
};
/**
 * OpenAIApi - factory interface
 * @export
 */ const OpenAIApiFactory = function(configuration, basePath, fetch1) {
    const localVarFp = OpenAIApiFp(configuration);
    return {
        /**
         *
         * @summary Immediately cancel a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ cancelFineTune (fineTuneId, options) {
            return localVarFp.cancelFineTune(fineTuneId, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
         * @param {CreateAnswerRequest} createAnswerRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ createAnswer (createAnswerRequest, options) {
            return localVarFp.createAnswer(createAnswerRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates a model response for the given chat conversation.
         * @param {CreateChatCompletionRequest} createChatCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createChatCompletion (createChatCompletionRequest, options) {
            return localVarFp.createChatCompletion(createChatCompletionRequest, options).then((request)=>{
                return request(fetch1, basePath);
            });
        },
        /**
         *
         * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
         * @param {CreateClassificationRequest} createClassificationRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ createClassification (createClassificationRequest, options) {
            return localVarFp.createClassification(createClassificationRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates a completion for the provided prompt and parameters.
         * @param {CreateCompletionRequest} createCompletionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createCompletion (createCompletionRequest, options) {
            return localVarFp.createCompletion(createCompletionRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates a new edit for the provided input, instruction, and parameters.
         * @param {CreateEditRequest} createEditRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createEdit (createEditRequest, options) {
            return localVarFp.createEdit(createEditRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates an embedding vector representing the input text.
         * @param {CreateEmbeddingRequest} createEmbeddingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createEmbedding (createEmbeddingRequest, options) {
            return localVarFp.createEmbedding(createEmbeddingRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
         * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createFile (file, purpose, options) {
            return localVarFp.createFile(file, purpose, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {CreateFineTuneRequest} createFineTuneRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createFineTune (createFineTuneRequest, options) {
            return localVarFp.createFineTune(createFineTuneRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates an image given a prompt.
         * @param {CreateImageRequest} createImageRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createImage (createImageRequest, options) {
            return localVarFp.createImage(createImageRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates an edited or extended image given an original image and a prompt.
         * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
         * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
         * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createImageEdit (image, prompt, mask, n, size, responseFormat, user, options) {
            return localVarFp.createImageEdit(image, prompt, mask, n, size, responseFormat, user, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Creates a variation of a given image.
         * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
         * @param {number} [n] The number of images to generate. Must be between 1 and 10.
         * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
         * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
         * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createImageVariation (image, n, size, responseFormat, user, options) {
            return localVarFp.createImageVariation(image, n, size, responseFormat, user, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Classifies if text violates OpenAI\'s Content Policy
         * @param {CreateModerationRequest} createModerationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createModeration (createModerationRequest, options) {
            return localVarFp.createModeration(createModerationRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
         * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
         * @param {CreateSearchRequest} createSearchRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ createSearch (engineId, createSearchRequest, options) {
            return localVarFp.createSearch(engineId, createSearchRequest, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Transcribes audio into the input language.
         * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createTranscription (file, model, prompt, responseFormat, temperature, language, options) {
            return localVarFp.createTranscription(file, model, prompt, responseFormat, temperature, language, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Translates audio into into English.
         * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
         * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
         * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
         * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
         * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ createTranslation (file, model, prompt, responseFormat, temperature, options) {
            return localVarFp.createTranslation(file, model, prompt, responseFormat, temperature, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ deleteFile (fileId, options) {
            return localVarFp.deleteFile(fileId, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
         * @param {string} model The model to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ deleteModel (model, options) {
            return localVarFp.deleteModel(model, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ downloadFile (fileId, options) {
            return localVarFp.downloadFile(fileId, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ listEngines (options) {
            return localVarFp.listEngines(options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listFiles (options) {
            return localVarFp.listFiles(options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Get fine-grained status updates for a fine-tune job.
         * @param {string} fineTuneId The ID of the fine-tune job to get events for.
         * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listFineTuneEvents (fineTuneId, stream, options) {
            return localVarFp.listFineTuneEvents(fineTuneId, stream, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary List your organization\'s fine-tuning jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listFineTunes (options) {
            return localVarFp.listFineTunes(options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ listModels (options) {
            return localVarFp.listModels(options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
         * @param {string} engineId The ID of the engine to use for this request
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */ retrieveEngine (engineId, options) {
            return localVarFp.retrieveEngine(engineId, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ retrieveFile (fileId, options) {
            return localVarFp.retrieveFile(fileId, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
         * @param {string} fineTuneId The ID of the fine-tune job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ retrieveFineTune (fineTuneId, options) {
            return localVarFp.retrieveFineTune(fineTuneId, options).then((request)=>request(fetch1, basePath));
        },
        /**
         *
         * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
         * @param {string} model The ID of the model to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */ retrieveModel (model, options) {
            return localVarFp.retrieveModel(model, options).then((request)=>request(fetch1, basePath));
        }
    };
};
/**
 * OpenAIApi - object-oriented interface
 * @export
 * @class OpenAIApi
 * @extends {BaseAPI}
 */ class OpenAIApi extends BaseAPI {
    /**
     *
     * @summary Immediately cancel a fine-tune job.
     * @param {string} fineTuneId The ID of the fine-tune job to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ cancelFineTune(fineTuneId, options) {
        return OpenAIApiFp(this.configuration).cancelFineTune(fineTuneId, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Answers the specified question using the provided documents and examples.  The endpoint first [searches](/docs/api-reference/searches) over provided documents or files to find relevant context. The relevant context is combined with the provided examples and question to create the prompt for [completion](/docs/api-reference/completions).
     * @param {CreateAnswerRequest} createAnswerRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createAnswer(createAnswerRequest, options) {
        return OpenAIApiFp(this.configuration).createAnswer(createAnswerRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates a model response for the given chat conversation.
     * @param {CreateChatCompletionRequest} createChatCompletionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createChatCompletion(createChatCompletionRequest, options) {
        return OpenAIApiFp(this.configuration).createChatCompletion(createChatCompletionRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Classifies the specified `query` using provided examples.  The endpoint first [searches](/docs/api-reference/searches) over the labeled examples to select the ones most relevant for the particular query. Then, the relevant examples are combined with the query to construct a prompt to produce the final label via the [completions](/docs/api-reference/completions) endpoint.  Labeled examples can be provided via an uploaded `file`, or explicitly listed in the request using the `examples` parameter for quick tests and small scale use cases.
     * @param {CreateClassificationRequest} createClassificationRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createClassification(createClassificationRequest, options) {
        return OpenAIApiFp(this.configuration).createClassification(createClassificationRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates a completion for the provided prompt and parameters.
     * @param {CreateCompletionRequest} createCompletionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createCompletion(createCompletionRequest, options) {
        return OpenAIApiFp(this.configuration).createCompletion(createCompletionRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates a new edit for the provided input, instruction, and parameters.
     * @param {CreateEditRequest} createEditRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createEdit(createEditRequest, options) {
        return OpenAIApiFp(this.configuration).createEdit(createEditRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates an embedding vector representing the input text.
     * @param {CreateEmbeddingRequest} createEmbeddingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createEmbedding(createEmbeddingRequest, options) {
        return OpenAIApiFp(this.configuration).createEmbedding(createEmbeddingRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file Name of the [JSON Lines](https://jsonlines.readthedocs.io/en/latest/) file to be uploaded.  If the &#x60;purpose&#x60; is set to \\\&quot;fine-tune\\\&quot;, each line is a JSON record with \\\&quot;prompt\\\&quot; and \\\&quot;completion\\\&quot; fields representing your [training examples](/docs/guides/fine-tuning/prepare-training-data).
     * @param {string} purpose The intended purpose of the uploaded documents.  Use \\\&quot;fine-tune\\\&quot; for [Fine-tuning](/docs/api-reference/fine-tunes). This allows us to validate the format of the uploaded file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createFile(file, purpose, options) {
        return OpenAIApiFp(this.configuration).createFile(file, purpose, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates a job that fine-tunes a specified model from a given dataset.  Response includes details of the enqueued job including job status and the name of the fine-tuned models once complete.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
     * @param {CreateFineTuneRequest} createFineTuneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createFineTune(createFineTuneRequest, options) {
        return OpenAIApiFp(this.configuration).createFineTune(createFineTuneRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates an image given a prompt.
     * @param {CreateImageRequest} createImageRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createImage(createImageRequest, options) {
        return OpenAIApiFp(this.configuration).createImage(createImageRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates an edited or extended image given an original image and a prompt.
     * @param {File} image The image to edit. Must be a valid PNG file, less than 4MB, and square. If mask is not provided, image must have transparency, which will be used as the mask.
     * @param {string} prompt A text description of the desired image(s). The maximum length is 1000 characters.
     * @param {File} [mask] An additional image whose fully transparent areas (e.g. where alpha is zero) indicate where &#x60;image&#x60; should be edited. Must be a valid PNG file, less than 4MB, and have the same dimensions as &#x60;image&#x60;.
     * @param {number} [n] The number of images to generate. Must be between 1 and 10.
     * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
     * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
     * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createImageEdit(image, prompt, mask, n, size, responseFormat, user, options) {
        return OpenAIApiFp(this.configuration).createImageEdit(image, prompt, mask, n, size, responseFormat, user, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Creates a variation of a given image.
     * @param {File} image The image to use as the basis for the variation(s). Must be a valid PNG file, less than 4MB, and square.
     * @param {number} [n] The number of images to generate. Must be between 1 and 10.
     * @param {string} [size] The size of the generated images. Must be one of &#x60;256x256&#x60;, &#x60;512x512&#x60;, or &#x60;1024x1024&#x60;.
     * @param {string} [responseFormat] The format in which the generated images are returned. Must be one of &#x60;url&#x60; or &#x60;b64_json&#x60;.
     * @param {string} [user] A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse. [Learn more](/docs/guides/safety-best-practices/end-user-ids).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createImageVariation(image, n, size, responseFormat, user, options) {
        return OpenAIApiFp(this.configuration).createImageVariation(image, n, size, responseFormat, user, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Classifies if text violates OpenAI\'s Content Policy
     * @param {CreateModerationRequest} createModerationRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createModeration(createModerationRequest, options) {
        return OpenAIApiFp(this.configuration).createModeration(createModerationRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary The search endpoint computes similarity scores between provided query and documents. Documents can be passed directly to the API if there are no more than 200 of them.  To go beyond the 200 document limit, documents can be processed offline and then used for efficient retrieval at query time. When `file` is set, the search endpoint searches over all the documents in the given file and returns up to the `max_rerank` number of documents. These documents will be returned along with their search scores.  The similarity score is a positive score that usually ranges from 0 to 300 (but can sometimes go higher), where a score above 200 usually means the document is semantically similar to the query.
     * @param {string} engineId The ID of the engine to use for this request.  You can select one of &#x60;ada&#x60;, &#x60;babbage&#x60;, &#x60;curie&#x60;, or &#x60;davinci&#x60;.
     * @param {CreateSearchRequest} createSearchRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createSearch(engineId, createSearchRequest, options) {
        return OpenAIApiFp(this.configuration).createSearch(engineId, createSearchRequest, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Transcribes audio into the input language.
     * @param {File} file The audio file object (not file name) to transcribe, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
     * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
     * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
     * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
     * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
     * @param {string} [language] The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createTranscription(file, model, prompt, responseFormat, temperature, language, options) {
        return OpenAIApiFp(this.configuration).createTranscription(file, model, prompt, responseFormat, temperature, language, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Translates audio into into English.
     * @param {File} file The audio file object (not file name) translate, in one of these formats: mp3, mp4, mpeg, mpga, m4a, wav, or webm.
     * @param {string} model ID of the model to use. Only &#x60;whisper-1&#x60; is currently available.
     * @param {string} [prompt] An optional text to guide the model\\\&#39;s style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should be in English.
     * @param {string} [responseFormat] The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
     * @param {number} [temperature] The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ createTranslation(file, model, prompt, responseFormat, temperature, options) {
        return OpenAIApiFp(this.configuration).createTranslation(file, model, prompt, responseFormat, temperature, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Delete a file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ deleteFile(fileId, options) {
        return OpenAIApiFp(this.configuration).deleteFile(fileId, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Delete a fine-tuned model. You must have the Owner role in your organization.
     * @param {string} model The model to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ deleteModel(model, options) {
        return OpenAIApiFp(this.configuration).deleteModel(model, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Returns the contents of the specified file
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ downloadFile(fileId, options) {
        return OpenAIApiFp(this.configuration).downloadFile(fileId, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Lists the currently available (non-finetuned) models, and provides basic information about each one such as the owner and availability.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ listEngines(options) {
        return OpenAIApiFp(this.configuration).listEngines(options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ listFiles(options) {
        return OpenAIApiFp(this.configuration).listFiles(options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Get fine-grained status updates for a fine-tune job.
     * @param {string} fineTuneId The ID of the fine-tune job to get events for.
     * @param {boolean} [stream] Whether to stream events for the fine-tune job. If set to true, events will be sent as data-only [server-sent events](https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format) as they become available. The stream will terminate with a &#x60;data: [DONE]&#x60; message when the job is finished (succeeded, cancelled, or failed).  If set to false, only events generated so far will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ listFineTuneEvents(fineTuneId, stream, options) {
        return OpenAIApiFp(this.configuration).listFineTuneEvents(fineTuneId, stream, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary List your organization\'s fine-tuning jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ listFineTunes(options) {
        return OpenAIApiFp(this.configuration).listFineTunes(options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Lists the currently available models, and provides basic information about each one such as the owner and availability.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ listModels(options) {
        return OpenAIApiFp(this.configuration).listModels(options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Retrieves a model instance, providing basic information about it such as the owner and availability.
     * @param {string} engineId The ID of the engine to use for this request
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ retrieveEngine(engineId, options) {
        return OpenAIApiFp(this.configuration).retrieveEngine(engineId, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Returns information about a specific file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ retrieveFile(fileId, options) {
        return OpenAIApiFp(this.configuration).retrieveFile(fileId, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Gets info about the fine-tune job.  [Learn more about Fine-tuning](/docs/guides/fine-tuning)
     * @param {string} fineTuneId The ID of the fine-tune job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ retrieveFineTune(fineTuneId, options) {
        return OpenAIApiFp(this.configuration).retrieveFineTune(fineTuneId, options).then((request)=>request(this.fetch, this.basePath));
    }
    /**
     *
     * @summary Retrieves a model instance, providing basic information about the model such as the owner and permissioning.
     * @param {string} model The ID of the model to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OpenAIApi
     */ retrieveModel(model, options) {
        return OpenAIApiFp(this.configuration).retrieveModel(model, options).then((request)=>request(this.fetch, this.basePath));
    }
}
// This is a simplified implementation of the `form-data` module:
// https://github.com/form-data/form-data
// It has a `getHeaders` method (with no argument)
function generateBoundary() {
    // This generates a 50 character boundary similar to those used by Firefox.
    // They are optimized for boyer-moore parsing.
    var boundary = "--------------------------";
    for(var i = 0; i < 24; i++){
        boundary += Math.floor(Math.random() * 10).toString(16);
    }
    return boundary;
}
class CustomFormData extends FormData {
    _boundary;
    constructor(...args){
        super(...args);
        this._boundary = generateBoundary();
    }
    getHeaders() {
        var formHeaders = {
            "content-type": "multipart/form-data; boundary=" + this._boundary
        };
        return formHeaders;
    }
}
/* tslint:disable */ class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */ apiKey;
    /**
     * OpenAI organization id
     *
     * @type {string}
     * @memberof Configuration
     */ organization;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */ username;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */ password;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */ accessToken;
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */ basePath;
    /**
     * base options for calls
     *
     * @type {any}
     * @memberof Configuration
     */ baseOptions;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */ defaultQueryParams;
    formDataCtor;
    constructor(param = {}){
        this.apiKey = param.apiKey;
        this.organization = param.organization;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.baseOptions = param.baseOptions;
        this.defaultQueryParams = param.defaultQueryParams;
        this.formDataCtor = param.formDataCtor;
        if (!this.baseOptions) {
            this.baseOptions = {};
        }
        this.baseOptions.headers = {
            // "User-Agent": `OpenAI/NodeJS/${packageJson.version}`,
            Authorization: `Bearer ${this.apiKey}`,
            ...this.baseOptions.headers
        };
        if (this.organization) {
            this.baseOptions.headers["OpenAI-Organization"] = this.organization;
        }
        if (!this.formDataCtor) {
            this.formDataCtor = CustomFormData;
        }
    }
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */ isJsonMime(mime) {
        const jsonMime = new RegExp("^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$", "i");
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === "application/json-patch+json");
    }
}
;
}}),
"[project]/node_modules/turndown/lib/turndown.es.js [app-route] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "default": (()=>__TURBOPACK__default__export__)
});
function extend(destination) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i];
        for(var key in source){
            if (source.hasOwnProperty(key)) destination[key] = source[key];
        }
    }
    return destination;
}
function repeat(character, count) {
    return Array(count + 1).join(character);
}
function trimLeadingNewlines(string) {
    return string.replace(/^\n*/, '');
}
function trimTrailingNewlines(string) {
    // avoid match-at-end regexp bottleneck, see #370
    var indexEnd = string.length;
    while(indexEnd > 0 && string[indexEnd - 1] === '\n')indexEnd--;
    return string.substring(0, indexEnd);
}
var blockElements = [
    'ADDRESS',
    'ARTICLE',
    'ASIDE',
    'AUDIO',
    'BLOCKQUOTE',
    'BODY',
    'CANVAS',
    'CENTER',
    'DD',
    'DIR',
    'DIV',
    'DL',
    'DT',
    'FIELDSET',
    'FIGCAPTION',
    'FIGURE',
    'FOOTER',
    'FORM',
    'FRAMESET',
    'H1',
    'H2',
    'H3',
    'H4',
    'H5',
    'H6',
    'HEADER',
    'HGROUP',
    'HR',
    'HTML',
    'ISINDEX',
    'LI',
    'MAIN',
    'MENU',
    'NAV',
    'NOFRAMES',
    'NOSCRIPT',
    'OL',
    'OUTPUT',
    'P',
    'PRE',
    'SECTION',
    'TABLE',
    'TBODY',
    'TD',
    'TFOOT',
    'TH',
    'THEAD',
    'TR',
    'UL'
];
function isBlock(node) {
    return is(node, blockElements);
}
var voidElements = [
    'AREA',
    'BASE',
    'BR',
    'COL',
    'COMMAND',
    'EMBED',
    'HR',
    'IMG',
    'INPUT',
    'KEYGEN',
    'LINK',
    'META',
    'PARAM',
    'SOURCE',
    'TRACK',
    'WBR'
];
function isVoid(node) {
    return is(node, voidElements);
}
function hasVoid(node) {
    return has(node, voidElements);
}
var meaningfulWhenBlankElements = [
    'A',
    'TABLE',
    'THEAD',
    'TBODY',
    'TFOOT',
    'TH',
    'TD',
    'IFRAME',
    'SCRIPT',
    'AUDIO',
    'VIDEO'
];
function isMeaningfulWhenBlank(node) {
    return is(node, meaningfulWhenBlankElements);
}
function hasMeaningfulWhenBlank(node) {
    return has(node, meaningfulWhenBlankElements);
}
function is(node, tagNames) {
    return tagNames.indexOf(node.nodeName) >= 0;
}
function has(node, tagNames) {
    return node.getElementsByTagName && tagNames.some(function(tagName) {
        return node.getElementsByTagName(tagName).length;
    });
}
var rules = {};
rules.paragraph = {
    filter: 'p',
    replacement: function(content) {
        return '\n\n' + content + '\n\n';
    }
};
rules.lineBreak = {
    filter: 'br',
    replacement: function(content, node, options) {
        return options.br + '\n';
    }
};
rules.heading = {
    filter: [
        'h1',
        'h2',
        'h3',
        'h4',
        'h5',
        'h6'
    ],
    replacement: function(content, node, options) {
        var hLevel = Number(node.nodeName.charAt(1));
        if (options.headingStyle === 'setext' && hLevel < 3) {
            var underline = repeat(hLevel === 1 ? '=' : '-', content.length);
            return '\n\n' + content + '\n' + underline + '\n\n';
        } else {
            return '\n\n' + repeat('#', hLevel) + ' ' + content + '\n\n';
        }
    }
};
rules.blockquote = {
    filter: 'blockquote',
    replacement: function(content) {
        content = content.replace(/^\n+|\n+$/g, '');
        content = content.replace(/^/gm, '> ');
        return '\n\n' + content + '\n\n';
    }
};
rules.list = {
    filter: [
        'ul',
        'ol'
    ],
    replacement: function(content, node) {
        var parent = node.parentNode;
        if (parent.nodeName === 'LI' && parent.lastElementChild === node) {
            return '\n' + content;
        } else {
            return '\n\n' + content + '\n\n';
        }
    }
};
rules.listItem = {
    filter: 'li',
    replacement: function(content, node, options) {
        content = content.replace(/^\n+/, '') // remove leading newlines
        .replace(/\n+$/, '\n') // replace trailing newlines with just a single one
        .replace(/\n/gm, '\n    '); // indent
        var prefix = options.bulletListMarker + '   ';
        var parent = node.parentNode;
        if (parent.nodeName === 'OL') {
            var start = parent.getAttribute('start');
            var index = Array.prototype.indexOf.call(parent.children, node);
            prefix = (start ? Number(start) + index : index + 1) + '.  ';
        }
        return prefix + content + (node.nextSibling && !/\n$/.test(content) ? '\n' : '');
    }
};
rules.indentedCodeBlock = {
    filter: function(node, options) {
        return options.codeBlockStyle === 'indented' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';
    },
    replacement: function(content, node, options) {
        return '\n\n    ' + node.firstChild.textContent.replace(/\n/g, '\n    ') + '\n\n';
    }
};
rules.fencedCodeBlock = {
    filter: function(node, options) {
        return options.codeBlockStyle === 'fenced' && node.nodeName === 'PRE' && node.firstChild && node.firstChild.nodeName === 'CODE';
    },
    replacement: function(content, node, options) {
        var className = node.firstChild.getAttribute('class') || '';
        var language = (className.match(/language-(\S+)/) || [
            null,
            ''
        ])[1];
        var code = node.firstChild.textContent;
        var fenceChar = options.fence.charAt(0);
        var fenceSize = 3;
        var fenceInCodeRegex = new RegExp('^' + fenceChar + '{3,}', 'gm');
        var match;
        while(match = fenceInCodeRegex.exec(code)){
            if (match[0].length >= fenceSize) {
                fenceSize = match[0].length + 1;
            }
        }
        var fence = repeat(fenceChar, fenceSize);
        return '\n\n' + fence + language + '\n' + code.replace(/\n$/, '') + '\n' + fence + '\n\n';
    }
};
rules.horizontalRule = {
    filter: 'hr',
    replacement: function(content, node, options) {
        return '\n\n' + options.hr + '\n\n';
    }
};
rules.inlineLink = {
    filter: function(node, options) {
        return options.linkStyle === 'inlined' && node.nodeName === 'A' && node.getAttribute('href');
    },
    replacement: function(content, node) {
        var href = node.getAttribute('href');
        if (href) href = href.replace(/([()])/g, '\\$1');
        var title = cleanAttribute(node.getAttribute('title'));
        if (title) title = ' "' + title.replace(/"/g, '\\"') + '"';
        return '[' + content + '](' + href + title + ')';
    }
};
rules.referenceLink = {
    filter: function(node, options) {
        return options.linkStyle === 'referenced' && node.nodeName === 'A' && node.getAttribute('href');
    },
    replacement: function(content, node, options) {
        var href = node.getAttribute('href');
        var title = cleanAttribute(node.getAttribute('title'));
        if (title) title = ' "' + title + '"';
        var replacement;
        var reference;
        switch(options.linkReferenceStyle){
            case 'collapsed':
                replacement = '[' + content + '][]';
                reference = '[' + content + ']: ' + href + title;
                break;
            case 'shortcut':
                replacement = '[' + content + ']';
                reference = '[' + content + ']: ' + href + title;
                break;
            default:
                var id = this.references.length + 1;
                replacement = '[' + content + '][' + id + ']';
                reference = '[' + id + ']: ' + href + title;
        }
        this.references.push(reference);
        return replacement;
    },
    references: [],
    append: function(options) {
        var references = '';
        if (this.references.length) {
            references = '\n\n' + this.references.join('\n') + '\n\n';
            this.references = []; // Reset references
        }
        return references;
    }
};
rules.emphasis = {
    filter: [
        'em',
        'i'
    ],
    replacement: function(content, node, options) {
        if (!content.trim()) return '';
        return options.emDelimiter + content + options.emDelimiter;
    }
};
rules.strong = {
    filter: [
        'strong',
        'b'
    ],
    replacement: function(content, node, options) {
        if (!content.trim()) return '';
        return options.strongDelimiter + content + options.strongDelimiter;
    }
};
rules.code = {
    filter: function(node) {
        var hasSiblings = node.previousSibling || node.nextSibling;
        var isCodeBlock = node.parentNode.nodeName === 'PRE' && !hasSiblings;
        return node.nodeName === 'CODE' && !isCodeBlock;
    },
    replacement: function(content) {
        if (!content) return '';
        content = content.replace(/\r?\n|\r/g, ' ');
        var extraSpace = /^`|^ .*?[^ ].* $|`$/.test(content) ? ' ' : '';
        var delimiter = '`';
        var matches = content.match(/`+/gm) || [];
        while(matches.indexOf(delimiter) !== -1)delimiter = delimiter + '`';
        return delimiter + extraSpace + content + extraSpace + delimiter;
    }
};
rules.image = {
    filter: 'img',
    replacement: function(content, node) {
        var alt = cleanAttribute(node.getAttribute('alt'));
        var src = node.getAttribute('src') || '';
        var title = cleanAttribute(node.getAttribute('title'));
        var titlePart = title ? ' "' + title + '"' : '';
        return src ? '![' + alt + ']' + '(' + src + titlePart + ')' : '';
    }
};
function cleanAttribute(attribute) {
    return attribute ? attribute.replace(/(\n+\s*)+/g, '\n') : '';
}
/**
 * Manages a collection of rules used to convert HTML to Markdown
 */ function Rules(options) {
    this.options = options;
    this._keep = [];
    this._remove = [];
    this.blankRule = {
        replacement: options.blankReplacement
    };
    this.keepReplacement = options.keepReplacement;
    this.defaultRule = {
        replacement: options.defaultReplacement
    };
    this.array = [];
    for(var key in options.rules)this.array.push(options.rules[key]);
}
Rules.prototype = {
    add: function(key, rule) {
        this.array.unshift(rule);
    },
    keep: function(filter) {
        this._keep.unshift({
            filter: filter,
            replacement: this.keepReplacement
        });
    },
    remove: function(filter) {
        this._remove.unshift({
            filter: filter,
            replacement: function() {
                return '';
            }
        });
    },
    forNode: function(node) {
        if (node.isBlank) return this.blankRule;
        var rule;
        if (rule = findRule(this.array, node, this.options)) return rule;
        if (rule = findRule(this._keep, node, this.options)) return rule;
        if (rule = findRule(this._remove, node, this.options)) return rule;
        return this.defaultRule;
    },
    forEach: function(fn) {
        for(var i = 0; i < this.array.length; i++)fn(this.array[i], i);
    }
};
function findRule(rules, node, options) {
    for(var i = 0; i < rules.length; i++){
        var rule = rules[i];
        if (filterValue(rule, node, options)) return rule;
    }
    return void 0;
}
function filterValue(rule, node, options) {
    var filter = rule.filter;
    if (typeof filter === 'string') {
        if (filter === node.nodeName.toLowerCase()) return true;
    } else if (Array.isArray(filter)) {
        if (filter.indexOf(node.nodeName.toLowerCase()) > -1) return true;
    } else if (typeof filter === 'function') {
        if (filter.call(rule, node, options)) return true;
    } else {
        throw new TypeError('`filter` needs to be a string, array, or function');
    }
}
/**
 * The collapseWhitespace function is adapted from collapse-whitespace
 * by Luc Thevenard.
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2014 Luc Thevenard <lucthevenard@gmail.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */ /**
 * collapseWhitespace(options) removes extraneous whitespace from an the given element.
 *
 * @param {Object} options
 */ function collapseWhitespace(options) {
    var element = options.element;
    var isBlock = options.isBlock;
    var isVoid = options.isVoid;
    var isPre = options.isPre || function(node) {
        return node.nodeName === 'PRE';
    };
    if (!element.firstChild || isPre(element)) return;
    var prevText = null;
    var keepLeadingWs = false;
    var prev = null;
    var node = next(prev, element, isPre);
    while(node !== element){
        if (node.nodeType === 3 || node.nodeType === 4) {
            var text = node.data.replace(/[ \r\n\t]+/g, ' ');
            if ((!prevText || / $/.test(prevText.data)) && !keepLeadingWs && text[0] === ' ') {
                text = text.substr(1);
            }
            // `text` might be empty at this point.
            if (!text) {
                node = remove(node);
                continue;
            }
            node.data = text;
            prevText = node;
        } else if (node.nodeType === 1) {
            if (isBlock(node) || node.nodeName === 'BR') {
                if (prevText) {
                    prevText.data = prevText.data.replace(/ $/, '');
                }
                prevText = null;
                keepLeadingWs = false;
            } else if (isVoid(node) || isPre(node)) {
                // Avoid trimming space around non-block, non-BR void elements and inline PRE.
                prevText = null;
                keepLeadingWs = true;
            } else if (prevText) {
                // Drop protection if set previously.
                keepLeadingWs = false;
            }
        } else {
            node = remove(node);
            continue;
        }
        var nextNode = next(prev, node, isPre);
        prev = node;
        node = nextNode;
    }
    if (prevText) {
        prevText.data = prevText.data.replace(/ $/, '');
        if (!prevText.data) {
            remove(prevText);
        }
    }
}
/**
 * remove(node) removes the given node from the DOM and returns the
 * next node in the sequence.
 *
 * @param {Node} node
 * @return {Node} node
 */ function remove(node) {
    var next = node.nextSibling || node.parentNode;
    node.parentNode.removeChild(node);
    return next;
}
/**
 * next(prev, current, isPre) returns the next node in the sequence, given the
 * current and previous nodes.
 *
 * @param {Node} prev
 * @param {Node} current
 * @param {Function} isPre
 * @return {Node}
 */ function next(prev, current, isPre) {
    if (prev && prev.parentNode === current || isPre(current)) {
        return current.nextSibling || current.parentNode;
    }
    return current.firstChild || current.nextSibling || current.parentNode;
}
/*
 * Set up window for Node.js
 */ var root = ("TURBOPACK compile-time falsy", 0) ? ("TURBOPACK unreachable", undefined) : {};
/*
 * Parsing HTML strings
 */ function canParseHTMLNatively() {
    var Parser = root.DOMParser;
    var canParse = false;
    // Adapted from https://gist.github.com/1129031
    // Firefox/Opera/IE throw errors on unsupported types
    try {
        // WebKit returns null on unsupported types
        if (new Parser().parseFromString('', 'text/html')) {
            canParse = true;
        }
    } catch (e) {}
    return canParse;
}
function createHTMLParser() {
    var Parser = function() {};
    {
        var domino = __turbopack_context__.r("[project]/node_modules/@mixmark-io/domino/lib/index.js [app-route] (ecmascript)");
        Parser.prototype.parseFromString = function(string) {
            return domino.createDocument(string);
        };
    }
    return Parser;
}
var HTMLParser = canParseHTMLNatively() ? root.DOMParser : createHTMLParser();
function RootNode(input, options) {
    var root;
    if (typeof input === 'string') {
        var doc = htmlParser().parseFromString(// DOM parsers arrange elements in the <head> and <body>.
        // Wrapping in a custom element ensures elements are reliably arranged in
        // a single element.
        '<x-turndown id="turndown-root">' + input + '</x-turndown>', 'text/html');
        root = doc.getElementById('turndown-root');
    } else {
        root = input.cloneNode(true);
    }
    collapseWhitespace({
        element: root,
        isBlock: isBlock,
        isVoid: isVoid,
        isPre: options.preformattedCode ? isPreOrCode : null
    });
    return root;
}
var _htmlParser;
function htmlParser() {
    _htmlParser = _htmlParser || new HTMLParser();
    return _htmlParser;
}
function isPreOrCode(node) {
    return node.nodeName === 'PRE' || node.nodeName === 'CODE';
}
function Node(node, options) {
    node.isBlock = isBlock(node);
    node.isCode = node.nodeName === 'CODE' || node.parentNode.isCode;
    node.isBlank = isBlank(node);
    node.flankingWhitespace = flankingWhitespace(node, options);
    return node;
}
function isBlank(node) {
    return !isVoid(node) && !isMeaningfulWhenBlank(node) && /^\s*$/i.test(node.textContent) && !hasVoid(node) && !hasMeaningfulWhenBlank(node);
}
function flankingWhitespace(node, options) {
    if (node.isBlock || options.preformattedCode && node.isCode) {
        return {
            leading: '',
            trailing: ''
        };
    }
    var edges = edgeWhitespace(node.textContent);
    // abandon leading ASCII WS if left-flanked by ASCII WS
    if (edges.leadingAscii && isFlankedByWhitespace('left', node, options)) {
        edges.leading = edges.leadingNonAscii;
    }
    // abandon trailing ASCII WS if right-flanked by ASCII WS
    if (edges.trailingAscii && isFlankedByWhitespace('right', node, options)) {
        edges.trailing = edges.trailingNonAscii;
    }
    return {
        leading: edges.leading,
        trailing: edges.trailing
    };
}
function edgeWhitespace(string) {
    var m = string.match(/^(([ \t\r\n]*)(\s*))(?:(?=\S)[\s\S]*\S)?((\s*?)([ \t\r\n]*))$/);
    return {
        leading: m[1],
        leadingAscii: m[2],
        leadingNonAscii: m[3],
        trailing: m[4],
        trailingNonAscii: m[5],
        trailingAscii: m[6]
    };
}
function isFlankedByWhitespace(side, node, options) {
    var sibling;
    var regExp;
    var isFlanked;
    if (side === 'left') {
        sibling = node.previousSibling;
        regExp = / $/;
    } else {
        sibling = node.nextSibling;
        regExp = /^ /;
    }
    if (sibling) {
        if (sibling.nodeType === 3) {
            isFlanked = regExp.test(sibling.nodeValue);
        } else if (options.preformattedCode && sibling.nodeName === 'CODE') {
            isFlanked = false;
        } else if (sibling.nodeType === 1 && !isBlock(sibling)) {
            isFlanked = regExp.test(sibling.textContent);
        }
    }
    return isFlanked;
}
var reduce = Array.prototype.reduce;
var escapes = [
    [
        /\\/g,
        '\\\\'
    ],
    [
        /\*/g,
        '\\*'
    ],
    [
        /^-/g,
        '\\-'
    ],
    [
        /^\+ /g,
        '\\+ '
    ],
    [
        /^(=+)/g,
        '\\$1'
    ],
    [
        /^(#{1,6}) /g,
        '\\$1 '
    ],
    [
        /`/g,
        '\\`'
    ],
    [
        /^~~~/g,
        '\\~~~'
    ],
    [
        /\[/g,
        '\\['
    ],
    [
        /\]/g,
        '\\]'
    ],
    [
        /^>/g,
        '\\>'
    ],
    [
        /_/g,
        '\\_'
    ],
    [
        /^(\d+)\. /g,
        '$1\\. '
    ]
];
function TurndownService(options) {
    if (!(this instanceof TurndownService)) return new TurndownService(options);
    var defaults = {
        rules: rules,
        headingStyle: 'setext',
        hr: '* * *',
        bulletListMarker: '*',
        codeBlockStyle: 'indented',
        fence: '```',
        emDelimiter: '_',
        strongDelimiter: '**',
        linkStyle: 'inlined',
        linkReferenceStyle: 'full',
        br: '  ',
        preformattedCode: false,
        blankReplacement: function(content, node) {
            return node.isBlock ? '\n\n' : '';
        },
        keepReplacement: function(content, node) {
            return node.isBlock ? '\n\n' + node.outerHTML + '\n\n' : node.outerHTML;
        },
        defaultReplacement: function(content, node) {
            return node.isBlock ? '\n\n' + content + '\n\n' : content;
        }
    };
    this.options = extend({}, defaults, options);
    this.rules = new Rules(this.options);
}
TurndownService.prototype = {
    /**
   * The entry point for converting a string or DOM node to Markdown
   * @public
   * @param {String|HTMLElement} input The string or DOM node to convert
   * @returns A Markdown representation of the input
   * @type String
   */ turndown: function(input) {
        if (!canConvert(input)) {
            throw new TypeError(input + ' is not a string, or an element/document/fragment node.');
        }
        if (input === '') return '';
        var output = process.call(this, new RootNode(input, this.options));
        return postProcess.call(this, output);
    },
    /**
   * Add one or more plugins
   * @public
   * @param {Function|Array} plugin The plugin or array of plugins to add
   * @returns The Turndown instance for chaining
   * @type Object
   */ use: function(plugin) {
        if (Array.isArray(plugin)) {
            for(var i = 0; i < plugin.length; i++)this.use(plugin[i]);
        } else if (typeof plugin === 'function') {
            plugin(this);
        } else {
            throw new TypeError('plugin must be a Function or an Array of Functions');
        }
        return this;
    },
    /**
   * Adds a rule
   * @public
   * @param {String} key The unique key of the rule
   * @param {Object} rule The rule
   * @returns The Turndown instance for chaining
   * @type Object
   */ addRule: function(key, rule) {
        this.rules.add(key, rule);
        return this;
    },
    /**
   * Keep a node (as HTML) that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */ keep: function(filter) {
        this.rules.keep(filter);
        return this;
    },
    /**
   * Remove a node that matches the filter
   * @public
   * @param {String|Array|Function} filter The unique key of the rule
   * @returns The Turndown instance for chaining
   * @type Object
   */ remove: function(filter) {
        this.rules.remove(filter);
        return this;
    },
    /**
   * Escapes Markdown syntax
   * @public
   * @param {String} string The string to escape
   * @returns A string with Markdown syntax escaped
   * @type String
   */ escape: function(string) {
        return escapes.reduce(function(accumulator, escape) {
            return accumulator.replace(escape[0], escape[1]);
        }, string);
    }
};
/**
 * Reduces a DOM node down to its Markdown string equivalent
 * @private
 * @param {HTMLElement} parentNode The node to convert
 * @returns A Markdown representation of the node
 * @type String
 */ function process(parentNode) {
    var self = this;
    return reduce.call(parentNode.childNodes, function(output, node) {
        node = new Node(node, self.options);
        var replacement = '';
        if (node.nodeType === 3) {
            replacement = node.isCode ? node.nodeValue : self.escape(node.nodeValue);
        } else if (node.nodeType === 1) {
            replacement = replacementForNode.call(self, node);
        }
        return join(output, replacement);
    }, '');
}
/**
 * Appends strings as each rule requires and trims the output
 * @private
 * @param {String} output The conversion output
 * @returns A trimmed version of the ouput
 * @type String
 */ function postProcess(output) {
    var self = this;
    this.rules.forEach(function(rule) {
        if (typeof rule.append === 'function') {
            output = join(output, rule.append(self.options));
        }
    });
    return output.replace(/^[\t\r\n]+/, '').replace(/[\t\r\n\s]+$/, '');
}
/**
 * Converts an element node to its Markdown equivalent
 * @private
 * @param {HTMLElement} node The node to convert
 * @returns A Markdown representation of the node
 * @type String
 */ function replacementForNode(node) {
    var rule = this.rules.forNode(node);
    var content = process.call(this, node);
    var whitespace = node.flankingWhitespace;
    if (whitespace.leading || whitespace.trailing) content = content.trim();
    return whitespace.leading + rule.replacement(content, node, this.options) + whitespace.trailing;
}
/**
 * Joins replacement to the current output with appropriate number of new lines
 * @private
 * @param {String} output The current conversion output
 * @param {String} replacement The string to append to the output
 * @returns Joined output
 * @type String
 */ function join(output, replacement) {
    var s1 = trimTrailingNewlines(output);
    var s2 = trimLeadingNewlines(replacement);
    var nls = Math.max(output.length - s1.length, replacement.length - s2.length);
    var separator = '\n\n'.substring(0, nls);
    return s1 + separator + s2;
}
/**
 * Determines whether an input can be converted
 * @private
 * @param {String|HTMLElement} input Describe this parameter
 * @returns Describe what it returns
 * @type String|Object|Array|Boolean|Number
 */ function canConvert(input) {
    return input != null && (typeof input === 'string' || input.nodeType && (input.nodeType === 1 || input.nodeType === 9 || input.nodeType === 11));
}
const __TURBOPACK__default__export__ = TurndownService;
}}),

};

//# sourceMappingURL=node_modules_1e699587._.js.map