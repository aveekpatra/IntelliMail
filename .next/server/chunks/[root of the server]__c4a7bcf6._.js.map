{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 62, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/env.js"],"sourcesContent":["import { createEnv } from \"@t3-oss/env-nextjs\";\nimport { z } from \"zod\";\n\nexport const env = createEnv({\n  /**\n   * Specify your server-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars.\n   */\n  server: {\n    DATABASE_URL: z.string().url(),\n    NODE_ENV: z\n      .enum([\"development\", \"test\", \"production\"])\n      .default(\"development\"),\n  },\n\n  /**\n   * Specify your client-side environment variables schema here. This way you can ensure the app\n   * isn't built with invalid env vars. To expose them to the client, prefix them with\n   * `NEXT_PUBLIC_`.\n   */\n  client: {\n    // NEXT_PUBLIC_CLIENTVAR: z.string(),\n  },\n\n  /**\n   * You can't destruct `process.env` as a regular object in the Next.js edge runtimes (e.g.\n   * middlewares) or client-side so we need to destruct manually.\n   */\n  runtimeEnv: {\n    DATABASE_URL: process.env.DATABASE_URL,\n    NODE_ENV: process.env.NODE_ENV,\n    // NEXT_PUBLIC_CLIENTVAR: process.env.NEXT_PUBLIC_CLIENTVAR,\n  },\n  /**\n   * Run `build` or `dev` with `SKIP_ENV_VALIDATION` to skip env validation. This is especially\n   * useful for Docker builds.\n   */\n  skipValidation: !!process.env.SKIP_ENV_VALIDATION,\n  /**\n   * Makes it so that empty strings are treated as undefined. `SOME_VAR: z.string()` and\n   * `SOME_VAR=''` will throw an error.\n   */\n  emptyStringAsUndefined: true,\n});\n"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,MAAM,MAAM,CAAA,GAAA,+JAAA,CAAA,YAAS,AAAD,EAAE;IAC3B;;;GAGC,GACD,QAAQ;QACN,cAAc,sIAAA,CAAA,IAAC,CAAC,MAAM,GAAG,GAAG;QAC5B,UAAU,sIAAA,CAAA,IAAC,CACR,IAAI,CAAC;YAAC;YAAe;YAAQ;SAAa,EAC1C,OAAO,CAAC;IACb;IAEA;;;;GAIC,GACD,QAAQ;IAER;IAEA;;;GAGC,GACD,YAAY;QACV,cAAc,QAAQ,GAAG,CAAC,YAAY;QACtC,QAAQ;IAEV;IACA;;;GAGC,GACD,gBAAgB,CAAC,CAAC,QAAQ,GAAG,CAAC,mBAAmB;IACjD;;;GAGC,GACD,wBAAwB;AAC1B","debugId":null}},
    {"offset": {"line": 109, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/server/db.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nimport { env } from \"@/env\";\n\nconst createPrismaClient = () =>\n  new PrismaClient({\n    log:\n      env.NODE_ENV === \"development\" ? [\"error\", \"warn\"] : [\"error\"],\n  });\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: ReturnType<typeof createPrismaClient> | undefined;\n};\n\nexport const db = globalForPrisma.prisma ?? createPrismaClient();\n\nif (env.NODE_ENV !== \"production\") globalForPrisma.prisma = db;\n"],"names":[],"mappings":";;;AAAA;AAEA;;;AAEA,MAAM,qBAAqB,IACzB,IAAI,6HAAA,CAAA,eAAY,CAAC;QACf,KACE,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,gBAAgB;YAAC;YAAS;SAAO,GAAG;YAAC;SAAQ;IAClE;AAEF,MAAM,kBAAkB;AAIjB,MAAM,KAAK,gBAAgB,MAAM,IAAI;AAE5C,IAAI,4GAAA,CAAA,MAAG,CAAC,QAAQ,KAAK,cAAc,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 349, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/stripe.ts"],"sourcesContent":["'server-only'\nimport Stripe from 'stripe'\n\nexport const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n    apiVersion: '2024-06-20',\n})\n\n"],"names":[],"mappings":";;;AACA;AADA;;AAGO,MAAM,SAAS,IAAI,wJAAA,CAAA,UAAM,CAAC,QAAQ,GAAG,CAAC,iBAAiB,EAAG;IAC7D,YAAY;AAChB","debugId":null}},
    {"offset": {"line": 364, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/stripe-actions.ts"],"sourcesContent":["'use server'\n\nimport { auth } from \"@clerk/nextjs/server\";\nimport { stripe } from \"./stripe\";\nimport { redirect } from \"next/navigation\";\nimport { db } from \"@/server/db\";\n\nexport async function createCheckoutSession() {\n    const { userId } = await auth();\n\n    if (!userId) {\n        throw new Error('User not found');\n    }\n\n    const session = await stripe.checkout.sessions.create({\n        payment_method_types: ['card'],\n        line_items: [\n            {\n                price: process.env.STRIPE_PRICE_ID,\n                quantity: 1,\n            },\n        ],\n        mode: 'subscription',\n        success_url: `${process.env.NEXT_PUBLIC_URL}/mail`,\n        cancel_url: `${process.env.NEXT_PUBLIC_URL}/pricing`,\n        client_reference_id: userId.toString(),\n    });\n\n    redirect(session.url!);\n}\n\nexport async function createBillingPortalSession() {\n    const { userId } = await auth();\n    if (!userId) {\n        return false\n    }\n    const subscription = await db.stripeSubscription.findUnique({\n        where: { userId: userId },\n    });\n    if (!subscription?.customerId) {\n        throw new Error('Subscription not found');\n    }\n    const session = await stripe.billingPortal.sessions.create({\n        customer: subscription.customerId,\n        return_url: `${process.env.NEXT_PUBLIC_URL}/pricing`,\n    });\n    redirect(session.url!)\n}\n\nexport async function getSubscriptionStatus() {\n    const { userId } = await auth();\n    if (!userId) {\n        return false\n    }\n    const subscription = await db.stripeSubscription.findUnique({\n        where: { userId: userId },\n    });\n    if (!subscription) {\n        return false;\n    }\n    return subscription.currentPeriodEnd > new Date();\n}\n\n"],"names":[],"mappings":";;;;;;;AAEA;AACA;AACA;AAAA;AACA;;;;;;;;AAEO,eAAe,uCAAmB,GAAnB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAE5B,IAAI,CAAC,QAAQ;QACT,MAAM,IAAI,MAAM;IACpB;IAEA,MAAM,UAAU,MAAM,sHAAA,CAAA,SAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;QAClD,sBAAsB;YAAC;SAAO;QAC9B,YAAY;YACR;gBACI,OAAO,QAAQ,GAAG,CAAC,eAAe;gBAClC,UAAU;YACd;SACH;QACD,MAAM;QACN,aAAa,6DAA+B,KAAK,CAAC;QAClD,YAAY,6DAA+B,QAAQ,CAAC;QACpD,qBAAqB,OAAO,QAAQ;IACxC;IAEA,CAAA,GAAA,uLAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG;AACxB;AAEO,eAAe,uCAAwB,GAAxB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAC5B,IAAI,CAAC,QAAQ;QACT,OAAO;IACX;IACA,MAAM,eAAe,MAAM,qHAAA,CAAA,KAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC;QACxD,OAAO;YAAE,QAAQ;QAAO;IAC5B;IACA,IAAI,CAAC,cAAc,YAAY;QAC3B,MAAM,IAAI,MAAM;IACpB;IACA,MAAM,UAAU,MAAM,sHAAA,CAAA,SAAM,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM,CAAC;QACvD,UAAU,aAAa,UAAU;QACjC,YAAY,6DAA+B,QAAQ,CAAC;IACxD;IACA,CAAA,GAAA,uLAAA,CAAA,WAAQ,AAAD,EAAE,QAAQ,GAAG;AACxB;AAEO,eAAe,uCAAmB,GAAnB;IAClB,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM,CAAA,GAAA,qLAAA,CAAA,OAAI,AAAD;IAC5B,IAAI,CAAC,QAAQ;QACT,OAAO;IACX;IACA,MAAM,eAAe,MAAM,qHAAA,CAAA,KAAE,CAAC,kBAAkB,CAAC,UAAU,CAAC;QACxD,OAAO;YAAE,QAAQ;QAAO;IAC5B;IACA,IAAI,CAAC,cAAc;QACf,OAAO;IACX;IACA,OAAO,aAAa,gBAAgB,GAAG,IAAI;AAC/C;;;IAtDsB;IAwBA;IAkBA;;AA1CA,iPAAA;AAwBA,iPAAA;AAkBA,iPAAA","debugId":null}},
    {"offset": {"line": 454, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/app/constants.ts"],"sourcesContent":["export const FREE_CREDITS_PER_DAY = 15\nexport const FREE_ACCOUNTS_PER_USER = 1\nexport const PRO_ACCOUNTS_PER_USER = 3"],"names":[],"mappings":";;;;;AAAO,MAAM,uBAAuB;AAC7B,MAAM,yBAAyB;AAC/B,MAAM,wBAAwB","debugId":null}},
    {"offset": {"line": 468, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/lib/gmail.ts"],"sourcesContent":["\"use server\";\n\nimport { google } from \"googleapis\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { getSubscriptionStatus } from \"./stripe-actions\";\nimport { db } from \"@/server/db\";\nimport { FREE_ACCOUNTS_PER_USER, PRO_ACCOUNTS_PER_USER } from \"@/app/constants\";\n\n// Create OAuth2 client\nfunction getOAuth2Client() {\n  console.log(\"Creating OAuth2 client with credentials...\");\n  return new google.auth.OAuth2(\n    process.env.GOOGLE_CLIENT_ID,\n    process.env.GOOGLE_CLIENT_SECRET,\n    `${process.env.NEXT_PUBLIC_URL}/api/auth/callback/gmail`,\n  );\n}\n\n/**\n * Generate the authorization URL for Gmail OAuth\n */\nexport const getGmailAuthUrl = async () => {\n  try {\n    console.log(\"Starting Gmail auth URL generation...\");\n    const { userId } = await auth();\n    if (!userId) {\n      console.error(\"No user ID found in auth\");\n      throw new Error(\"User not found\");\n    }\n    console.log(\"Got user ID:\", userId);\n\n    const user = await db.user.upsert({\n      where: { id: userId },\n      update: {},\n      create: {\n        id: userId,\n        emailAddress: \"temp@example.com\", // This will be updated by the webhook\n        role: \"user\",\n      },\n    });\n    console.log(\"User record created/updated:\", user);\n\n    // Check subscription limits\n    console.log(\"Checking subscription limits...\");\n    const isSubscribed = await getSubscriptionStatus();\n    console.log(\"Subscription status:\", isSubscribed);\n\n    const accounts = await db.account.count({\n      where: { userId },\n    });\n    console.log(\"Current account count:\", accounts);\n    console.log(\n      \"Account limit:\",\n      isSubscribed ? PRO_ACCOUNTS_PER_USER : FREE_ACCOUNTS_PER_USER,\n    );\n\n    // Temporarily disabled account limits\n    /*\n    if (user.role === \"user\") {\n      if (isSubscribed) {\n        if (accounts >= PRO_ACCOUNTS_PER_USER) {\n          console.error(\"User has reached maximum accounts for subscription\", {\n            currentAccounts: accounts,\n            maxAccounts: PRO_ACCOUNTS_PER_USER,\n            isSubscribed: true,\n          });\n          throw new Error(\n            \"You have reached the maximum number of accounts for your subscription\",\n          );\n        }\n      } else {\n        if (accounts >= FREE_ACCOUNTS_PER_USER) {\n          console.error(\"User has reached maximum free accounts\", {\n            currentAccounts: accounts,\n            maxAccounts: FREE_ACCOUNTS_PER_USER,\n            isSubscribed: false,\n          });\n          throw new Error(\n            \"You have reached the maximum number of accounts for your subscription\",\n          );\n        }\n      }\n    }\n    */\n\n    console.log(\"Creating OAuth2 client...\");\n    const oauth2Client = getOAuth2Client();\n    const scopes = [\n      \"https://www.googleapis.com/auth/gmail.readonly\",\n      \"https://www.googleapis.com/auth/gmail.send\",\n      \"https://www.googleapis.com/auth/gmail.compose\",\n      \"https://www.googleapis.com/auth/gmail.modify\",\n      \"https://www.googleapis.com/auth/userinfo.email\",\n      \"https://www.googleapis.com/auth/userinfo.profile\",\n    ];\n    console.log(\"Using scopes:\", scopes);\n\n    console.log(\"Generating auth URL with state:\", userId);\n    const authUrl = oauth2Client.generateAuthUrl({\n      access_type: \"offline\",\n      scope: scopes,\n      prompt: \"consent\",\n      state: userId,\n      include_granted_scopes: true,\n    });\n    console.log(\"Auth URL generated successfully:\", authUrl);\n\n    return authUrl;\n  } catch (error) {\n    console.error(\"Error in getGmailAuthUrl:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Exchange authorization code for tokens\n */\nexport const getGmailTokens = async (code: string) => {\n  try {\n    console.log(\"Starting token exchange process...\");\n    console.log(\"Creating OAuth2 client for token exchange...\");\n    const oauth2Client = getOAuth2Client();\n\n    console.log(\"Exchanging code for tokens...\");\n    const { tokens } = await oauth2Client.getToken(code);\n\n    console.log(\"Token exchange successful\");\n    if (!tokens.access_token) {\n      console.error(\"No access token received\");\n      throw new Error(\"Failed to get access token\");\n    }\n\n    console.log(\"Tokens received:\", {\n      accessTokenExists: !!tokens.access_token,\n      refreshTokenExists: !!tokens.refresh_token,\n      expiryDate: tokens.expiry_date,\n    });\n\n    return {\n      accessToken: tokens.access_token,\n      refreshToken: tokens.refresh_token,\n      expiryDate: tokens.expiry_date,\n    };\n  } catch (error) {\n    console.error(\"Error in getGmailTokens:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Get Gmail user information\n */\nexport const getGmailUserInfo = async (accessToken: string) => {\n  try {\n    console.log(\"Starting user info fetch process...\");\n    console.log(\"Setting up OAuth2 client with access token...\");\n    const oauth2Client = getOAuth2Client();\n    oauth2Client.setCredentials({ access_token: accessToken });\n\n    console.log(\"Creating People API client...\");\n    const peopleApi = google.people({ version: \"v1\", auth: oauth2Client });\n\n    console.log(\"Fetching user profile...\");\n    const profile = await peopleApi.people.get({\n      resourceName: \"people/me\",\n      personFields: \"emailAddresses,names\",\n    });\n\n    console.log(\"User profile fetched successfully\");\n    const userInfo = {\n      email: profile.data.emailAddresses?.[0]?.value || \"\",\n      name: profile.data.names?.[0]?.displayName || \"\",\n    };\n    console.log(\"User info:\", userInfo);\n\n    return userInfo;\n  } catch (error) {\n    console.error(\"Error in getGmailUserInfo:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Create a Gmail account for syncing emails\n */\nexport async function createGmailAccount(\n  accessToken: string,\n  refreshToken: string | null | undefined,\n) {\n  try {\n    console.log(\"Creating Gmail account with tokens...\");\n    console.log(\"Token info:\", {\n      accessTokenExists: !!accessToken,\n      refreshTokenExists: !!refreshToken,\n    });\n\n    // Implementation for syncing emails and sending\n    const gmailAccount = {\n      accessToken,\n      refreshToken,\n\n      async syncEmails() {\n        console.log(\"Starting email sync process...\");\n        // Implement email syncing logic here\n        return { success: true, count: 0 };\n      },\n\n      async sendEmail(options: { to: string; subject: string; body: string }) {\n        console.log(\"Sending email:\", options);\n        const oauth2Client = getOAuth2Client();\n        oauth2Client.setCredentials({ access_token: accessToken });\n\n        const gmail = google.gmail({ version: \"v1\", auth: oauth2Client });\n\n        // Format the email according to Gmail API requirements\n        const message = [\n          `To: ${options.to}`,\n          `Subject: ${options.subject}`,\n          \"Content-Type: text/html; charset=utf-8\",\n          \"\",\n          options.body,\n        ].join(\"\\n\");\n\n        const encodedMessage = Buffer.from(message)\n          .toString(\"base64\")\n          .replace(/\\+/g, \"-\")\n          .replace(/\\//g, \"_\")\n          .replace(/=+$/, \"\");\n\n        console.log(\"Sending email via Gmail API...\");\n        await gmail.users.messages.send({\n          userId: \"me\",\n          requestBody: {\n            raw: encodedMessage,\n          },\n        });\n\n        console.log(\"Email sent successfully\");\n        return { success: true };\n      },\n    };\n\n    console.log(\"Gmail account created successfully\");\n    return gmailAccount;\n  } catch (error) {\n    console.error(\"Error in createGmailAccount:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n}\n\n/**\n * Refresh the Gmail access token using the refresh token\n */\nexport const refreshGmailToken = async (refreshToken: string) => {\n  try {\n    console.log(\"Starting token refresh process...\");\n    const oauth2Client = getOAuth2Client();\n\n    console.log(\"Setting refresh token...\");\n    oauth2Client.setCredentials({\n      refresh_token: refreshToken,\n    });\n\n    console.log(\"Refreshing access token...\");\n    const { credentials } = await oauth2Client.refreshAccessToken();\n\n    console.log(\"Access token refreshed successfully\");\n    return {\n      accessToken: credentials.access_token,\n      expiryDate: credentials.expiry_date,\n    };\n  } catch (error) {\n    console.error(\"Error refreshing Gmail token:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Fetch Gmail emails directly from Gmail API\n */\nexport const fetchGmailEmails = async (\n  accessToken: string,\n  maxResults = 20,\n  refreshToken?: string | null,\n) => {\n  try {\n    console.log(\"Starting Gmail email fetch process...\");\n    console.log(\"Setting up OAuth2 client with access token...\");\n    const oauth2Client = getOAuth2Client();\n    oauth2Client.setCredentials({\n      access_token: accessToken,\n      refresh_token: refreshToken || undefined,\n    });\n\n    console.log(\"Creating Gmail API client...\");\n    const gmail = google.gmail({ version: \"v1\", auth: oauth2Client });\n\n    console.log(\"Fetching emails from Gmail API...\");\n    const response = await gmail.users.messages.list({\n      userId: \"me\",\n      maxResults: maxResults,\n      q: \"in:inbox\",\n    });\n\n    console.log(`Retrieved ${response.data.messages?.length || 0} email IDs`);\n\n    if (!response.data.messages || response.data.messages.length === 0) {\n      console.log(\"No emails found\");\n      return [];\n    }\n\n    // Get email details for each message ID\n    console.log(\"Fetching email details...\");\n    const emails = await Promise.all(\n      response.data.messages.map(async (message) => {\n        if (!message.id) return null;\n\n        const emailDetail = await gmail.users.messages.get({\n          userId: \"me\",\n          id: message.id,\n        });\n\n        const headers = emailDetail.data.payload?.headers || [];\n\n        // Extract email headers\n        const subject =\n          headers.find((h) => h.name === \"Subject\")?.value || \"(No subject)\";\n        const from = headers.find((h) => h.name === \"From\")?.value || \"\";\n        const to = headers.find((h) => h.name === \"To\")?.value || \"\";\n        const date = headers.find((h) => h.name === \"Date\")?.value || \"\";\n\n        // Extract email body (text or HTML)\n        let body = \"\";\n        const parts = emailDetail.data.payload?.parts || [];\n\n        if (parts.length > 0) {\n          // Try to find HTML body first\n          const htmlPart = parts.find((p) => p.mimeType === \"text/html\");\n          const textPart = parts.find((p) => p.mimeType === \"text/plain\");\n\n          if (htmlPart && htmlPart.body && htmlPart.body.data) {\n            body = Buffer.from(htmlPart.body.data, \"base64\").toString(\"utf-8\");\n          } else if (textPart && textPart.body && textPart.body.data) {\n            body = Buffer.from(textPart.body.data, \"base64\").toString(\"utf-8\");\n          }\n        } else if (emailDetail.data.payload?.body?.data) {\n          // For single-part messages\n          body = Buffer.from(\n            emailDetail.data.payload.body.data,\n            \"base64\",\n          ).toString(\"utf-8\");\n        }\n\n        // Create a snippet from the body (first 100 chars)\n        const snippet =\n          body.substring(0, 100) + (body.length > 100 ? \"...\" : \"\");\n\n        return {\n          id: message.id,\n          threadId: emailDetail.data.threadId,\n          labelIds: emailDetail.data.labelIds || [],\n          snippet: emailDetail.data.snippet || snippet,\n          subject,\n          from,\n          to,\n          date,\n          body,\n        };\n      }),\n    );\n\n    console.log(`Fetched details for ${emails.filter(Boolean).length} emails`);\n    return emails.filter(Boolean);\n  } catch (error) {\n    console.error(\"Error in fetchGmailEmails:\", error);\n    if (error instanceof Error) {\n      console.error(\"Error details:\", {\n        message: error.message,\n        stack: error.stack,\n      });\n    }\n    throw error;\n  }\n};\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 849, "column": 0}, "map": {"version":3,"sources":["file:///Users/aveekpatra/Coding/lumi/src/app/api/gmail/emails/route.ts"],"sourcesContent":["\"use server\";\n\nimport { db } from \"@/server/db\";\nimport { fetchGmailEmails, refreshGmailToken } from \"@/lib/gmail\";\nimport { auth } from \"@clerk/nextjs/server\";\nimport { NextResponse } from \"next/server\";\nimport { headers } from \"next/headers\";\n\nexport async function GET(req: Request) {\n  try {\n    // Get query parameters\n    const url = new URL(req.url);\n    const limit = parseInt(url.searchParams.get(\"limit\") || \"20\");\n    const accountId = url.searchParams.get(\"accountId\");\n\n    console.log(\n      `[GMAIL EMAILS] Fetching emails, limit: ${limit}, accountId: ${accountId}`,\n    );\n\n    // Get user from auth - explicitly wait for headers\n    const headersList = headers();\n    const { userId } = await auth({ headersList });\n\n    if (!userId) {\n      console.error(\"[GMAIL EMAILS] No user ID found in auth\");\n      return NextResponse.json({ error: \"Unauthorized\" }, { status: 401 });\n    }\n\n    console.log(\"[GMAIL EMAILS] Authenticated user:\", userId);\n\n    // If accountId is provided, use that specific account\n    // Otherwise, get the first Gmail account\n    let account;\n    if (accountId) {\n      account = await db.account.findUnique({\n        where: {\n          id: accountId,\n          userId: userId,\n          provider: \"Gmail\",\n        },\n      });\n    } else {\n      account = await db.account.findFirst({\n        where: {\n          userId: userId,\n          provider: \"Gmail\",\n        },\n      });\n    }\n\n    if (!account) {\n      console.error(\"[GMAIL EMAILS] No Gmail account found for user:\", userId);\n      return NextResponse.json(\n        { error: \"No Gmail account found\" },\n        { status: 404 },\n      );\n    }\n\n    console.log(\n      `[GMAIL EMAILS] Found account: ${account.emailAddress}, ID: ${account.id}`,\n    );\n\n    try {\n      // Try to fetch emails using the current access token\n      console.log(\"Attempting to fetch emails with current access token\");\n      console.log(\"Token info:\", {\n        tokenLength: account.token?.length || 0,\n        hasRefreshToken: !!account.refreshToken,\n        refreshTokenLength: account.refreshToken?.length || 0,\n      });\n      const emails = await fetchGmailEmails(\n        account.token,\n        limit,\n        account.refreshToken,\n      );\n\n      console.log(\n        `[GMAIL EMAILS] Successfully fetched ${emails.length} emails`,\n      );\n\n      return NextResponse.json({\n        emails,\n        account: {\n          id: account.id,\n          emailAddress: account.emailAddress,\n          name: account.name,\n        },\n      });\n    } catch (error) {\n      // If the token is invalid, try refreshing it\n      if (\n        error instanceof Error &&\n        (error.message.includes(\"Invalid Credentials\") ||\n          error.message.includes(\"401\") ||\n          error.message.includes(\"invalid_grant\") ||\n          error.message.includes(\"unauthorized\")) &&\n        account.refreshToken\n      ) {\n        console.log(\n          \"[GMAIL EMAILS] Access token expired, attempting to refresh\",\n        );\n        console.log(\"Refresh token info:\", {\n          refreshTokenExists: !!account.refreshToken,\n          refreshTokenLength: account.refreshToken?.length || 0,\n        });\n\n        try {\n          // Refresh the token\n          const { accessToken } = await refreshGmailToken(account.refreshToken);\n\n          // Update the token in the database\n          await db.account.update({\n            where: { id: account.id },\n            data: { token: accessToken },\n          });\n\n          console.log(\n            \"[GMAIL EMAILS] Token refreshed successfully, retrying fetch\",\n          );\n          console.log(\"New token info:\", {\n            tokenLength: accessToken?.length || 0,\n          });\n\n          // Retry with the new token\n          const emails = await fetchGmailEmails(\n            accessToken,\n            limit,\n            account.refreshToken,\n          );\n\n          console.log(\n            `[GMAIL EMAILS] Successfully fetched ${emails.length} emails after token refresh`,\n          );\n\n          return NextResponse.json({\n            emails,\n            account: {\n              id: account.id,\n              emailAddress: account.emailAddress,\n              name: account.name,\n            },\n          });\n        } catch (refreshError) {\n          console.error(\n            \"[GMAIL EMAILS] Failed to refresh token:\",\n            refreshError,\n          );\n          console.error(\n            \"Error details:\",\n            refreshError instanceof Error\n              ? refreshError.message\n              : \"Unknown error\",\n          );\n          return NextResponse.json(\n            {\n              error: \"Failed to refresh Gmail access token\",\n              message:\n                \"Your Gmail access has expired. Please reconnect your account.\",\n            },\n            { status: 401 },\n          );\n        }\n      }\n\n      // If not a token issue or no refresh token available, rethrow the error\n      throw error;\n    }\n  } catch (error) {\n    console.error(\"[GMAIL EMAILS] Error fetching emails:\", error);\n\n    if (error instanceof Error) {\n      return NextResponse.json(\n        {\n          error: \"Failed to fetch emails\",\n          message: error.message,\n        },\n        { status: 500 },\n      );\n    }\n\n    return NextResponse.json(\n      {\n        error: \"Failed to fetch emails\",\n      },\n      { status: 500 },\n    );\n  }\n}\n"],"names":[],"mappings":"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","debugId":null}}]
}